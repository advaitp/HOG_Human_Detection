\hypertarget{AmbiVector_8h_source}{}\doxysection{Ambi\+Vector.\+h}
\label{AmbiVector_8h_source}\index{include/Eigen/src/SparseCore/AmbiVector.h@{include/Eigen/src/SparseCore/AmbiVector.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}}
\DoxyCodeLine{2 \textcolor{comment}{// for linear algebra.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}}
\DoxyCodeLine{7 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}}
\DoxyCodeLine{8 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}}
\DoxyCodeLine{9 }
\DoxyCodeLine{10 \textcolor{preprocessor}{\#ifndef EIGEN\_AMBIVECTOR\_H}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#define EIGEN\_AMBIVECTOR\_H}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include "{}./InternalHeaderCheck.h"{}}}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceEigen}{Eigen}} \{ }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{18 }
\DoxyCodeLine{24 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_, \textcolor{keyword}{typename} StorageIndex\_>}
\DoxyCodeLine{25 \textcolor{keyword}{class }\mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector}{AmbiVector}}}
\DoxyCodeLine{26 \{}
\DoxyCodeLine{27   \textcolor{keyword}{public}:}
\DoxyCodeLine{28     \textcolor{keyword}{typedef} Scalar\_ Scalar;}
\DoxyCodeLine{29     \textcolor{keyword}{typedef} StorageIndex\_ StorageIndex;}
\DoxyCodeLine{30     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1NumTraits}{NumTraits<Scalar>::Real}} RealScalar;}
\DoxyCodeLine{31 }
\DoxyCodeLine{32     \textcolor{keyword}{explicit} \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector}{AmbiVector}}(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} size)}
\DoxyCodeLine{33       : m\_buffer(0), m\_zero(0), m\_size(0), m\_end(0), m\_allocatedSize(0), m\_allocatedElements(0), m\_mode(-\/1)}
\DoxyCodeLine{34     \{}
\DoxyCodeLine{35       resize(size);}
\DoxyCodeLine{36     \}}
\DoxyCodeLine{37 }
\DoxyCodeLine{38     \textcolor{keywordtype}{void} init(\textcolor{keywordtype}{double} estimatedDensity);}
\DoxyCodeLine{39     \textcolor{keywordtype}{void} init(\textcolor{keywordtype}{int} mode);}
\DoxyCodeLine{40 }
\DoxyCodeLine{41     \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector_a0ced8efb0cb8181ce6268e90a7b5d47d}{nonZeros}}() \textcolor{keyword}{const};}
\DoxyCodeLine{42 }
\DoxyCodeLine{44     \textcolor{keywordtype}{void} \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector_adcb6346ba2be93f13be1aa430fa5356d}{setBounds}}(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} start, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} end) \{ m\_start = convert\_index(start); m\_end = convert\_index(end); \}}
\DoxyCodeLine{45 }
\DoxyCodeLine{46     \textcolor{keywordtype}{void} \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector_a7f66033ac294a0b900653fd908b2e043}{setZero}}();}
\DoxyCodeLine{47 }
\DoxyCodeLine{48     \textcolor{keywordtype}{void} \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector_ab5d3099bee58e06224dfb5ee1341685f}{restart}}();}
\DoxyCodeLine{49     Scalar\& coeffRef(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i);}
\DoxyCodeLine{50     Scalar\& coeff(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i);}
\DoxyCodeLine{51 }
\DoxyCodeLine{52     \textcolor{keyword}{class }Iterator;}
\DoxyCodeLine{53 }
\DoxyCodeLine{54     \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector}{\string~AmbiVector}}() \{ \textcolor{keyword}{delete}[] m\_buffer; \}}
\DoxyCodeLine{55 }
\DoxyCodeLine{56     \textcolor{keywordtype}{void} resize(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} size)}
\DoxyCodeLine{57     \{}
\DoxyCodeLine{58       \textcolor{keywordflow}{if} (m\_allocatedSize < size)}
\DoxyCodeLine{59         reallocate(size);}
\DoxyCodeLine{60       m\_size = convert\_index(size);}
\DoxyCodeLine{61     \}}
\DoxyCodeLine{62 }
\DoxyCodeLine{63     StorageIndex size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_size; \}}
\DoxyCodeLine{64 }
\DoxyCodeLine{65   \textcolor{keyword}{protected}:}
\DoxyCodeLine{66     StorageIndex convert\_index(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} idx)}
\DoxyCodeLine{67     \{}
\DoxyCodeLine{68       \textcolor{keywordflow}{return} internal::convert\_index<StorageIndex>(idx);}
\DoxyCodeLine{69     \}}
\DoxyCodeLine{70 }
\DoxyCodeLine{71     \textcolor{keywordtype}{void} reallocate(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} size)}
\DoxyCodeLine{72     \{}
\DoxyCodeLine{73       \textcolor{comment}{// if the size of the matrix is not too large, let's allocate a bit more than needed such}}
\DoxyCodeLine{74       \textcolor{comment}{// that we can handle dense vector even in sparse mode.}}
\DoxyCodeLine{75       \textcolor{keyword}{delete}[] m\_buffer;}
\DoxyCodeLine{76       \textcolor{keywordflow}{if} (size<1000)}
\DoxyCodeLine{77       \{}
\DoxyCodeLine{78         \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} allocSize = (size * \textcolor{keyword}{sizeof}(ListEl) + \textcolor{keyword}{sizeof}(Scalar) -\/ 1)/\textcolor{keyword}{sizeof}(Scalar);}
\DoxyCodeLine{79         m\_allocatedElements = convert\_index((allocSize*\textcolor{keyword}{sizeof}(Scalar))/\textcolor{keyword}{sizeof}(ListEl));}
\DoxyCodeLine{80         m\_buffer = \textcolor{keyword}{new} Scalar[allocSize];}
\DoxyCodeLine{81       \}}
\DoxyCodeLine{82       \textcolor{keywordflow}{else}}
\DoxyCodeLine{83       \{}
\DoxyCodeLine{84         m\_allocatedElements = convert\_index((size*\textcolor{keyword}{sizeof}(Scalar))/\textcolor{keyword}{sizeof}(ListEl));}
\DoxyCodeLine{85         m\_buffer = \textcolor{keyword}{new} Scalar[size];}
\DoxyCodeLine{86       \}}
\DoxyCodeLine{87       m\_size = convert\_index(size);}
\DoxyCodeLine{88       m\_start = 0;}
\DoxyCodeLine{89       m\_end = m\_size;}
\DoxyCodeLine{90     \}}
\DoxyCodeLine{91 }
\DoxyCodeLine{92     \textcolor{keywordtype}{void} reallocateSparse()}
\DoxyCodeLine{93     \{}
\DoxyCodeLine{94       \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} copyElements = m\_allocatedElements;}
\DoxyCodeLine{95       m\_allocatedElements = (std::min)(StorageIndex(m\_allocatedElements*1.5),m\_size);}
\DoxyCodeLine{96       \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} allocSize = m\_allocatedElements * \textcolor{keyword}{sizeof}(ListEl);}
\DoxyCodeLine{97       allocSize = (allocSize + \textcolor{keyword}{sizeof}(Scalar) -\/ 1)/\textcolor{keyword}{sizeof}(Scalar);}
\DoxyCodeLine{98       Scalar* newBuffer = \textcolor{keyword}{new} Scalar[allocSize];}
\DoxyCodeLine{99       std::memcpy(newBuffer,  m\_buffer,  copyElements * \textcolor{keyword}{sizeof}(ListEl));}
\DoxyCodeLine{100       \textcolor{keyword}{delete}[] m\_buffer;}
\DoxyCodeLine{101       m\_buffer = newBuffer;}
\DoxyCodeLine{102     \}}
\DoxyCodeLine{103 }
\DoxyCodeLine{104   \textcolor{keyword}{protected}:}
\DoxyCodeLine{105     \textcolor{comment}{// element type of the linked list}}
\DoxyCodeLine{106     \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1AmbiVector_1_1ListEl}{ListEl}}}
\DoxyCodeLine{107     \{}
\DoxyCodeLine{108       StorageIndex next;}
\DoxyCodeLine{109       StorageIndex index;}
\DoxyCodeLine{110       Scalar value;}
\DoxyCodeLine{111     \};}
\DoxyCodeLine{112 }
\DoxyCodeLine{113     \textcolor{comment}{// used to store data in both mode}}
\DoxyCodeLine{114     Scalar* m\_buffer;}
\DoxyCodeLine{115     Scalar m\_zero;}
\DoxyCodeLine{116     StorageIndex m\_size;}
\DoxyCodeLine{117     StorageIndex m\_start;}
\DoxyCodeLine{118     StorageIndex m\_end;}
\DoxyCodeLine{119     StorageIndex m\_allocatedSize;}
\DoxyCodeLine{120     StorageIndex m\_allocatedElements;}
\DoxyCodeLine{121     StorageIndex m\_mode;}
\DoxyCodeLine{122 }
\DoxyCodeLine{123     \textcolor{comment}{// linked list mode}}
\DoxyCodeLine{124     StorageIndex m\_llStart;}
\DoxyCodeLine{125     StorageIndex m\_llCurrent;}
\DoxyCodeLine{126     StorageIndex m\_llSize;}
\DoxyCodeLine{127 \};}
\DoxyCodeLine{128 }
\DoxyCodeLine{130 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_,\textcolor{keyword}{typename} StorageIndex\_>}
\DoxyCodeLine{131 \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector_a0ced8efb0cb8181ce6268e90a7b5d47d}{AmbiVector<Scalar\_,StorageIndex\_>::nonZeros}}()\textcolor{keyword}{ const}}
\DoxyCodeLine{132 \textcolor{keyword}{}\{}
\DoxyCodeLine{133   \textcolor{keywordflow}{if} (m\_mode==IsSparse)}
\DoxyCodeLine{134     \textcolor{keywordflow}{return} m\_llSize;}
\DoxyCodeLine{135   \textcolor{keywordflow}{else}}
\DoxyCodeLine{136     \textcolor{keywordflow}{return} m\_end -\/ m\_start;}
\DoxyCodeLine{137 \}}
\DoxyCodeLine{138 }
\DoxyCodeLine{139 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_,\textcolor{keyword}{typename} StorageIndex\_>}
\DoxyCodeLine{140 \textcolor{keywordtype}{void} \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector}{AmbiVector<Scalar\_,StorageIndex\_>::init}}(\textcolor{keywordtype}{double} estimatedDensity)}
\DoxyCodeLine{141 \{}
\DoxyCodeLine{142   \textcolor{keywordflow}{if} (estimatedDensity>0.1)}
\DoxyCodeLine{143     init(IsDense);}
\DoxyCodeLine{144   \textcolor{keywordflow}{else}}
\DoxyCodeLine{145     init(IsSparse);}
\DoxyCodeLine{146 \}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_,\textcolor{keyword}{typename} StorageIndex\_>}
\DoxyCodeLine{149 \textcolor{keywordtype}{void} AmbiVector<Scalar\_,StorageIndex\_>::init(\textcolor{keywordtype}{int} mode)}
\DoxyCodeLine{150 \{}
\DoxyCodeLine{151   m\_mode = mode;}
\DoxyCodeLine{152   \textcolor{comment}{// This is only necessary in sparse mode, but we set these unconditionally to avoid some maybe-\/uninitialized warnings}}
\DoxyCodeLine{153   \textcolor{comment}{// if (m\_mode==IsSparse)}}
\DoxyCodeLine{154   \{}
\DoxyCodeLine{155     m\_llSize = 0;}
\DoxyCodeLine{156     m\_llStart = -\/1;}
\DoxyCodeLine{157   \}}
\DoxyCodeLine{158 \}}
\DoxyCodeLine{159 }
\DoxyCodeLine{165 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_,\textcolor{keyword}{typename} StorageIndex\_>}
\DoxyCodeLine{166 \textcolor{keywordtype}{void} \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector_ab5d3099bee58e06224dfb5ee1341685f}{AmbiVector<Scalar\_,StorageIndex\_>::restart}}()}
\DoxyCodeLine{167 \{}
\DoxyCodeLine{168   m\_llCurrent = m\_llStart;}
\DoxyCodeLine{169 \}}
\DoxyCodeLine{170 }
\DoxyCodeLine{172 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_,\textcolor{keyword}{typename} StorageIndex\_>}
\DoxyCodeLine{173 \textcolor{keywordtype}{void} \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector_a7f66033ac294a0b900653fd908b2e043}{AmbiVector<Scalar\_,StorageIndex\_>::setZero}}()}
\DoxyCodeLine{174 \{}
\DoxyCodeLine{175   \textcolor{keywordflow}{if} (m\_mode==IsDense)}
\DoxyCodeLine{176   \{}
\DoxyCodeLine{177     \textcolor{keywordflow}{for} (\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i=m\_start; i<m\_end; ++i)}
\DoxyCodeLine{178       m\_buffer[i] = Scalar(0);}
\DoxyCodeLine{179   \}}
\DoxyCodeLine{180   \textcolor{keywordflow}{else}}
\DoxyCodeLine{181   \{}
\DoxyCodeLine{182     eigen\_assert(m\_mode==IsSparse);}
\DoxyCodeLine{183     m\_llSize = 0;}
\DoxyCodeLine{184     m\_llStart = -\/1;}
\DoxyCodeLine{185   \}}
\DoxyCodeLine{186 \}}
\DoxyCodeLine{187 }
\DoxyCodeLine{188 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_,\textcolor{keyword}{typename} StorageIndex\_>}
\DoxyCodeLine{189 Scalar\_\& \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector}{AmbiVector<Scalar\_,StorageIndex\_>::coeffRef}}(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i)}
\DoxyCodeLine{190 \{}
\DoxyCodeLine{191   \textcolor{keywordflow}{if} (m\_mode==IsDense)}
\DoxyCodeLine{192     \textcolor{keywordflow}{return} m\_buffer[i];}
\DoxyCodeLine{193   \textcolor{keywordflow}{else}}
\DoxyCodeLine{194   \{}
\DoxyCodeLine{195     ListEl* EIGEN\_RESTRICT llElements = \textcolor{keyword}{reinterpret\_cast<}ListEl*\textcolor{keyword}{>}(m\_buffer);}
\DoxyCodeLine{196     \textcolor{comment}{// TODO factorize the following code to reduce code generation}}
\DoxyCodeLine{197     eigen\_assert(m\_mode==IsSparse);}
\DoxyCodeLine{198     \textcolor{keywordflow}{if} (m\_llSize==0)}
\DoxyCodeLine{199     \{}
\DoxyCodeLine{200       \textcolor{comment}{// this is the first element}}
\DoxyCodeLine{201       m\_llStart = 0;}
\DoxyCodeLine{202       m\_llCurrent = 0;}
\DoxyCodeLine{203       ++m\_llSize;}
\DoxyCodeLine{204       llElements[0].value = Scalar(0);}
\DoxyCodeLine{205       llElements[0].index = convert\_index(i);}
\DoxyCodeLine{206       llElements[0].next = -\/1;}
\DoxyCodeLine{207       \textcolor{keywordflow}{return} llElements[0].value;}
\DoxyCodeLine{208     \}}
\DoxyCodeLine{209     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (i<llElements[m\_llStart].index)}
\DoxyCodeLine{210     \{}
\DoxyCodeLine{211       \textcolor{comment}{// this is going to be the new first element of the list}}
\DoxyCodeLine{212       ListEl\& el = llElements[m\_llSize];}
\DoxyCodeLine{213       el.value = Scalar(0);}
\DoxyCodeLine{214       el.index = convert\_index(i);}
\DoxyCodeLine{215       el.next = m\_llStart;}
\DoxyCodeLine{216       m\_llStart = m\_llSize;}
\DoxyCodeLine{217       ++m\_llSize;}
\DoxyCodeLine{218       m\_llCurrent = m\_llStart;}
\DoxyCodeLine{219       \textcolor{keywordflow}{return} el.value;}
\DoxyCodeLine{220     \}}
\DoxyCodeLine{221     \textcolor{keywordflow}{else}}
\DoxyCodeLine{222     \{}
\DoxyCodeLine{223       StorageIndex nextel = llElements[m\_llCurrent].next;}
\DoxyCodeLine{224       eigen\_assert(i>=llElements[m\_llCurrent].index \&\& \textcolor{stringliteral}{"{}you must call restart() before inserting an element with lower or equal index"{}});}
\DoxyCodeLine{225       \textcolor{keywordflow}{while} (nextel >= 0 \&\& llElements[nextel].index<=i)}
\DoxyCodeLine{226       \{}
\DoxyCodeLine{227         m\_llCurrent = nextel;}
\DoxyCodeLine{228         nextel = llElements[nextel].next;}
\DoxyCodeLine{229       \}}
\DoxyCodeLine{230 }
\DoxyCodeLine{231       \textcolor{keywordflow}{if} (llElements[m\_llCurrent].index==i)}
\DoxyCodeLine{232       \{}
\DoxyCodeLine{233         \textcolor{comment}{// the coefficient already exists and we found it !}}
\DoxyCodeLine{234         \textcolor{keywordflow}{return} llElements[m\_llCurrent].value;}
\DoxyCodeLine{235       \}}
\DoxyCodeLine{236       \textcolor{keywordflow}{else}}
\DoxyCodeLine{237       \{}
\DoxyCodeLine{238         \textcolor{keywordflow}{if} (m\_llSize>=m\_allocatedElements)}
\DoxyCodeLine{239         \{}
\DoxyCodeLine{240           reallocateSparse();}
\DoxyCodeLine{241           llElements = \textcolor{keyword}{reinterpret\_cast<}ListEl*\textcolor{keyword}{>}(m\_buffer);}
\DoxyCodeLine{242         \}}
\DoxyCodeLine{243         eigen\_internal\_assert(m\_llSize<m\_allocatedElements \&\& \textcolor{stringliteral}{"{}internal error: overflow in sparse mode"{}});}
\DoxyCodeLine{244         \textcolor{comment}{// let's insert a new coefficient}}
\DoxyCodeLine{245         ListEl\& el = llElements[m\_llSize];}
\DoxyCodeLine{246         el.value = Scalar(0);}
\DoxyCodeLine{247         el.index = convert\_index(i);}
\DoxyCodeLine{248         el.next = llElements[m\_llCurrent].next;}
\DoxyCodeLine{249         llElements[m\_llCurrent].next = m\_llSize;}
\DoxyCodeLine{250         ++m\_llSize;}
\DoxyCodeLine{251         \textcolor{keywordflow}{return} el.value;}
\DoxyCodeLine{252       \}}
\DoxyCodeLine{253     \}}
\DoxyCodeLine{254   \}}
\DoxyCodeLine{255 \}}
\DoxyCodeLine{256 }
\DoxyCodeLine{257 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_,\textcolor{keyword}{typename} StorageIndex\_>}
\DoxyCodeLine{258 Scalar\_\& AmbiVector<Scalar\_,StorageIndex\_>::coeff(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i)}
\DoxyCodeLine{259 \{}
\DoxyCodeLine{260   \textcolor{keywordflow}{if} (m\_mode==IsDense)}
\DoxyCodeLine{261     \textcolor{keywordflow}{return} m\_buffer[i];}
\DoxyCodeLine{262   \textcolor{keywordflow}{else}}
\DoxyCodeLine{263   \{}
\DoxyCodeLine{264     ListEl* EIGEN\_RESTRICT llElements = \textcolor{keyword}{reinterpret\_cast<}ListEl*\textcolor{keyword}{>}(m\_buffer);}
\DoxyCodeLine{265     eigen\_assert(m\_mode==IsSparse);}
\DoxyCodeLine{266     \textcolor{keywordflow}{if} ((m\_llSize==0) || (i<llElements[m\_llStart].index))}
\DoxyCodeLine{267     \{}
\DoxyCodeLine{268       \textcolor{keywordflow}{return} m\_zero;}
\DoxyCodeLine{269     \}}
\DoxyCodeLine{270     \textcolor{keywordflow}{else}}
\DoxyCodeLine{271     \{}
\DoxyCodeLine{272       \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} elid = m\_llStart;}
\DoxyCodeLine{273       \textcolor{keywordflow}{while} (elid >= 0 \&\& llElements[elid].index<i)}
\DoxyCodeLine{274         elid = llElements[elid].next;}
\DoxyCodeLine{275 }
\DoxyCodeLine{276       \textcolor{keywordflow}{if} (llElements[elid].index==i)}
\DoxyCodeLine{277         \textcolor{keywordflow}{return} llElements[m\_llCurrent].value;}
\DoxyCodeLine{278       \textcolor{keywordflow}{else}}
\DoxyCodeLine{279         \textcolor{keywordflow}{return} m\_zero;}
\DoxyCodeLine{280     \}}
\DoxyCodeLine{281   \}}
\DoxyCodeLine{282 \}}
\DoxyCodeLine{283 }
\DoxyCodeLine{285 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_,\textcolor{keyword}{typename} StorageIndex\_>}
\DoxyCodeLine{286 \textcolor{keyword}{class }\mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector}{AmbiVector}}<Scalar\_,StorageIndex\_>::\mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector_1_1Iterator}{Iterator}}}
\DoxyCodeLine{287 \{}
\DoxyCodeLine{288   \textcolor{keyword}{public}:}
\DoxyCodeLine{289     \textcolor{keyword}{typedef} Scalar\_ Scalar;}
\DoxyCodeLine{290     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1NumTraits}{NumTraits<Scalar>::Real}} RealScalar;}
\DoxyCodeLine{291 }
\DoxyCodeLine{298     \textcolor{keyword}{explicit} \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector_1_1Iterator_a952fa26dfc9193e6c4fd0b802c1b158e}{Iterator}}(\textcolor{keyword}{const} \mbox{\hyperlink{classEigen_1_1internal_1_1AmbiVector}{AmbiVector}}\& vec, \textcolor{keyword}{const} RealScalar\& epsilon = 0)}
\DoxyCodeLine{299       : m\_vector(vec)}
\DoxyCodeLine{300     \{}
\DoxyCodeLine{301       \textcolor{keyword}{using} std::abs;}
\DoxyCodeLine{302       m\_epsilon = epsilon;}
\DoxyCodeLine{303       m\_isDense = m\_vector.m\_mode==IsDense;}
\DoxyCodeLine{304       \textcolor{keywordflow}{if} (m\_isDense)}
\DoxyCodeLine{305       \{}
\DoxyCodeLine{306         m\_currentEl = 0;   \textcolor{comment}{// this is to avoid a compilation warning}}
\DoxyCodeLine{307         m\_cachedValue = 0; \textcolor{comment}{// this is to avoid a compilation warning}}
\DoxyCodeLine{308         m\_cachedIndex = m\_vector.m\_start-\/1;}
\DoxyCodeLine{309         ++(*this);}
\DoxyCodeLine{310       \}}
\DoxyCodeLine{311       \textcolor{keywordflow}{else}}
\DoxyCodeLine{312       \{}
\DoxyCodeLine{313         \mbox{\hyperlink{structEigen_1_1internal_1_1AmbiVector_1_1ListEl}{ListEl}}* EIGEN\_RESTRICT llElements = \textcolor{keyword}{reinterpret\_cast<}\mbox{\hyperlink{structEigen_1_1internal_1_1AmbiVector_1_1ListEl}{ListEl}}*\textcolor{keyword}{>}(m\_vector.m\_buffer);}
\DoxyCodeLine{314         m\_currentEl = m\_vector.m\_llStart;}
\DoxyCodeLine{315         \textcolor{keywordflow}{while} (m\_currentEl>=0 \&\& abs(llElements[m\_currentEl].value)<=m\_epsilon)}
\DoxyCodeLine{316           m\_currentEl = llElements[m\_currentEl].next;}
\DoxyCodeLine{317         \textcolor{keywordflow}{if} (m\_currentEl<0)}
\DoxyCodeLine{318         \{}
\DoxyCodeLine{319           m\_cachedValue = 0; \textcolor{comment}{// this is to avoid a compilation warning}}
\DoxyCodeLine{320           m\_cachedIndex = -\/1;}
\DoxyCodeLine{321         \}}
\DoxyCodeLine{322         \textcolor{keywordflow}{else}}
\DoxyCodeLine{323         \{}
\DoxyCodeLine{324           m\_cachedIndex = llElements[m\_currentEl].index;}
\DoxyCodeLine{325           m\_cachedValue = llElements[m\_currentEl].value;}
\DoxyCodeLine{326         \}}
\DoxyCodeLine{327       \}}
\DoxyCodeLine{328     \}}
\DoxyCodeLine{329 }
\DoxyCodeLine{330     StorageIndex index()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_cachedIndex; \}}
\DoxyCodeLine{331     Scalar value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_cachedValue; \}}
\DoxyCodeLine{332 }
\DoxyCodeLine{333     \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_cachedIndex>=0; \}}
\DoxyCodeLine{334 }
\DoxyCodeLine{335     Iterator\& operator++()}
\DoxyCodeLine{336     \{}
\DoxyCodeLine{337       \textcolor{keyword}{using} std::abs;}
\DoxyCodeLine{338       \textcolor{keywordflow}{if} (m\_isDense)}
\DoxyCodeLine{339       \{}
\DoxyCodeLine{340         \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{341           ++m\_cachedIndex;}
\DoxyCodeLine{342         \} \textcolor{keywordflow}{while} (m\_cachedIndex<m\_vector.m\_end \&\& abs(m\_vector.m\_buffer[m\_cachedIndex])<=m\_epsilon);}
\DoxyCodeLine{343         \textcolor{keywordflow}{if} (m\_cachedIndex<m\_vector.m\_end)}
\DoxyCodeLine{344           m\_cachedValue = m\_vector.m\_buffer[m\_cachedIndex];}
\DoxyCodeLine{345         \textcolor{keywordflow}{else}}
\DoxyCodeLine{346           m\_cachedIndex=-\/1;}
\DoxyCodeLine{347       \}}
\DoxyCodeLine{348       \textcolor{keywordflow}{else}}
\DoxyCodeLine{349       \{}
\DoxyCodeLine{350         ListEl* EIGEN\_RESTRICT llElements = \textcolor{keyword}{reinterpret\_cast<}ListEl*\textcolor{keyword}{>}(m\_vector.m\_buffer);}
\DoxyCodeLine{351         \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{352           m\_currentEl = llElements[m\_currentEl].next;}
\DoxyCodeLine{353         \} \textcolor{keywordflow}{while} (m\_currentEl>=0 \&\& abs(llElements[m\_currentEl].value)<=m\_epsilon);}
\DoxyCodeLine{354         \textcolor{keywordflow}{if} (m\_currentEl<0)}
\DoxyCodeLine{355         \{}
\DoxyCodeLine{356           m\_cachedIndex = -\/1;}
\DoxyCodeLine{357         \}}
\DoxyCodeLine{358         \textcolor{keywordflow}{else}}
\DoxyCodeLine{359         \{}
\DoxyCodeLine{360           m\_cachedIndex = llElements[m\_currentEl].index;}
\DoxyCodeLine{361           m\_cachedValue = llElements[m\_currentEl].value;}
\DoxyCodeLine{362         \}}
\DoxyCodeLine{363       \}}
\DoxyCodeLine{364       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{365     \}}
\DoxyCodeLine{366 }
\DoxyCodeLine{367   \textcolor{keyword}{protected}:}
\DoxyCodeLine{368     \textcolor{keyword}{const} AmbiVector\& m\_vector; \textcolor{comment}{// the target vector}}
\DoxyCodeLine{369     StorageIndex m\_currentEl;   \textcolor{comment}{// the current element in sparse/linked-\/list mode}}
\DoxyCodeLine{370     RealScalar m\_epsilon;       \textcolor{comment}{// epsilon used to prune zero coefficients}}
\DoxyCodeLine{371     StorageIndex m\_cachedIndex; \textcolor{comment}{// current coordinate}}
\DoxyCodeLine{372     Scalar m\_cachedValue;       \textcolor{comment}{// current value}}
\DoxyCodeLine{373     \textcolor{keywordtype}{bool} m\_isDense;             \textcolor{comment}{// mode of the vector}}
\DoxyCodeLine{374 \};}
\DoxyCodeLine{375 }
\DoxyCodeLine{376 \} \textcolor{comment}{// end namespace internal}}
\DoxyCodeLine{377 }
\DoxyCodeLine{378 \} \textcolor{comment}{// end namespace Eigen}}
\DoxyCodeLine{379 }
\DoxyCodeLine{380 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// EIGEN\_AMBIVECTOR\_H}}

\end{DoxyCode}
