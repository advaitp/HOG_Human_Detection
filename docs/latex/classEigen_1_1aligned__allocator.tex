\hypertarget{classEigen_1_1aligned__allocator}{}\doxysection{Eigen\+::aligned\+\_\+allocator\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>} Class Template Reference}
\label{classEigen_1_1aligned__allocator}\index{Eigen::aligned\_allocator$<$ T $>$@{Eigen::aligned\_allocator$<$ T $>$}}


STL compatible allocator to use with types requiring a non standrad alignment.  




{\ttfamily \#include $<$Memory.\+h$>$}

Inheritance diagram for Eigen\+::aligned\+\_\+allocator\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>}\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classEigen_1_1aligned__allocator}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structEigen_1_1aligned__allocator_1_1rebind}{rebind}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classEigen_1_1aligned__allocator_a2250815f042d86cb48c8e8fb960db280}\label{classEigen_1_1aligned__allocator_a2250815f042d86cb48c8e8fb960db280}} 
typedef std\+::size\+\_\+t {\bfseries size\+\_\+type}
\item 
\mbox{\Hypertarget{classEigen_1_1aligned__allocator_a390bc09fb087d94423c42cf3428f0a24}\label{classEigen_1_1aligned__allocator_a390bc09fb087d94423c42cf3428f0a24}} 
typedef std\+::ptrdiff\+\_\+t {\bfseries difference\+\_\+type}
\item 
\mbox{\Hypertarget{classEigen_1_1aligned__allocator_a0973991f7b26d4113d52aa57284e0360}\label{classEigen_1_1aligned__allocator_a0973991f7b26d4113d52aa57284e0360}} 
typedef T $\ast$ {\bfseries pointer}
\item 
\mbox{\Hypertarget{classEigen_1_1aligned__allocator_aa225f4ea011fce1e792423ad02d5de01}\label{classEigen_1_1aligned__allocator_aa225f4ea011fce1e792423ad02d5de01}} 
typedef const T $\ast$ {\bfseries const\+\_\+pointer}
\item 
\mbox{\Hypertarget{classEigen_1_1aligned__allocator_a0c3b4937cc7a495af864800176e3b9ca}\label{classEigen_1_1aligned__allocator_a0c3b4937cc7a495af864800176e3b9ca}} 
typedef T \& {\bfseries reference}
\item 
\mbox{\Hypertarget{classEigen_1_1aligned__allocator_a2f2cd14e4335018c07585467d579207a}\label{classEigen_1_1aligned__allocator_a2f2cd14e4335018c07585467d579207a}} 
typedef const T \& {\bfseries const\+\_\+reference}
\item 
\mbox{\Hypertarget{classEigen_1_1aligned__allocator_a2188bac5dd2a2208a02c9dc934acb451}\label{classEigen_1_1aligned__allocator_a2188bac5dd2a2208a02c9dc934acb451}} 
typedef T {\bfseries value\+\_\+type}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classEigen_1_1aligned__allocator_a7076a7a6ccb57759a910860135253543}\label{classEigen_1_1aligned__allocator_a7076a7a6ccb57759a910860135253543}} 
{\bfseries aligned\+\_\+allocator} (const \mbox{\hyperlink{classEigen_1_1aligned__allocator}{aligned\+\_\+allocator}} \&other)
\item 
\mbox{\Hypertarget{classEigen_1_1aligned__allocator_a19b1a156baf134359d088dc9127fc2c1}\label{classEigen_1_1aligned__allocator_a19b1a156baf134359d088dc9127fc2c1}} 
{\footnotesize template$<$class U $>$ }\\{\bfseries aligned\+\_\+allocator} (const \mbox{\hyperlink{classEigen_1_1aligned__allocator}{aligned\+\_\+allocator}}$<$ U $>$ \&other)
\item 
\mbox{\Hypertarget{classEigen_1_1aligned__allocator_a11f921b8c551f8f89c5b6252a2cbfac0}\label{classEigen_1_1aligned__allocator_a11f921b8c551f8f89c5b6252a2cbfac0}} 
pointer {\bfseries allocate} (size\+\_\+type num, const void $\ast$=0)
\item 
\mbox{\Hypertarget{classEigen_1_1aligned__allocator_ae00326806b7ba19c141c6c61a5f7b1ad}\label{classEigen_1_1aligned__allocator_ae00326806b7ba19c141c6c61a5f7b1ad}} 
void {\bfseries deallocate} (pointer p, size\+\_\+type)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class T$>$\newline
class Eigen\+::aligned\+\_\+allocator$<$ T $>$}
STL compatible allocator to use with types requiring a non standrad alignment. 

The memory is aligned as for dynamically aligned matrix/array types such as Matrix\+Xd. By default, it will thus provide at least 16 bytes alignment and more in following cases\+:
\begin{DoxyItemize}
\item 32 bytes alignment if AVX is enabled.
\item 64 bytes alignment if AVX512 is enabled.
\end{DoxyItemize}

This can be controlled using the {\ttfamily EIGEN\+\_\+\+MAX\+\_\+\+ALIGN\+\_\+\+BYTES} macro as documented \mbox{\hyperlink{}{there }}.

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Matrix4f requires 16 bytes alignment:}}
\DoxyCodeLine{std::map< int, Matrix4f, std::less<int>,}
\DoxyCodeLine{          aligned\_allocator<std::pair<const int, Matrix4f> > > my\_map\_mat4;}
\DoxyCodeLine{\textcolor{comment}{// Vector3f does not require 16 bytes alignment, no need to use Eigen's allocator:}}
\DoxyCodeLine{std::map< int, Vector3f > my\_map\_vec3;}

\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\textbackslash{}blank Topic\+Stl\+Containers. 
\end{DoxySeeAlso}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/\+Eigen/src/\+Core/util/Memory.\+h\end{DoxyCompactItemize}
