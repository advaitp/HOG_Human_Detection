\hypertarget{classEigen_1_1JacobiSVD}{}\doxysection{Eigen\+::Jacobi\+SVD\texorpdfstring{$<$}{<} Matrix\+Type\+\_\+, QRPreconditioner \texorpdfstring{$>$}{>} Class Template Reference}
\label{classEigen_1_1JacobiSVD}\index{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}}


Two-\/sided Jacobi SVD decomposition of a rectangular matrix.  




{\ttfamily \#include $<$Jacobi\+SVD.\+h$>$}

Inheritance diagram for Eigen\+::Jacobi\+SVD\texorpdfstring{$<$}{<} Matrix\+Type\+\_\+, QRPreconditioner \texorpdfstring{$>$}{>}\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4.000000cm]{classEigen_1_1JacobiSVD}
\end{center}
\end{figure}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_ad3b779c133d763234c7e92132fc06c06}\label{classEigen_1_1JacobiSVD_ad3b779c133d763234c7e92132fc06c06}} 
enum \{ \newline
{\bfseries Rows\+At\+Compile\+Time} = Matrix\+Type\+::Rows\+At\+Compile\+Time
, {\bfseries Cols\+At\+Compile\+Time} = Matrix\+Type\+::Cols\+At\+Compile\+Time
, {\bfseries Diag\+Size\+At\+Compile\+Time} = EIGEN\+\_\+\+SIZE\+\_\+\+MIN\+\_\+\+PREFER\+\_\+\+DYNAMIC(Rows\+At\+Compile\+Time,Cols\+At\+Compile\+Time)
, {\bfseries Max\+Rows\+At\+Compile\+Time} = Matrix\+Type\+::Max\+Rows\+At\+Compile\+Time
, \newline
{\bfseries Max\+Cols\+At\+Compile\+Time} = Matrix\+Type\+::Max\+Cols\+At\+Compile\+Time
, {\bfseries Max\+Diag\+Size\+At\+Compile\+Time} = EIGEN\+\_\+\+SIZE\+\_\+\+MIN\+\_\+\+PREFER\+\_\+\+FIXED(Max\+Rows\+At\+Compile\+Time,Max\+Cols\+At\+Compile\+Time)
, {\bfseries Matrix\+Options} = Matrix\+Type\+::Options
 \}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_abf3b68b5e8535d915b2b8b52ffdaf7fe}\label{classEigen_1_1JacobiSVD_abf3b68b5e8535d915b2b8b52ffdaf7fe}} 
typedef Matrix\+Type\+\_\+ {\bfseries Matrix\+Type}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_ae0286a56ca4d23d75c0884dd9d028e58}\label{classEigen_1_1JacobiSVD_ae0286a56ca4d23d75c0884dd9d028e58}} 
typedef Matrix\+Type\+::\+Scalar {\bfseries Scalar}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_a838ab988bb1ac02d7ddb527fa0658354}\label{classEigen_1_1JacobiSVD_a838ab988bb1ac02d7ddb527fa0658354}} 
typedef \mbox{\hyperlink{structEigen_1_1NumTraits}{Num\+Traits}}$<$ typename\+Matrix\+Type\+::\+Scalar $>$\+::Real {\bfseries Real\+Scalar}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_a9656696aa9258f15f4f416414401ca74}\label{classEigen_1_1JacobiSVD_a9656696aa9258f15f4f416414401ca74}} 
typedef Base\+::\+Matrix\+UType {\bfseries Matrix\+UType}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_ae452a553a8c30d6c590be26442fb0d8a}\label{classEigen_1_1JacobiSVD_ae452a553a8c30d6c590be26442fb0d8a}} 
typedef Base\+::\+Matrix\+VType {\bfseries Matrix\+VType}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_ad7bfd098e015e0db96159c53b8cca43b}\label{classEigen_1_1JacobiSVD_ad7bfd098e015e0db96159c53b8cca43b}} 
typedef Base\+::\+Singular\+Values\+Type {\bfseries Singular\+Values\+Type}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_a9c7be43f39a569ae03b1db31b32fe0e7}\label{classEigen_1_1JacobiSVD_a9c7be43f39a569ae03b1db31b32fe0e7}} 
typedef \mbox{\hyperlink{structEigen_1_1internal_1_1plain__row__type}{internal\+::plain\+\_\+row\+\_\+type}}$<$ Matrix\+Type $>$\+::type {\bfseries Row\+Type}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_a60c5b95a15c64938b0265ca1b4329fa9}\label{classEigen_1_1JacobiSVD_a60c5b95a15c64938b0265ca1b4329fa9}} 
typedef \mbox{\hyperlink{structEigen_1_1internal_1_1plain__col__type}{internal\+::plain\+\_\+col\+\_\+type}}$<$ Matrix\+Type $>$\+::type {\bfseries Col\+Type}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_a293ca9c355f880d12f23560e5cea884e}\label{classEigen_1_1JacobiSVD_a293ca9c355f880d12f23560e5cea884e}} 
typedef \mbox{\hyperlink{classEigen_1_1Matrix}{Matrix}}$<$ Scalar, Diag\+Size\+At\+Compile\+Time, Diag\+Size\+At\+Compile\+Time, Matrix\+Options, Max\+Diag\+Size\+At\+Compile\+Time, Max\+Diag\+Size\+At\+Compile\+Time $>$ {\bfseries Work\+Matrix\+Type}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classEigen_1_1JacobiSVD_ae37a9d883232f608766435d09044cd6d}{Jacobi\+SVD}} ()
\begin{DoxyCompactList}\small\item\em Default Constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classEigen_1_1JacobiSVD_a7a81e8e2879f6ccd03daac713aa2cad6}{Jacobi\+SVD}} (\mbox{\hyperlink{structEigen_1_1EigenBase_a554f30542cc2316add4b1ea0a492ff02}{Index}} \mbox{\hyperlink{classEigen_1_1JacobiSVD_af1d12fdb3361e150427e1fd94ebb1f14}{rows}}, \mbox{\hyperlink{structEigen_1_1EigenBase_a554f30542cc2316add4b1ea0a492ff02}{Index}} \mbox{\hyperlink{classEigen_1_1JacobiSVD_a50c19c45f15acdfe1cb66ab5e879b8e3}{cols}}, unsigned int computation\+Options=0)
\begin{DoxyCompactList}\small\item\em Default Constructor with memory preallocation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classEigen_1_1JacobiSVD_afd9ba810cb2e5a8b1450163739367ab2}{Jacobi\+SVD}} (const Matrix\+Type \&matrix, unsigned int computation\+Options=0)
\begin{DoxyCompactList}\small\item\em Constructor performing the decomposition of given matrix. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classEigen_1_1JacobiSVD}{Jacobi\+SVD}} \& \mbox{\hyperlink{classEigen_1_1JacobiSVD_a5dab376cc86cf0d36674bcdad4af3f5a}{compute}} (const Matrix\+Type \&matrix, unsigned int computation\+Options)
\begin{DoxyCompactList}\small\item\em Method performing the decomposition of given matrix using custom options. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classEigen_1_1JacobiSVD}{Jacobi\+SVD}} \& \mbox{\hyperlink{classEigen_1_1JacobiSVD_ac57c71c8cc099d24faa447f4508b533c}{compute}} (const Matrix\+Type \&matrix)
\begin{DoxyCompactList}\small\item\em Method performing the decomposition of given matrix using current options. \end{DoxyCompactList}\item 
EIGEN\+\_\+\+DEVICE\+\_\+\+FUNC EIGEN\+\_\+\+CONSTEXPR \mbox{\hyperlink{structEigen_1_1EigenBase_a554f30542cc2316add4b1ea0a492ff02}{Index}} \mbox{\hyperlink{classEigen_1_1JacobiSVD_af1d12fdb3361e150427e1fd94ebb1f14}{rows}} () const EIGEN\+\_\+\+NOEXCEPT
\item 
EIGEN\+\_\+\+DEVICE\+\_\+\+FUNC EIGEN\+\_\+\+CONSTEXPR \mbox{\hyperlink{structEigen_1_1EigenBase_a554f30542cc2316add4b1ea0a492ff02}{Index}} \mbox{\hyperlink{classEigen_1_1JacobiSVD_a50c19c45f15acdfe1cb66ab5e879b8e3}{cols}} () const EIGEN\+\_\+\+NOEXCEPT
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_ae64b9e52502cdb9ac4e1fc9ee68efd08}\label{classEigen_1_1JacobiSVD_ae64b9e52502cdb9ac4e1fc9ee68efd08}} 
\mbox{\hyperlink{classEigen_1_1Matrix}{Work\+Matrix\+Type}} {\bfseries m\+\_\+work\+Matrix}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_a395d32ea50fed6d68139f4b024db0a39}\label{classEigen_1_1JacobiSVD_a395d32ea50fed6d68139f4b024db0a39}} 
\mbox{\hyperlink{structEigen_1_1internal_1_1qr__preconditioner__impl}{internal\+::qr\+\_\+preconditioner\+\_\+impl}}$<$ Matrix\+Type, QRPreconditioner, internal\+::\+Precondition\+If\+More\+Cols\+Than\+Rows $>$ {\bfseries m\+\_\+qr\+\_\+precond\+\_\+morecols}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_a4e09a43df3d1c2fb703a49b3bc001173}\label{classEigen_1_1JacobiSVD_a4e09a43df3d1c2fb703a49b3bc001173}} 
\mbox{\hyperlink{structEigen_1_1internal_1_1qr__preconditioner__impl}{internal\+::qr\+\_\+preconditioner\+\_\+impl}}$<$ Matrix\+Type, QRPreconditioner, internal\+::\+Precondition\+If\+More\+Rows\+Than\+Cols $>$ {\bfseries m\+\_\+qr\+\_\+precond\+\_\+morerows}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_aa1c6579630aa576dd2d7485bf959e2ad}\label{classEigen_1_1JacobiSVD_aa1c6579630aa576dd2d7485bf959e2ad}} 
Matrix\+Type {\bfseries m\+\_\+scaled\+Matrix}
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_a88d510b611ce8922ee1457b5a6223658}\label{classEigen_1_1JacobiSVD_a88d510b611ce8922ee1457b5a6223658}} 
{\footnotesize template$<$typename Matrix\+Type\+\_\+\+\_\+ , int QRPreconditioner\+\_\+, bool Is\+Complex\+\_\+$>$ }\\struct {\bfseries internal\+::svd\+\_\+precondition\+\_\+2x2\+\_\+block\+\_\+to\+\_\+be\+\_\+real}
\item 
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_a1d21ab8e3cfd531f14023c010d3335bc}\label{classEigen_1_1JacobiSVD_a1d21ab8e3cfd531f14023c010d3335bc}} 
{\footnotesize template$<$typename Matrix\+Type\+\_\+\+\_\+ , int QRPreconditioner\+\_\+, int Case\+\_\+, bool Do\+Anything\+\_\+$>$ }\\struct {\bfseries internal\+::qr\+\_\+preconditioner\+\_\+impl}
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Matrix\+Type\+\_\+, int QRPreconditioner$>$\newline
class Eigen\+::\+Jacobi\+SVD$<$ Matrix\+Type\+\_\+, QRPreconditioner $>$}
Two-\/sided Jacobi SVD decomposition of a rectangular matrix. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Matrix\+Type\+\_\+} & the type of the matrix of which we are computing the SVD decomposition \\
\hline
{\em QRPreconditioner} & this optional parameter allows to specify the type of QR decomposition that will be used internally for the R-\/\+SVD step for non-\/square matrices. See discussion of possible values below.\\
\hline
\end{DoxyTemplParams}
SVD decomposition consists in decomposing any n-\/by-\/p matrix {\itshape A} as a product \[ A = U S V^* \] where {\itshape U} is a n-\/by-\/n unitary, {\itshape V} is a p-\/by-\/p unitary, and {\itshape S} is a n-\/by-\/p real positive matrix which is zero outside of its main diagonal; the diagonal entries of S are known as the {\itshape singular} {\itshape values} of {\itshape A} and the columns of {\itshape U} and {\itshape V} are known as the left and right {\itshape singular} {\itshape vectors} of {\itshape A} respectively.

Singular values are always sorted in decreasing order.

This \mbox{\hyperlink{classEigen_1_1JacobiSVD}{Jacobi\+SVD}} decomposition computes only the singular values by default. If you want {\itshape U} or {\itshape V}, you need to ask for them explicitly.

You can ask for only {\itshape thin} {\itshape U} or {\itshape V} to be computed, meaning the following. In case of a rectangular n-\/by-\/p matrix, letting {\itshape m} be the smaller value among {\itshape n} and {\itshape p}, there are only {\itshape m} singular vectors; the remaining columns of {\itshape U} and {\itshape V} do not correspond to actual singular vectors. Asking for {\itshape thin} {\itshape U} or {\itshape V} means asking for only their {\itshape m} first columns to be formed. So {\itshape U} is then a n-\/by-\/m matrix, and {\itshape V} is then a p-\/by-\/m matrix. Notice that thin {\itshape U} and {\itshape V} are all you need for (least squares) solving.

Here\textquotesingle{}s an example demonstrating basic usage\+: 
\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 Output\+: 
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}


This \mbox{\hyperlink{classEigen_1_1JacobiSVD}{Jacobi\+SVD}} class is a two-\/sided Jacobi R-\/\+SVD decomposition, ensuring optimal reliability and accuracy. The downside is that it\textquotesingle{}s slower than bidiagonalizing SVD algorithms for large square matrices; however its complexity is still $ O(n^2p) $ where {\itshape n} is the smaller dimension and {\itshape p} is the greater dimension, meaning that it is still of the same order of complexity as the faster bidiagonalizing R-\/\+SVD algorithms. In particular, like any R-\/\+SVD, it takes advantage of non-\/squareness in that its complexity is only linear in the greater dimension.

If the input matrix has inf or nan coefficients, the result of the computation is undefined, but the computation is guaranteed to terminate in finite (and reasonable) time.

The possible values for QRPreconditioner are\+: \begin{DoxyItemize}
\item Col\+Piv\+Householder\+QRPreconditioner is the default. In practice it\textquotesingle{}s very safe. It uses column-\/pivoting QR. \item Full\+Piv\+Householder\+QRPreconditioner, is the safest and slowest. It uses full-\/pivoting QR. Contrary to other QRs, it doesn\textquotesingle{}t allow computing thin unitaries. \item Householder\+QRPreconditioner is the fastest, and less safe and accurate than the pivoting variants. It uses non-\/pivoting QR. This is very similar in safety and accuracy to the bidiagonalization process used by bidiagonalizing SVD algorithms (since bidiagonalization is inherently non-\/pivoting). However the resulting SVD is still more reliable than bidiagonalizing SVDs because the Jacobi-\/based iterarive process is more reliable than the optimized bidiagonal SVD iterations. \item No\+QRPreconditioner allows not to use a QR preconditioner at all. This is useful if you know that you will only be computing \mbox{\hyperlink{classEigen_1_1JacobiSVD}{Jacobi\+SVD}} decompositions of square matrices. Non-\/square matrices require a QR preconditioner. Using this option will result in faster compilation and smaller executable code. It won\textquotesingle{}t significantly speed up computation, since \mbox{\hyperlink{classEigen_1_1JacobiSVD}{Jacobi\+SVD}} is always checking if QR preconditioning is needed before applying it anyway.\end{DoxyItemize}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classEigen_1_1MatrixBase_a5745dca9c54390633b434e54a1d1eedd}{Matrix\+Base\+::jacobi\+Svd()}} 
\end{DoxySeeAlso}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_ae37a9d883232f608766435d09044cd6d}\label{classEigen_1_1JacobiSVD_ae37a9d883232f608766435d09044cd6d}} 
\index{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}!JacobiSVD@{JacobiSVD}}
\index{JacobiSVD@{JacobiSVD}!Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}}
\doxysubsubsection{\texorpdfstring{JacobiSVD()}{JacobiSVD()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , int QRPreconditioner$>$ \\
\mbox{\hyperlink{classEigen_1_1JacobiSVD}{Eigen\+::\+Jacobi\+SVD}}$<$ Matrix\+Type\+\_\+, QRPreconditioner $>$\+::\mbox{\hyperlink{classEigen_1_1JacobiSVD}{Jacobi\+SVD}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Default Constructor. 

The default constructor is useful in cases in which the user intends to perform decompositions via \mbox{\hyperlink{classEigen_1_1JacobiSVD_ac57c71c8cc099d24faa447f4508b533c}{Jacobi\+SVD\+::compute(const Matrix\+Type\&)}}. \mbox{\Hypertarget{classEigen_1_1JacobiSVD_a7a81e8e2879f6ccd03daac713aa2cad6}\label{classEigen_1_1JacobiSVD_a7a81e8e2879f6ccd03daac713aa2cad6}} 
\index{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}!JacobiSVD@{JacobiSVD}}
\index{JacobiSVD@{JacobiSVD}!Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}}
\doxysubsubsection{\texorpdfstring{JacobiSVD()}{JacobiSVD()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , int QRPreconditioner$>$ \\
\mbox{\hyperlink{classEigen_1_1JacobiSVD}{Eigen\+::\+Jacobi\+SVD}}$<$ Matrix\+Type\+\_\+, QRPreconditioner $>$\+::\mbox{\hyperlink{classEigen_1_1JacobiSVD}{Jacobi\+SVD}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structEigen_1_1EigenBase_a554f30542cc2316add4b1ea0a492ff02}{Index}}}]{rows,  }\item[{\mbox{\hyperlink{structEigen_1_1EigenBase_a554f30542cc2316add4b1ea0a492ff02}{Index}}}]{cols,  }\item[{unsigned int}]{computation\+Options = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Default Constructor with memory preallocation. 

Like the default constructor but with preallocation of the internal data according to the specified problem size. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classEigen_1_1JacobiSVD_ae37a9d883232f608766435d09044cd6d}{Jacobi\+SVD()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_afd9ba810cb2e5a8b1450163739367ab2}\label{classEigen_1_1JacobiSVD_afd9ba810cb2e5a8b1450163739367ab2}} 
\index{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}!JacobiSVD@{JacobiSVD}}
\index{JacobiSVD@{JacobiSVD}!Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}}
\doxysubsubsection{\texorpdfstring{JacobiSVD()}{JacobiSVD()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , int QRPreconditioner$>$ \\
\mbox{\hyperlink{classEigen_1_1JacobiSVD}{Eigen\+::\+Jacobi\+SVD}}$<$ Matrix\+Type\+\_\+, QRPreconditioner $>$\+::\mbox{\hyperlink{classEigen_1_1JacobiSVD}{Jacobi\+SVD}} (\begin{DoxyParamCaption}\item[{const Matrix\+Type \&}]{matrix,  }\item[{unsigned int}]{computation\+Options = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Constructor performing the decomposition of given matrix. 


\begin{DoxyParams}{Parameters}
{\em matrix} & the matrix to decompose \\
\hline
{\em computation\+Options} & optional parameter allowing to specify if you want full or thin U or V unitaries to be computed. By default, none is computed. This is a bit-\/field, the possible bits are \mbox{\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a9fa9302d510cee20c26311154937e23f}{Compute\+FullU}}, \mbox{\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9aa7fb4e98834788d0b1b0f2b8467d2527}{Compute\+ThinU}}, \mbox{\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a36581f7c662f7def31efd500c284f930}{Compute\+FullV}}, \mbox{\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a540036417bfecf2e791a70948c227f47}{Compute\+ThinV}}.\\
\hline
\end{DoxyParams}
Thin unitaries are only available if your matrix type has a Dynamic number of columns (for example Matrix\+Xf). They also are not available with the (non-\/default) \mbox{\hyperlink{classEigen_1_1FullPivHouseholderQR}{Full\+Piv\+Householder\+QR}} preconditioner. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_a50c19c45f15acdfe1cb66ab5e879b8e3}\label{classEigen_1_1JacobiSVD_a50c19c45f15acdfe1cb66ab5e879b8e3}} 
\index{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}!cols@{cols}}
\index{cols@{cols}!Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}}
\doxysubsubsection{\texorpdfstring{cols()}{cols()}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , int QRPreconditioner$>$ \\
EIGEN\+\_\+\+DEVICE\+\_\+\+FUNC EIGEN\+\_\+\+CONSTEXPR \mbox{\hyperlink{structEigen_1_1EigenBase_a554f30542cc2316add4b1ea0a492ff02}{Index}} \mbox{\hyperlink{structEigen_1_1EigenBase}{Eigen\+::\+Eigen\+Base}}$<$ Derived $>$\+::cols (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of columns. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classEigen_1_1JacobiSVD_af1d12fdb3361e150427e1fd94ebb1f14}{rows()}}, Cols\+At\+Compile\+Time 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classEigen_1_1JacobiSVD_ac57c71c8cc099d24faa447f4508b533c}\label{classEigen_1_1JacobiSVD_ac57c71c8cc099d24faa447f4508b533c}} 
\index{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}!compute@{compute}}
\index{compute@{compute}!Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}}
\doxysubsubsection{\texorpdfstring{compute()}{compute()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , int QRPreconditioner$>$ \\
\mbox{\hyperlink{classEigen_1_1JacobiSVD}{Jacobi\+SVD}} \& \mbox{\hyperlink{classEigen_1_1JacobiSVD}{Eigen\+::\+Jacobi\+SVD}}$<$ Matrix\+Type\+\_\+, QRPreconditioner $>$\+::compute (\begin{DoxyParamCaption}\item[{const Matrix\+Type \&}]{matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Method performing the decomposition of given matrix using current options. 


\begin{DoxyParams}{Parameters}
{\em matrix} & the matrix to decompose\\
\hline
\end{DoxyParams}
This method uses the current {\itshape computation\+Options}, as already passed to the constructor or to \mbox{\hyperlink{classEigen_1_1JacobiSVD_a5dab376cc86cf0d36674bcdad4af3f5a}{compute(const Matrix\+Type\&, unsigned int)}}. \mbox{\Hypertarget{classEigen_1_1JacobiSVD_a5dab376cc86cf0d36674bcdad4af3f5a}\label{classEigen_1_1JacobiSVD_a5dab376cc86cf0d36674bcdad4af3f5a}} 
\index{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}!compute@{compute}}
\index{compute@{compute}!Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}}
\doxysubsubsection{\texorpdfstring{compute()}{compute()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type , int QRPreconditioner$>$ \\
\mbox{\hyperlink{classEigen_1_1JacobiSVD}{Jacobi\+SVD}}$<$ Matrix\+Type, QRPreconditioner $>$ \& \mbox{\hyperlink{classEigen_1_1JacobiSVD}{Eigen\+::\+Jacobi\+SVD}}$<$ Matrix\+Type, QRPreconditioner $>$\+::compute (\begin{DoxyParamCaption}\item[{const Matrix\+Type \&}]{matrix,  }\item[{unsigned int}]{computation\+Options }\end{DoxyParamCaption})}



Method performing the decomposition of given matrix using custom options. 


\begin{DoxyParams}{Parameters}
{\em matrix} & the matrix to decompose \\
\hline
{\em computation\+Options} & optional parameter allowing to specify if you want full or thin U or V unitaries to be computed. By default, none is computed. This is a bit-\/field, the possible bits are \mbox{\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a9fa9302d510cee20c26311154937e23f}{Compute\+FullU}}, \mbox{\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9aa7fb4e98834788d0b1b0f2b8467d2527}{Compute\+ThinU}}, \mbox{\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a36581f7c662f7def31efd500c284f930}{Compute\+FullV}}, \mbox{\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a540036417bfecf2e791a70948c227f47}{Compute\+ThinV}}.\\
\hline
\end{DoxyParams}
Thin unitaries are only available if your matrix type has a Dynamic number of columns (for example Matrix\+Xf). They also are not available with the (non-\/default) \mbox{\hyperlink{classEigen_1_1FullPivHouseholderQR}{Full\+Piv\+Householder\+QR}} preconditioner. \mbox{\Hypertarget{classEigen_1_1JacobiSVD_af1d12fdb3361e150427e1fd94ebb1f14}\label{classEigen_1_1JacobiSVD_af1d12fdb3361e150427e1fd94ebb1f14}} 
\index{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}!rows@{rows}}
\index{rows@{rows}!Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$@{Eigen::JacobiSVD$<$ MatrixType\_, QRPreconditioner $>$}}
\doxysubsubsection{\texorpdfstring{rows()}{rows()}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , int QRPreconditioner$>$ \\
EIGEN\+\_\+\+DEVICE\+\_\+\+FUNC EIGEN\+\_\+\+CONSTEXPR \mbox{\hyperlink{structEigen_1_1EigenBase_a554f30542cc2316add4b1ea0a492ff02}{Index}} \mbox{\hyperlink{structEigen_1_1EigenBase}{Eigen\+::\+Eigen\+Base}}$<$ Derived $>$\+::rows (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of rows. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classEigen_1_1JacobiSVD_a50c19c45f15acdfe1cb66ab5e879b8e3}{cols()}}, Rows\+At\+Compile\+Time 
\end{DoxySeeAlso}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/\+Eigen/src/\+Core/util/Forward\+Declarations.\+h\item 
include/\+Eigen/src/\+SVD/Jacobi\+SVD.\+h\end{DoxyCompactItemize}
