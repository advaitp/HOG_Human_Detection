\hypertarget{structEigen_1_1internal_1_1nested__eval}{}\doxysection{Eigen\+::internal\+::nested\+\_\+eval\texorpdfstring{$<$}{<} T, n, Plain\+Object \texorpdfstring{$>$}{>} Struct Template Reference}
\label{structEigen_1_1internal_1_1nested__eval}\index{Eigen::internal::nested\_eval$<$ T, n, PlainObject $>$@{Eigen::internal::nested\_eval$<$ T, n, PlainObject $>$}}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{structEigen_1_1internal_1_1nested__eval_a8d054b43642011731d39a59bc0af8042}\label{structEigen_1_1internal_1_1nested__eval_a8d054b43642011731d39a59bc0af8042}} 
enum \{ \newline
{\bfseries Scalar\+Read\+Cost} = Num\+Traits\texorpdfstring{$<$}{<}typename traits\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}\+::Scalar\texorpdfstring{$>$}{>}\+::Read\+Cost
, {\bfseries Coeff\+Read\+Cost} = evaluator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}\+::Coeff\+Read\+Cost
, {\bfseries NAs\+Integer} = n == Dynamic ? Huge\+Cost \+: n
, {\bfseries Cost\+Eval} = (NAs\+Integer+1) $\ast$ Scalar\+Read\+Cost + Coeff\+Read\+Cost
, \newline
{\bfseries Cost\+No\+Eval} = NAs\+Integer $\ast$ Coeff\+Read\+Cost
, {\bfseries Evaluate} = (int(evaluator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}\+::Flags) \& Eval\+Before\+Nesting\+Bit) $\vert$$\vert$ (int(Cost\+Eval) \texorpdfstring{$<$}{<} int(Cost\+No\+Eval))
 \}
\item 
\mbox{\Hypertarget{structEigen_1_1internal_1_1nested__eval_a787dfc6bd971e0ab60b3c1158ba4b313}\label{structEigen_1_1internal_1_1nested__eval_a787dfc6bd971e0ab60b3c1158ba4b313}} 
typedef \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional}}$<$ Evaluate, Plain\+Object, typenameref\+\_\+selector$<$ T $>$\+::\mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{type}} $>$\+::\mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{type}} {\bfseries type}
\end{DoxyCompactItemize}


The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/\+Eigen/src/\+Core/util/Xpr\+Helper.\+h\end{DoxyCompactItemize}
