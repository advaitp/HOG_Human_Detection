\hypertarget{gmock-matchers_8h_source}{}\doxysection{gmock-\/matchers.h}
\label{gmock-matchers_8h_source}\index{vendor/googletest/googlemock/include/gmock/gmock-\/matchers.h@{vendor/googletest/googlemock/include/gmock/gmock-\/matchers.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2007, Google Inc.}}
\DoxyCodeLine{2 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Redistribution and use in source and binary forms, with or without}}
\DoxyCodeLine{5 \textcolor{comment}{// modification, are permitted provided that the following conditions are}}
\DoxyCodeLine{6 \textcolor{comment}{// met:}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{//     * Redistributions of source code must retain the above copyright}}
\DoxyCodeLine{9 \textcolor{comment}{// notice, this list of conditions and the following disclaimer.}}
\DoxyCodeLine{10 \textcolor{comment}{//     * Redistributions in binary form must reproduce the above}}
\DoxyCodeLine{11 \textcolor{comment}{// copyright notice, this list of conditions and the following disclaimer}}
\DoxyCodeLine{12 \textcolor{comment}{// in the documentation and/or other materials provided with the}}
\DoxyCodeLine{13 \textcolor{comment}{// distribution.}}
\DoxyCodeLine{14 \textcolor{comment}{//     * Neither the name of Google Inc. nor the names of its}}
\DoxyCodeLine{15 \textcolor{comment}{// contributors may be used to endorse or promote products derived from}}
\DoxyCodeLine{16 \textcolor{comment}{// this software without specific prior written permission.}}
\DoxyCodeLine{17 \textcolor{comment}{//}}
\DoxyCodeLine{18 \textcolor{comment}{// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}}
\DoxyCodeLine{19 \textcolor{comment}{// "{}AS IS"{} AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}}
\DoxyCodeLine{20 \textcolor{comment}{// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}}
\DoxyCodeLine{21 \textcolor{comment}{// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}}
\DoxyCodeLine{22 \textcolor{comment}{// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}}
\DoxyCodeLine{23 \textcolor{comment}{// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}}
\DoxyCodeLine{24 \textcolor{comment}{// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}}
\DoxyCodeLine{25 \textcolor{comment}{// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}}
\DoxyCodeLine{26 \textcolor{comment}{// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}}
\DoxyCodeLine{27 \textcolor{comment}{// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}}
\DoxyCodeLine{28 \textcolor{comment}{// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}}
\DoxyCodeLine{29 \textcolor{comment}{//}}
\DoxyCodeLine{30 \textcolor{comment}{// Author: wan@google.com (Zhanyong Wan)}}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{comment}{// Google Mock -\/ a framework for writing C++ mock classes.}}
\DoxyCodeLine{33 \textcolor{comment}{//}}
\DoxyCodeLine{34 \textcolor{comment}{// This file implements some commonly used argument matchers.  More}}
\DoxyCodeLine{35 \textcolor{comment}{// matchers can be defined by the user implementing the}}
\DoxyCodeLine{36 \textcolor{comment}{// MatcherInterface<T> interface if necessary.}}
\DoxyCodeLine{37 }
\DoxyCodeLine{38 \textcolor{preprocessor}{\#ifndef GMOCK\_INCLUDE\_GMOCK\_GMOCK\_MATCHERS\_H\_}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#define GMOCK\_INCLUDE\_GMOCK\_GMOCK\_MATCHERS\_H\_}}
\DoxyCodeLine{40 }
\DoxyCodeLine{41 \textcolor{preprocessor}{\#include <math.h>}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{43 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{44 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#include <ostream>}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{48 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51 \textcolor{preprocessor}{\#include "{}gmock/internal/gmock-\/internal-\/utils.h"{}}}
\DoxyCodeLine{52 \textcolor{preprocessor}{\#include "{}gmock/internal/gmock-\/port.h"{}}}
\DoxyCodeLine{53 \textcolor{preprocessor}{\#include "{}gtest/gtest.h"{}}}
\DoxyCodeLine{54 }
\DoxyCodeLine{55 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_INITIALIZER\_LIST\_}}
\DoxyCodeLine{56 \textcolor{preprocessor}{\# include <initializer\_list>}  \textcolor{comment}{// NOLINT -\/-\/ must be after gtest.h}}
\DoxyCodeLine{57 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{58 }
\DoxyCodeLine{59 \textcolor{keyword}{namespace }testing \{}
\DoxyCodeLine{60 }
\DoxyCodeLine{61 \textcolor{comment}{// To implement a matcher Foo for type T, define:}}
\DoxyCodeLine{62 \textcolor{comment}{//   1. a class FooMatcherImpl that implements the}}
\DoxyCodeLine{63 \textcolor{comment}{//      MatcherInterface<T> interface, and}}
\DoxyCodeLine{64 \textcolor{comment}{//   2. a factory function that creates a Matcher<T> object from a}}
\DoxyCodeLine{65 \textcolor{comment}{//      FooMatcherImpl*.}}
\DoxyCodeLine{66 \textcolor{comment}{//}}
\DoxyCodeLine{67 \textcolor{comment}{// The two-\/level delegation design makes it possible to allow a user}}
\DoxyCodeLine{68 \textcolor{comment}{// to write "{}v"{} instead of "{}Eq(v)"{} where a Matcher is expected, which}}
\DoxyCodeLine{69 \textcolor{comment}{// is impossible if we pass matchers by pointers.  It also eases}}
\DoxyCodeLine{70 \textcolor{comment}{// ownership management as Matcher objects can now be copied like}}
\DoxyCodeLine{71 \textcolor{comment}{// plain values.}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73 \textcolor{comment}{// MatchResultListener is an abstract class.  Its << operator can be}}
\DoxyCodeLine{74 \textcolor{comment}{// used by a matcher to explain why a value matches or doesn't match.}}
\DoxyCodeLine{75 \textcolor{comment}{//}}
\DoxyCodeLine{76 \textcolor{comment}{// TODO(wan@google.com): add method}}
\DoxyCodeLine{77 \textcolor{comment}{//   bool InterestedInWhy(bool result) const;}}
\DoxyCodeLine{78 \textcolor{comment}{// to indicate whether the listener is interested in why the match}}
\DoxyCodeLine{79 \textcolor{comment}{// result is 'result'.}}
\DoxyCodeLine{80 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}} \{}
\DoxyCodeLine{81  \textcolor{keyword}{public}:}
\DoxyCodeLine{82   \textcolor{comment}{// Creates a listener object with the given underlying ostream.  The}}
\DoxyCodeLine{83   \textcolor{comment}{// listener does not own the ostream, and does not dereference it}}
\DoxyCodeLine{84   \textcolor{comment}{// in the constructor or destructor.}}
\DoxyCodeLine{85   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}(::std::ostream* os) : stream\_(os) \{\}}
\DoxyCodeLine{86   \textcolor{keyword}{virtual} \mbox{\hyperlink{classtesting_1_1MatchResultListener}{\string~MatchResultListener}}() = 0;  \textcolor{comment}{// Makes this class abstract.}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88   \textcolor{comment}{// Streams x to the underlying ostream; does nothing if the ostream}}
\DoxyCodeLine{89   \textcolor{comment}{// is NULL.}}
\DoxyCodeLine{90   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{91   \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}\& operator<<(\textcolor{keyword}{const} T\& x) \{}
\DoxyCodeLine{92     \textcolor{keywordflow}{if} (stream\_ != NULL)}
\DoxyCodeLine{93       *stream\_ << x;}
\DoxyCodeLine{94     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{95   \}}
\DoxyCodeLine{96 }
\DoxyCodeLine{97   \textcolor{comment}{// Returns the underlying ostream.}}
\DoxyCodeLine{98   ::std::ostream* stream() \{ \textcolor{keywordflow}{return} stream\_; \}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100   \textcolor{comment}{// Returns true iff the listener is interested in an explanation of}}
\DoxyCodeLine{101   \textcolor{comment}{// the match result.  A matcher's MatchAndExplain() method can use}}
\DoxyCodeLine{102   \textcolor{comment}{// this information to avoid generating the explanation when no one}}
\DoxyCodeLine{103   \textcolor{comment}{// intends to hear it.}}
\DoxyCodeLine{104   \textcolor{keywordtype}{bool} IsInterested()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} stream\_ != NULL; \}}
\DoxyCodeLine{105 }
\DoxyCodeLine{106  \textcolor{keyword}{private}:}
\DoxyCodeLine{107   ::std::ostream* \textcolor{keyword}{const} stream\_;}
\DoxyCodeLine{108 }
\DoxyCodeLine{109   GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}});}
\DoxyCodeLine{110 \};}
\DoxyCodeLine{111 }
\DoxyCodeLine{112 \textcolor{keyword}{inline} MatchResultListener::\string~MatchResultListener() \{}
\DoxyCodeLine{113 \}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115 \textcolor{comment}{// An instance of a subclass of this knows how to describe itself as a}}
\DoxyCodeLine{116 \textcolor{comment}{// matcher.}}
\DoxyCodeLine{117 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1MatcherDescriberInterface}{MatcherDescriberInterface}} \{}
\DoxyCodeLine{118  \textcolor{keyword}{public}:}
\DoxyCodeLine{119   \textcolor{keyword}{virtual} \mbox{\hyperlink{classtesting_1_1MatcherDescriberInterface}{\string~MatcherDescriberInterface}}() \{\}}
\DoxyCodeLine{120 }
\DoxyCodeLine{121   \textcolor{comment}{// Describes this matcher to an ostream.  The function should print}}
\DoxyCodeLine{122   \textcolor{comment}{// a verb phrase that describes the property a value matching this}}
\DoxyCodeLine{123   \textcolor{comment}{// matcher should have.  The subject of the verb phrase is the value}}
\DoxyCodeLine{124   \textcolor{comment}{// being matched.  For example, the DescribeTo() method of the Gt(7)}}
\DoxyCodeLine{125   \textcolor{comment}{// matcher prints "{}is greater than 7"{}.}}
\DoxyCodeLine{126   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{127 }
\DoxyCodeLine{128   \textcolor{comment}{// Describes the negation of this matcher to an ostream.  For}}
\DoxyCodeLine{129   \textcolor{comment}{// example, if the description of this matcher is "{}is greater than}}
\DoxyCodeLine{130   \textcolor{comment}{// 7"{}, the negated description could be "{}is not greater than 7"{}.}}
\DoxyCodeLine{131   \textcolor{comment}{// You are not required to override this when implementing}}
\DoxyCodeLine{132   \textcolor{comment}{// MatcherInterface, but it is highly advised so that your matcher}}
\DoxyCodeLine{133   \textcolor{comment}{// can produce good error messages.}}
\DoxyCodeLine{134   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{135     *os << \textcolor{stringliteral}{"{}not ("{}};}
\DoxyCodeLine{136     DescribeTo(os);}
\DoxyCodeLine{137     *os << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{138   \}}
\DoxyCodeLine{139 \};}
\DoxyCodeLine{140 }
\DoxyCodeLine{141 \textcolor{comment}{// The implementation of a matcher.}}
\DoxyCodeLine{142 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{143 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherDescriberInterface}{MatcherDescriberInterface}} \{}
\DoxyCodeLine{144  \textcolor{keyword}{public}:}
\DoxyCodeLine{145   \textcolor{comment}{// Returns true iff the matcher matches x; also explains the match}}
\DoxyCodeLine{146   \textcolor{comment}{// result to 'listener' if necessary (see the next paragraph), in}}
\DoxyCodeLine{147   \textcolor{comment}{// the form of a non-\/restrictive relative clause ("{}which ..."{},}}
\DoxyCodeLine{148   \textcolor{comment}{// "{}whose ..."{}, etc) that describes x.  For example, the}}
\DoxyCodeLine{149   \textcolor{comment}{// MatchAndExplain() method of the Pointee(...) matcher should}}
\DoxyCodeLine{150   \textcolor{comment}{// generate an explanation like "{}which points to ..."{}.}}
\DoxyCodeLine{151   \textcolor{comment}{//}}
\DoxyCodeLine{152   \textcolor{comment}{// Implementations of MatchAndExplain() should add an explanation of}}
\DoxyCodeLine{153   \textcolor{comment}{// the match result *if and only if* they can provide additional}}
\DoxyCodeLine{154   \textcolor{comment}{// information that's not already present (or not obvious) in the}}
\DoxyCodeLine{155   \textcolor{comment}{// print-\/out of x and the matcher's description.  Whether the match}}
\DoxyCodeLine{156   \textcolor{comment}{// succeeds is not a factor in deciding whether an explanation is}}
\DoxyCodeLine{157   \textcolor{comment}{// needed, as sometimes the caller needs to print a failure message}}
\DoxyCodeLine{158   \textcolor{comment}{// when the match succeeds (e.g. when the matcher is used inside}}
\DoxyCodeLine{159   \textcolor{comment}{// Not()).}}
\DoxyCodeLine{160   \textcolor{comment}{//}}
\DoxyCodeLine{161   \textcolor{comment}{// For example, a "{}has at least 10 elements"{} matcher should explain}}
\DoxyCodeLine{162   \textcolor{comment}{// what the actual element count is, regardless of the match result,}}
\DoxyCodeLine{163   \textcolor{comment}{// as it is useful information to the reader; on the other hand, an}}
\DoxyCodeLine{164   \textcolor{comment}{// "{}is empty"{} matcher probably only needs to explain what the actual}}
\DoxyCodeLine{165   \textcolor{comment}{// size is when the match fails, as it's redundant to say that the}}
\DoxyCodeLine{166   \textcolor{comment}{// size is 0 when the value is already known to be empty.}}
\DoxyCodeLine{167   \textcolor{comment}{//}}
\DoxyCodeLine{168   \textcolor{comment}{// You should override this method when defining a new matcher.}}
\DoxyCodeLine{169   \textcolor{comment}{//}}
\DoxyCodeLine{170   \textcolor{comment}{// It's the responsibility of the caller (Google Mock) to guarantee}}
\DoxyCodeLine{171   \textcolor{comment}{// that 'listener' is not NULL.  This helps to simplify a matcher's}}
\DoxyCodeLine{172   \textcolor{comment}{// implementation when it doesn't care about the performance, as it}}
\DoxyCodeLine{173   \textcolor{comment}{// can talk to 'listener' without checking its validity first.}}
\DoxyCodeLine{174   \textcolor{comment}{// However, in order to implement dummy listeners efficiently,}}
\DoxyCodeLine{175   \textcolor{comment}{// listener-\/>stream() may be NULL.}}
\DoxyCodeLine{176   \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(T x, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{177 }
\DoxyCodeLine{178   \textcolor{comment}{// Inherits these methods from MatcherDescriberInterface:}}
\DoxyCodeLine{179   \textcolor{comment}{//   virtual void DescribeTo(::std::ostream* os) const = 0;}}
\DoxyCodeLine{180   \textcolor{comment}{//   virtual void DescribeNegationTo(::std::ostream* os) const;}}
\DoxyCodeLine{181 \};}
\DoxyCodeLine{182 }
\DoxyCodeLine{183 \textcolor{comment}{// A match result listener that stores the explanation in a string.}}
\DoxyCodeLine{184 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}} \{}
\DoxyCodeLine{185  \textcolor{keyword}{public}:}
\DoxyCodeLine{186   \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}}() : \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}(\&ss\_) \{\}}
\DoxyCodeLine{187 }
\DoxyCodeLine{188   \textcolor{comment}{// Returns the explanation accumulated so far.}}
\DoxyCodeLine{189   internal::string str()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} ss\_.str(); \}}
\DoxyCodeLine{190 }
\DoxyCodeLine{191   \textcolor{comment}{// Clears the explanation accumulated so far.}}
\DoxyCodeLine{192   \textcolor{keywordtype}{void} Clear() \{ ss\_.str(\textcolor{stringliteral}{"{}"{}}); \}}
\DoxyCodeLine{193 }
\DoxyCodeLine{194  \textcolor{keyword}{private}:}
\DoxyCodeLine{195   ::std::stringstream ss\_;}
\DoxyCodeLine{196 }
\DoxyCodeLine{197   GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}});}
\DoxyCodeLine{198 \};}
\DoxyCodeLine{199 }
\DoxyCodeLine{200 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{201 }
\DoxyCodeLine{202 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1AnyEq}{AnyEq}} \{}
\DoxyCodeLine{203   \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{204   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a == b; \}}
\DoxyCodeLine{205 \};}
\DoxyCodeLine{206 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1AnyNe}{AnyNe}} \{}
\DoxyCodeLine{207   \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{208   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a != b; \}}
\DoxyCodeLine{209 \};}
\DoxyCodeLine{210 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1AnyLt}{AnyLt}} \{}
\DoxyCodeLine{211   \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{212   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a < b; \}}
\DoxyCodeLine{213 \};}
\DoxyCodeLine{214 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1AnyGt}{AnyGt}} \{}
\DoxyCodeLine{215   \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{216   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a > b; \}}
\DoxyCodeLine{217 \};}
\DoxyCodeLine{218 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1AnyLe}{AnyLe}} \{}
\DoxyCodeLine{219   \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{220   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a <= b; \}}
\DoxyCodeLine{221 \};}
\DoxyCodeLine{222 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1AnyGe}{AnyGe}} \{}
\DoxyCodeLine{223   \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B>}
\DoxyCodeLine{224   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a >= b; \}}
\DoxyCodeLine{225 \};}
\DoxyCodeLine{226 }
\DoxyCodeLine{227 \textcolor{comment}{// A match result listener that ignores the explanation.}}
\DoxyCodeLine{228 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1DummyMatchResultListener}{DummyMatchResultListener}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}} \{}
\DoxyCodeLine{229  \textcolor{keyword}{public}:}
\DoxyCodeLine{230   \mbox{\hyperlink{classtesting_1_1internal_1_1DummyMatchResultListener}{DummyMatchResultListener}}() : \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}(NULL) \{\}}
\DoxyCodeLine{231 }
\DoxyCodeLine{232  \textcolor{keyword}{private}:}
\DoxyCodeLine{233   GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1DummyMatchResultListener}{DummyMatchResultListener}});}
\DoxyCodeLine{234 \};}
\DoxyCodeLine{235 }
\DoxyCodeLine{236 \textcolor{comment}{// A match result listener that forwards the explanation to a given}}
\DoxyCodeLine{237 \textcolor{comment}{// ostream.  The difference between this and MatchResultListener is}}
\DoxyCodeLine{238 \textcolor{comment}{// that the former is concrete.}}
\DoxyCodeLine{239 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1StreamMatchResultListener}{StreamMatchResultListener}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}} \{}
\DoxyCodeLine{240  \textcolor{keyword}{public}:}
\DoxyCodeLine{241   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1StreamMatchResultListener}{StreamMatchResultListener}}(::std::ostream* os)}
\DoxyCodeLine{242       : \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}(os) \{\}}
\DoxyCodeLine{243 }
\DoxyCodeLine{244  \textcolor{keyword}{private}:}
\DoxyCodeLine{245   GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1StreamMatchResultListener}{StreamMatchResultListener}});}
\DoxyCodeLine{246 \};}
\DoxyCodeLine{247 }
\DoxyCodeLine{248 \textcolor{comment}{// An internal class for implementing Matcher<T>, which will derive}}
\DoxyCodeLine{249 \textcolor{comment}{// from it.  We put functionalities common to all Matcher<T>}}
\DoxyCodeLine{250 \textcolor{comment}{// specializations here to avoid code duplication.}}
\DoxyCodeLine{251 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{252 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1MatcherBase}{MatcherBase}} \{}
\DoxyCodeLine{253  \textcolor{keyword}{public}:}
\DoxyCodeLine{254   \textcolor{comment}{// Returns true iff the matcher matches x; also explains the match}}
\DoxyCodeLine{255   \textcolor{comment}{// result to 'listener'.}}
\DoxyCodeLine{256   \textcolor{keywordtype}{bool} MatchAndExplain(T x, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{257     \textcolor{keywordflow}{return} impl\_-\/>MatchAndExplain(x, listener);}
\DoxyCodeLine{258   \}}
\DoxyCodeLine{259 }
\DoxyCodeLine{260   \textcolor{comment}{// Returns true iff this matcher matches x.}}
\DoxyCodeLine{261   \textcolor{keywordtype}{bool} Matches(T x)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{262     \mbox{\hyperlink{classtesting_1_1internal_1_1DummyMatchResultListener}{DummyMatchResultListener}} dummy;}
\DoxyCodeLine{263     \textcolor{keywordflow}{return} MatchAndExplain(x, \&dummy);}
\DoxyCodeLine{264   \}}
\DoxyCodeLine{265 }
\DoxyCodeLine{266   \textcolor{comment}{// Describes this matcher to an ostream.}}
\DoxyCodeLine{267   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{ impl\_-\/>DescribeTo(os); \}}
\DoxyCodeLine{268 }
\DoxyCodeLine{269   \textcolor{comment}{// Describes the negation of this matcher to an ostream.}}
\DoxyCodeLine{270   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{271     impl\_-\/>DescribeNegationTo(os);}
\DoxyCodeLine{272   \}}
\DoxyCodeLine{273 }
\DoxyCodeLine{274   \textcolor{comment}{// Explains why x matches, or doesn't match, the matcher.}}
\DoxyCodeLine{275   \textcolor{keywordtype}{void} ExplainMatchResultTo(T x, ::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{276     \mbox{\hyperlink{classtesting_1_1internal_1_1StreamMatchResultListener}{StreamMatchResultListener}} listener(os);}
\DoxyCodeLine{277     MatchAndExplain(x, \&listener);}
\DoxyCodeLine{278   \}}
\DoxyCodeLine{279 }
\DoxyCodeLine{280   \textcolor{comment}{// Returns the describer for this matcher object; retains ownership}}
\DoxyCodeLine{281   \textcolor{comment}{// of the describer, which is only guaranteed to be alive when}}
\DoxyCodeLine{282   \textcolor{comment}{// this matcher object is alive.}}
\DoxyCodeLine{283   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1MatcherDescriberInterface}{MatcherDescriberInterface}}* GetDescriber()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{284     \textcolor{keywordflow}{return} impl\_.get();}
\DoxyCodeLine{285   \}}
\DoxyCodeLine{286 }
\DoxyCodeLine{287  \textcolor{keyword}{protected}:}
\DoxyCodeLine{288   \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherBase}{MatcherBase}}() \{\}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290   \textcolor{comment}{// Constructs a matcher from its implementation.}}
\DoxyCodeLine{291   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherBase}{MatcherBase}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface<T>}}* impl)}
\DoxyCodeLine{292       : impl\_(impl) \{\}}
\DoxyCodeLine{293 }
\DoxyCodeLine{294   \textcolor{keyword}{virtual} \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherBase}{\string~MatcherBase}}() \{\}}
\DoxyCodeLine{295 }
\DoxyCodeLine{296  \textcolor{keyword}{private}:}
\DoxyCodeLine{297   \textcolor{comment}{// shared\_ptr (util/gtl/shared\_ptr.h) and linked\_ptr have similar}}
\DoxyCodeLine{298   \textcolor{comment}{// interfaces.  The former dynamically allocates a chunk of memory}}
\DoxyCodeLine{299   \textcolor{comment}{// to hold the reference count, while the latter tracks all}}
\DoxyCodeLine{300   \textcolor{comment}{// references using a circular linked list without allocating}}
\DoxyCodeLine{301   \textcolor{comment}{// memory.  It has been observed that linked\_ptr performs better in}}
\DoxyCodeLine{302   \textcolor{comment}{// typical scenarios.  However, shared\_ptr can out-\/perform}}
\DoxyCodeLine{303   \textcolor{comment}{// linked\_ptr when there are many more uses of the copy constructor}}
\DoxyCodeLine{304   \textcolor{comment}{// than the default constructor.}}
\DoxyCodeLine{305   \textcolor{comment}{//}}
\DoxyCodeLine{306   \textcolor{comment}{// If performance becomes a problem, we should see if using}}
\DoxyCodeLine{307   \textcolor{comment}{// shared\_ptr helps.}}
\DoxyCodeLine{308   \mbox{\hyperlink{classtesting_1_1internal_1_1linked__ptr}{::testing::internal::linked\_ptr<const MatcherInterface<T>}} > impl\_;}
\DoxyCodeLine{309 \};}
\DoxyCodeLine{310 }
\DoxyCodeLine{311 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{312 }
\DoxyCodeLine{313 \textcolor{comment}{// A Matcher<T> is a copyable and IMMUTABLE (except by assignment)}}
\DoxyCodeLine{314 \textcolor{comment}{// object that can check whether a value of type T matches.  The}}
\DoxyCodeLine{315 \textcolor{comment}{// implementation of Matcher<T> is just a linked\_ptr to const}}
\DoxyCodeLine{316 \textcolor{comment}{// MatcherInterface<T>, so copying is fairly cheap.  Don't inherit}}
\DoxyCodeLine{317 \textcolor{comment}{// from Matcher!}}
\DoxyCodeLine{318 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{319 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherBase}{internal::MatcherBase}}<T> \{}
\DoxyCodeLine{320  \textcolor{keyword}{public}:}
\DoxyCodeLine{321   \textcolor{comment}{// Constructs a null matcher.  Needed for storing Matcher objects in STL}}
\DoxyCodeLine{322   \textcolor{comment}{// containers.  A default-\/constructed matcher is not yet initialized.  You}}
\DoxyCodeLine{323   \textcolor{comment}{// cannot use it until a valid value has been assigned to it.}}
\DoxyCodeLine{324   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}() \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{325 }
\DoxyCodeLine{326   \textcolor{comment}{// Constructs a matcher from its implementation.}}
\DoxyCodeLine{327   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface<T>}}* impl)}
\DoxyCodeLine{328       : \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherBase}{internal::MatcherBase<T>}}(impl) \{\}}
\DoxyCodeLine{329 }
\DoxyCodeLine{330   \textcolor{comment}{// Implicit constructor here allows people to write}}
\DoxyCodeLine{331   \textcolor{comment}{// EXPECT\_CALL(foo, Bar(5)) instead of EXPECT\_CALL(foo, Bar(Eq(5))) sometimes}}
\DoxyCodeLine{332   \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}(T value);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{333 \};}
\DoxyCodeLine{334 }
\DoxyCodeLine{335 \textcolor{comment}{// The following two specializations allow the user to write str}}
\DoxyCodeLine{336 \textcolor{comment}{// instead of Eq(str) and "{}foo"{} instead of Eq("{}foo"{}) when a string}}
\DoxyCodeLine{337 \textcolor{comment}{// matcher is expected.}}
\DoxyCodeLine{338 \textcolor{keyword}{template} <>}
\DoxyCodeLine{339 \textcolor{keyword}{class }GTEST\_API\_ \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}<const internal::string\&>}
\DoxyCodeLine{340     : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherBase}{internal::MatcherBase}}<const internal::string\&> \{}
\DoxyCodeLine{341  \textcolor{keyword}{public}:}
\DoxyCodeLine{342   \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}() \{\}}
\DoxyCodeLine{343 }
\DoxyCodeLine{344   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface<const internal::string\&>}}* impl)}
\DoxyCodeLine{345       : \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherBase}{internal::MatcherBase<const internal::string\&>}}(impl) \{\}}
\DoxyCodeLine{346 }
\DoxyCodeLine{347   \textcolor{comment}{// Allows the user to write str instead of Eq(str) sometimes, where}}
\DoxyCodeLine{348   \textcolor{comment}{// str is a string object.}}
\DoxyCodeLine{349   \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}(\textcolor{keyword}{const} internal::string\& s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{350 }
\DoxyCodeLine{351   \textcolor{comment}{// Allows the user to write "{}foo"{} instead of Eq("{}foo"{}) sometimes.}}
\DoxyCodeLine{352   \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{353 \};}
\DoxyCodeLine{354 }
\DoxyCodeLine{355 \textcolor{keyword}{template} <>}
\DoxyCodeLine{356 \textcolor{keyword}{class }GTEST\_API\_ \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}<internal::string>}
\DoxyCodeLine{357     : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherBase}{internal::MatcherBase}}<internal::string> \{}
\DoxyCodeLine{358  \textcolor{keyword}{public}:}
\DoxyCodeLine{359   \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}() \{\}}
\DoxyCodeLine{360 }
\DoxyCodeLine{361   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface<internal::string>}}* impl)}
\DoxyCodeLine{362       : \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherBase}{internal::MatcherBase<internal::string>}}(impl) \{\}}
\DoxyCodeLine{363 }
\DoxyCodeLine{364   \textcolor{comment}{// Allows the user to write str instead of Eq(str) sometimes, where}}
\DoxyCodeLine{365   \textcolor{comment}{// str is a string object.}}
\DoxyCodeLine{366   \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}(\textcolor{keyword}{const} internal::string\& s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{367 }
\DoxyCodeLine{368   \textcolor{comment}{// Allows the user to write "{}foo"{} instead of Eq("{}foo"{}) sometimes.}}
\DoxyCodeLine{369   \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{370 \};}
\DoxyCodeLine{371 }
\DoxyCodeLine{372 \textcolor{preprocessor}{\#if GTEST\_HAS\_STRING\_PIECE\_}}
\DoxyCodeLine{373 \textcolor{comment}{// The following two specializations allow the user to write str}}
\DoxyCodeLine{374 \textcolor{comment}{// instead of Eq(str) and "{}foo"{} instead of Eq("{}foo"{}) when a StringPiece}}
\DoxyCodeLine{375 \textcolor{comment}{// matcher is expected.}}
\DoxyCodeLine{376 \textcolor{keyword}{template} <>}
\DoxyCodeLine{377 \textcolor{keyword}{class }GTEST\_API\_ \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}<const StringPiece\&>}
\DoxyCodeLine{378     : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherBase}{internal::MatcherBase<const StringPiece\&>}} \{}
\DoxyCodeLine{379  \textcolor{keyword}{public}:}
\DoxyCodeLine{380   \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}() \{\}}
\DoxyCodeLine{381 }
\DoxyCodeLine{382   \textcolor{keyword}{explicit} Matcher(\textcolor{keyword}{const} MatcherInterface<const StringPiece\&>* impl)}
\DoxyCodeLine{383       : internal::MatcherBase<const StringPiece\&>(impl) \{\}}
\DoxyCodeLine{384 }
\DoxyCodeLine{385   \textcolor{comment}{// Allows the user to write str instead of Eq(str) sometimes, where}}
\DoxyCodeLine{386   \textcolor{comment}{// str is a string object.}}
\DoxyCodeLine{387   Matcher(\textcolor{keyword}{const} internal::string\& s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{388 }
\DoxyCodeLine{389   \textcolor{comment}{// Allows the user to write "{}foo"{} instead of Eq("{}foo"{}) sometimes.}}
\DoxyCodeLine{390   Matcher(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{391 }
\DoxyCodeLine{392   \textcolor{comment}{// Allows the user to pass StringPieces directly.}}
\DoxyCodeLine{393   Matcher(StringPiece s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{394 \};}
\DoxyCodeLine{395 }
\DoxyCodeLine{396 \textcolor{keyword}{template} <>}
\DoxyCodeLine{397 \textcolor{keyword}{class }GTEST\_API\_ Matcher<StringPiece>}
\DoxyCodeLine{398     : \textcolor{keyword}{public} internal::MatcherBase<StringPiece> \{}
\DoxyCodeLine{399  \textcolor{keyword}{public}:}
\DoxyCodeLine{400   Matcher() \{\}}
\DoxyCodeLine{401 }
\DoxyCodeLine{402   \textcolor{keyword}{explicit} Matcher(\textcolor{keyword}{const} MatcherInterface<StringPiece>* impl)}
\DoxyCodeLine{403       : internal::MatcherBase<StringPiece>(impl) \{\}}
\DoxyCodeLine{404 }
\DoxyCodeLine{405   \textcolor{comment}{// Allows the user to write str instead of Eq(str) sometimes, where}}
\DoxyCodeLine{406   \textcolor{comment}{// str is a string object.}}
\DoxyCodeLine{407   Matcher(\textcolor{keyword}{const} internal::string\& s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{408 }
\DoxyCodeLine{409   \textcolor{comment}{// Allows the user to write "{}foo"{} instead of Eq("{}foo"{}) sometimes.}}
\DoxyCodeLine{410   Matcher(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{411 }
\DoxyCodeLine{412   \textcolor{comment}{// Allows the user to pass StringPieces directly.}}
\DoxyCodeLine{413   Matcher(StringPiece s);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{414 \};}
\DoxyCodeLine{415 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_STRING\_PIECE\_}}
\DoxyCodeLine{416 }
\DoxyCodeLine{417 \textcolor{comment}{// The PolymorphicMatcher class template makes it easy to implement a}}
\DoxyCodeLine{418 \textcolor{comment}{// polymorphic matcher (i.e. a matcher that can match values of more}}
\DoxyCodeLine{419 \textcolor{comment}{// than one type, e.g. Eq(n) and NotNull()).}}
\DoxyCodeLine{420 \textcolor{comment}{//}}
\DoxyCodeLine{421 \textcolor{comment}{// To define a polymorphic matcher, a user should provide an Impl}}
\DoxyCodeLine{422 \textcolor{comment}{// class that has a DescribeTo() method and a DescribeNegationTo()}}
\DoxyCodeLine{423 \textcolor{comment}{// method, and define a member function (or member function template)}}
\DoxyCodeLine{424 \textcolor{comment}{//}}
\DoxyCodeLine{425 \textcolor{comment}{//   bool MatchAndExplain(const Value\& value,}}
\DoxyCodeLine{426 \textcolor{comment}{//                        MatchResultListener* listener) const;}}
\DoxyCodeLine{427 \textcolor{comment}{//}}
\DoxyCodeLine{428 \textcolor{comment}{// See the definition of NotNull() for a complete example.}}
\DoxyCodeLine{429 \textcolor{keyword}{template} <\textcolor{keyword}{class} Impl>}
\DoxyCodeLine{430 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1PolymorphicMatcher}{PolymorphicMatcher}} \{}
\DoxyCodeLine{431  \textcolor{keyword}{public}:}
\DoxyCodeLine{432   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1PolymorphicMatcher}{PolymorphicMatcher}}(\textcolor{keyword}{const} Impl\& an\_impl) : impl\_(an\_impl) \{\}}
\DoxyCodeLine{433 }
\DoxyCodeLine{434   \textcolor{comment}{// Returns a mutable reference to the underlying matcher}}
\DoxyCodeLine{435   \textcolor{comment}{// implementation object.}}
\DoxyCodeLine{436   Impl\& mutable\_impl() \{ \textcolor{keywordflow}{return} impl\_; \}}
\DoxyCodeLine{437 }
\DoxyCodeLine{438   \textcolor{comment}{// Returns an immutable reference to the underlying matcher}}
\DoxyCodeLine{439   \textcolor{comment}{// implementation object.}}
\DoxyCodeLine{440   \textcolor{keyword}{const} Impl\& impl()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} impl\_; \}}
\DoxyCodeLine{441 }
\DoxyCodeLine{442   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{443   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{444     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}(\textcolor{keyword}{new} MonomorphicImpl<T>(impl\_));}
\DoxyCodeLine{445   \}}
\DoxyCodeLine{446 }
\DoxyCodeLine{447  \textcolor{keyword}{private}:}
\DoxyCodeLine{448   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{449   \textcolor{keyword}{class }MonomorphicImpl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<T> \{}
\DoxyCodeLine{450    \textcolor{keyword}{public}:}
\DoxyCodeLine{451     \textcolor{keyword}{explicit} MonomorphicImpl(\textcolor{keyword}{const} Impl\& impl) : impl\_(impl) \{\}}
\DoxyCodeLine{452 }
\DoxyCodeLine{453     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{454       impl\_.DescribeTo(os);}
\DoxyCodeLine{455     \}}
\DoxyCodeLine{456 }
\DoxyCodeLine{457     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{458       impl\_.DescribeNegationTo(os);}
\DoxyCodeLine{459     \}}
\DoxyCodeLine{460 }
\DoxyCodeLine{461     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(T x, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{462       \textcolor{keywordflow}{return} impl\_.MatchAndExplain(x, listener);}
\DoxyCodeLine{463     \}}
\DoxyCodeLine{464 }
\DoxyCodeLine{465    \textcolor{keyword}{private}:}
\DoxyCodeLine{466     \textcolor{keyword}{const} Impl impl\_;}
\DoxyCodeLine{467 }
\DoxyCodeLine{468     GTEST\_DISALLOW\_ASSIGN\_(MonomorphicImpl);}
\DoxyCodeLine{469   \};}
\DoxyCodeLine{470 }
\DoxyCodeLine{471   Impl impl\_;}
\DoxyCodeLine{472 }
\DoxyCodeLine{473   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1PolymorphicMatcher}{PolymorphicMatcher}});}
\DoxyCodeLine{474 \};}
\DoxyCodeLine{475 }
\DoxyCodeLine{476 \textcolor{comment}{// Creates a matcher from its implementation.  This is easier to use}}
\DoxyCodeLine{477 \textcolor{comment}{// than the Matcher<T> constructor as it doesn't require you to}}
\DoxyCodeLine{478 \textcolor{comment}{// explicitly write the template argument, e.g.}}
\DoxyCodeLine{479 \textcolor{comment}{//}}
\DoxyCodeLine{480 \textcolor{comment}{//   MakeMatcher(foo);}}
\DoxyCodeLine{481 \textcolor{comment}{// vs}}
\DoxyCodeLine{482 \textcolor{comment}{//   Matcher<const string\&>(foo);}}
\DoxyCodeLine{483 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{484 \textcolor{keyword}{inline} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} MakeMatcher(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface<T>}}* impl) \{}
\DoxyCodeLine{485   \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}(impl);}
\DoxyCodeLine{486 \}}
\DoxyCodeLine{487 }
\DoxyCodeLine{488 \textcolor{comment}{// Creates a polymorphic matcher from its implementation.  This is}}
\DoxyCodeLine{489 \textcolor{comment}{// easier to use than the PolymorphicMatcher<Impl> constructor as it}}
\DoxyCodeLine{490 \textcolor{comment}{// doesn't require you to explicitly write the template argument, e.g.}}
\DoxyCodeLine{491 \textcolor{comment}{//}}
\DoxyCodeLine{492 \textcolor{comment}{//   MakePolymorphicMatcher(foo);}}
\DoxyCodeLine{493 \textcolor{comment}{// vs}}
\DoxyCodeLine{494 \textcolor{comment}{//   PolymorphicMatcher<TypeOfFoo>(foo);}}
\DoxyCodeLine{495 \textcolor{keyword}{template} <\textcolor{keyword}{class} Impl>}
\DoxyCodeLine{496 \textcolor{keyword}{inline} PolymorphicMatcher<Impl> MakePolymorphicMatcher(\textcolor{keyword}{const} Impl\& impl) \{}
\DoxyCodeLine{497   \textcolor{keywordflow}{return} PolymorphicMatcher<Impl>(impl);}
\DoxyCodeLine{498 \}}
\DoxyCodeLine{499 }
\DoxyCodeLine{500 \textcolor{comment}{// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION}}
\DoxyCodeLine{501 \textcolor{comment}{// and MUST NOT BE USED IN USER CODE!!!}}
\DoxyCodeLine{502 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{503 }
\DoxyCodeLine{504 \textcolor{comment}{// The MatcherCastImpl class template is a helper for implementing}}
\DoxyCodeLine{505 \textcolor{comment}{// MatcherCast().  We need this helper in order to partially}}
\DoxyCodeLine{506 \textcolor{comment}{// specialize the implementation of MatcherCast() (C++ allows}}
\DoxyCodeLine{507 \textcolor{comment}{// class/struct templates to be partially specialized, but not}}
\DoxyCodeLine{508 \textcolor{comment}{// function templates.).}}
\DoxyCodeLine{509 }
\DoxyCodeLine{510 \textcolor{comment}{// This general version is used when MatcherCast()'s argument is a}}
\DoxyCodeLine{511 \textcolor{comment}{// polymorphic matcher (i.e. something that can be converted to a}}
\DoxyCodeLine{512 \textcolor{comment}{// Matcher but is not one yet; for example, Eq(value)) or a value (for}}
\DoxyCodeLine{513 \textcolor{comment}{// example, "{}hello"{}).}}
\DoxyCodeLine{514 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{515 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1MatcherCastImpl}{MatcherCastImpl}} \{}
\DoxyCodeLine{516  \textcolor{keyword}{public}:}
\DoxyCodeLine{517   \textcolor{keyword}{static} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} Cast(\textcolor{keyword}{const} M\& polymorphic\_matcher\_or\_value) \{}
\DoxyCodeLine{518     \textcolor{comment}{// M can be a polymorhic matcher, in which case we want to use}}
\DoxyCodeLine{519     \textcolor{comment}{// its conversion operator to create Matcher<T>.  Or it can be a value}}
\DoxyCodeLine{520     \textcolor{comment}{// that should be passed to the Matcher<T>'s constructor.}}
\DoxyCodeLine{521     \textcolor{comment}{//}}
\DoxyCodeLine{522     \textcolor{comment}{// We can't call Matcher<T>(polymorphic\_matcher\_or\_value) when M is a}}
\DoxyCodeLine{523     \textcolor{comment}{// polymorphic matcher because it'll be ambiguous if T has an implicit}}
\DoxyCodeLine{524     \textcolor{comment}{// constructor from M (this usually happens when T has an implicit}}
\DoxyCodeLine{525     \textcolor{comment}{// constructor from any type).}}
\DoxyCodeLine{526     \textcolor{comment}{//}}
\DoxyCodeLine{527     \textcolor{comment}{// It won't work to unconditionally implict\_cast}}
\DoxyCodeLine{528     \textcolor{comment}{// polymorphic\_matcher\_or\_value to Matcher<T> because it won't trigger}}
\DoxyCodeLine{529     \textcolor{comment}{// a user-\/defined conversion from M to T if one exists (assuming M is}}
\DoxyCodeLine{530     \textcolor{comment}{// a value).}}
\DoxyCodeLine{531     \textcolor{keywordflow}{return} CastImpl(}
\DoxyCodeLine{532         polymorphic\_matcher\_or\_value,}
\DoxyCodeLine{533         \mbox{\hyperlink{structtesting_1_1internal_1_1BooleanConstant}{BooleanConstant}}<}
\DoxyCodeLine{534             \mbox{\hyperlink{classtesting_1_1internal_1_1ImplicitlyConvertible}{internal::ImplicitlyConvertible}}<M, \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} >::value>());}
\DoxyCodeLine{535   \}}
\DoxyCodeLine{536 }
\DoxyCodeLine{537  \textcolor{keyword}{private}:}
\DoxyCodeLine{538   \textcolor{keyword}{static} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} CastImpl(\textcolor{keyword}{const} M\& value, \mbox{\hyperlink{structtesting_1_1internal_1_1BooleanConstant}{BooleanConstant<false>}}) \{}
\DoxyCodeLine{539     \textcolor{comment}{// M can't be implicitly converted to Matcher<T>, so M isn't a polymorphic}}
\DoxyCodeLine{540     \textcolor{comment}{// matcher.  It must be a value then.  Use direct initialization to create}}
\DoxyCodeLine{541     \textcolor{comment}{// a matcher.}}
\DoxyCodeLine{542     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}(ImplicitCast\_<T>(value));}
\DoxyCodeLine{543   \}}
\DoxyCodeLine{544 }
\DoxyCodeLine{545   \textcolor{keyword}{static} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} CastImpl(\textcolor{keyword}{const} M\& polymorphic\_matcher\_or\_value,}
\DoxyCodeLine{546                              \mbox{\hyperlink{structtesting_1_1internal_1_1BooleanConstant}{BooleanConstant<true>}}) \{}
\DoxyCodeLine{547     \textcolor{comment}{// M is implicitly convertible to Matcher<T>, which means that either}}
\DoxyCodeLine{548     \textcolor{comment}{// M is a polymorhpic matcher or Matcher<T> has an implicit constructor}}
\DoxyCodeLine{549     \textcolor{comment}{// from M.  In both cases using the implicit conversion will produce a}}
\DoxyCodeLine{550     \textcolor{comment}{// matcher.}}
\DoxyCodeLine{551     \textcolor{comment}{//}}
\DoxyCodeLine{552     \textcolor{comment}{// Even if T has an implicit constructor from M, it won't be called because}}
\DoxyCodeLine{553     \textcolor{comment}{// creating Matcher<T> would require a chain of two user-\/defined conversions}}
\DoxyCodeLine{554     \textcolor{comment}{// (first to create T from M and then to create Matcher<T> from T).}}
\DoxyCodeLine{555     \textcolor{keywordflow}{return} polymorphic\_matcher\_or\_value;}
\DoxyCodeLine{556   \}}
\DoxyCodeLine{557 \};}
\DoxyCodeLine{558 }
\DoxyCodeLine{559 \textcolor{comment}{// This more specialized version is used when MatcherCast()'s argument}}
\DoxyCodeLine{560 \textcolor{comment}{// is already a Matcher.  This only compiles when type T can be}}
\DoxyCodeLine{561 \textcolor{comment}{// statically converted to type U.}}
\DoxyCodeLine{562 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{563 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1MatcherCastImpl}{MatcherCastImpl}}<T, \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}<U> > \{}
\DoxyCodeLine{564  \textcolor{keyword}{public}:}
\DoxyCodeLine{565   \textcolor{keyword}{static} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} Cast(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<U>}}\& source\_matcher) \{}
\DoxyCodeLine{566     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}(\textcolor{keyword}{new} Impl(source\_matcher));}
\DoxyCodeLine{567   \}}
\DoxyCodeLine{568 }
\DoxyCodeLine{569  \textcolor{keyword}{private}:}
\DoxyCodeLine{570   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<T> \{}
\DoxyCodeLine{571    \textcolor{keyword}{public}:}
\DoxyCodeLine{572     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<U>}}\& source\_matcher)}
\DoxyCodeLine{573         : source\_matcher\_(source\_matcher) \{\}}
\DoxyCodeLine{574 }
\DoxyCodeLine{575     \textcolor{comment}{// We delegate the matching logic to the source matcher.}}
\DoxyCodeLine{576     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(T x, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{577       \textcolor{keywordflow}{return} source\_matcher\_.MatchAndExplain(\textcolor{keyword}{static\_cast<}U\textcolor{keyword}{>}(x), listener);}
\DoxyCodeLine{578     \}}
\DoxyCodeLine{579 }
\DoxyCodeLine{580     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{581       source\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{582     \}}
\DoxyCodeLine{583 }
\DoxyCodeLine{584     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{585       source\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{586     \}}
\DoxyCodeLine{587 }
\DoxyCodeLine{588    \textcolor{keyword}{private}:}
\DoxyCodeLine{589     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<U>}} source\_matcher\_;}
\DoxyCodeLine{590 }
\DoxyCodeLine{591     GTEST\_DISALLOW\_ASSIGN\_(Impl);}
\DoxyCodeLine{592   \};}
\DoxyCodeLine{593 \};}
\DoxyCodeLine{594 }
\DoxyCodeLine{595 \textcolor{comment}{// This even more specialized version is used for efficiently casting}}
\DoxyCodeLine{596 \textcolor{comment}{// a matcher to its own type.}}
\DoxyCodeLine{597 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{598 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1MatcherCastImpl}{MatcherCastImpl}}<T, \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}<T> > \{}
\DoxyCodeLine{599  \textcolor{keyword}{public}:}
\DoxyCodeLine{600   \textcolor{keyword}{static} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} Cast(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}\& matcher) \{ \textcolor{keywordflow}{return} matcher; \}}
\DoxyCodeLine{601 \};}
\DoxyCodeLine{602 }
\DoxyCodeLine{603 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{604 }
\DoxyCodeLine{605 \textcolor{comment}{// In order to be safe and clear, casting between different matcher}}
\DoxyCodeLine{606 \textcolor{comment}{// types is done explicitly via MatcherCast<T>(m), which takes a}}
\DoxyCodeLine{607 \textcolor{comment}{// matcher m and returns a Matcher<T>.  It compiles only when T can be}}
\DoxyCodeLine{608 \textcolor{comment}{// statically converted to the argument type of m.}}
\DoxyCodeLine{609 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{610 \textcolor{keyword}{inline} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} MatcherCast(\textcolor{keyword}{const} M\& matcher) \{}
\DoxyCodeLine{611   \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherCastImpl}{internal::MatcherCastImpl<T, M>::Cast}}(matcher);}
\DoxyCodeLine{612 \}}
\DoxyCodeLine{613 }
\DoxyCodeLine{614 \textcolor{comment}{// Implements SafeMatcherCast().}}
\DoxyCodeLine{615 \textcolor{comment}{//}}
\DoxyCodeLine{616 \textcolor{comment}{// We use an intermediate class to do the actual safe casting as Nokia's}}
\DoxyCodeLine{617 \textcolor{comment}{// Symbian compiler cannot decide between}}
\DoxyCodeLine{618 \textcolor{comment}{// template <T, M> ... (M) and}}
\DoxyCodeLine{619 \textcolor{comment}{// template <T, U> ... (const Matcher<U>\&)}}
\DoxyCodeLine{620 \textcolor{comment}{// for function templates but can for member function templates.}}
\DoxyCodeLine{621 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{622 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1SafeMatcherCastImpl}{SafeMatcherCastImpl}} \{}
\DoxyCodeLine{623  \textcolor{keyword}{public}:}
\DoxyCodeLine{624   \textcolor{comment}{// This overload handles polymorphic matchers and values only since}}
\DoxyCodeLine{625   \textcolor{comment}{// monomorphic matchers are handled by the next one.}}
\DoxyCodeLine{626   \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{627   \textcolor{keyword}{static} \textcolor{keyword}{inline} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} Cast(\textcolor{keyword}{const} M\& polymorphic\_matcher\_or\_value) \{}
\DoxyCodeLine{628     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherCastImpl}{internal::MatcherCastImpl<T, M>::Cast}}(polymorphic\_matcher\_or\_value);}
\DoxyCodeLine{629   \}}
\DoxyCodeLine{630 }
\DoxyCodeLine{631   \textcolor{comment}{// This overload handles monomorphic matchers.}}
\DoxyCodeLine{632   \textcolor{comment}{//}}
\DoxyCodeLine{633   \textcolor{comment}{// In general, if type T can be implicitly converted to type U, we can}}
\DoxyCodeLine{634   \textcolor{comment}{// safely convert a Matcher<U> to a Matcher<T> (i.e. Matcher is}}
\DoxyCodeLine{635   \textcolor{comment}{// contravariant): just keep a copy of the original Matcher<U>, convert the}}
\DoxyCodeLine{636   \textcolor{comment}{// argument from type T to U, and then pass it to the underlying Matcher<U>.}}
\DoxyCodeLine{637   \textcolor{comment}{// The only exception is when U is a reference and T is not, as the}}
\DoxyCodeLine{638   \textcolor{comment}{// underlying Matcher<U> may be interested in the argument's address, which}}
\DoxyCodeLine{639   \textcolor{comment}{// is not preserved in the conversion from T to U.}}
\DoxyCodeLine{640   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{641   \textcolor{keyword}{static} \textcolor{keyword}{inline} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} Cast(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<U>}}\& matcher) \{}
\DoxyCodeLine{642     \textcolor{comment}{// Enforce that T can be implicitly converted to U.}}
\DoxyCodeLine{643     GTEST\_COMPILE\_ASSERT\_((\mbox{\hyperlink{classtesting_1_1internal_1_1ImplicitlyConvertible}{internal::ImplicitlyConvertible<T, U>::value}}),}
\DoxyCodeLine{644                           T\_must\_be\_implicitly\_convertible\_to\_U);}
\DoxyCodeLine{645     \textcolor{comment}{// Enforce that we are not converting a non-\/reference type T to a reference}}
\DoxyCodeLine{646     \textcolor{comment}{// type U.}}
\DoxyCodeLine{647     GTEST\_COMPILE\_ASSERT\_(}
\DoxyCodeLine{648         \mbox{\hyperlink{structtesting_1_1internal_1_1is__reference}{internal::is\_reference<T>::value}} || !\mbox{\hyperlink{structtesting_1_1internal_1_1is__reference}{internal::is\_reference<U>::value}},}
\DoxyCodeLine{649         cannot\_convert\_non\_referentce\_arg\_to\_reference);}
\DoxyCodeLine{650     \textcolor{comment}{// In case both T and U are arithmetic types, enforce that the}}
\DoxyCodeLine{651     \textcolor{comment}{// conversion is not lossy.}}
\DoxyCodeLine{652     \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(T) RawT;}
\DoxyCodeLine{653     \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(U) RawU;}
\DoxyCodeLine{654     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} kTIsOther = GMOCK\_KIND\_OF\_(RawT) == internal::kOther;}
\DoxyCodeLine{655     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} kUIsOther = GMOCK\_KIND\_OF\_(RawU) == internal::kOther;}
\DoxyCodeLine{656     GTEST\_COMPILE\_ASSERT\_(}
\DoxyCodeLine{657         kTIsOther || kUIsOther ||}
\DoxyCodeLine{658         (internal::LosslessArithmeticConvertible<RawT, RawU>::value),}
\DoxyCodeLine{659         conversion\_of\_arithmetic\_types\_must\_be\_lossless);}
\DoxyCodeLine{660     \textcolor{keywordflow}{return} MatcherCast<T>(matcher);}
\DoxyCodeLine{661   \}}
\DoxyCodeLine{662 \};}
\DoxyCodeLine{663 }
\DoxyCodeLine{664 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{665 \textcolor{keyword}{inline} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} SafeMatcherCast(\textcolor{keyword}{const} M\& polymorphic\_matcher) \{}
\DoxyCodeLine{666   \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1SafeMatcherCastImpl}{SafeMatcherCastImpl<T>::Cast}}(polymorphic\_matcher);}
\DoxyCodeLine{667 \}}
\DoxyCodeLine{668 }
\DoxyCodeLine{669 \textcolor{comment}{// A<T>() returns a matcher that matches any value of type T.}}
\DoxyCodeLine{670 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{671 Matcher<T> A();}
\DoxyCodeLine{672 }
\DoxyCodeLine{673 \textcolor{comment}{// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION}}
\DoxyCodeLine{674 \textcolor{comment}{// and MUST NOT BE USED IN USER CODE!!!}}
\DoxyCodeLine{675 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{676 }
\DoxyCodeLine{677 \textcolor{comment}{// If the explanation is not empty, prints it to the ostream.}}
\DoxyCodeLine{678 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} PrintIfNotEmpty(\textcolor{keyword}{const} internal::string\& explanation,}
\DoxyCodeLine{679                             ::std::ostream* os) \{}
\DoxyCodeLine{680   \textcolor{keywordflow}{if} (explanation != \textcolor{stringliteral}{"{}"{}} \&\& os != NULL) \{}
\DoxyCodeLine{681     *os << \textcolor{stringliteral}{"{}, "{}} << explanation;}
\DoxyCodeLine{682   \}}
\DoxyCodeLine{683 \}}
\DoxyCodeLine{684 }
\DoxyCodeLine{685 \textcolor{comment}{// Returns true if the given type name is easy to read by a human.}}
\DoxyCodeLine{686 \textcolor{comment}{// This is used to decide whether printing the type of a value might}}
\DoxyCodeLine{687 \textcolor{comment}{// be helpful.}}
\DoxyCodeLine{688 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} IsReadableTypeName(\textcolor{keyword}{const} \textcolor{keywordtype}{string}\& type\_name) \{}
\DoxyCodeLine{689   \textcolor{comment}{// We consider a type name readable if it's short or doesn't contain}}
\DoxyCodeLine{690   \textcolor{comment}{// a template or function type.}}
\DoxyCodeLine{691   \textcolor{keywordflow}{return} (type\_name.length() <= 20 ||}
\DoxyCodeLine{692           type\_name.find\_first\_of(\textcolor{stringliteral}{"{}<("{}}) == string::npos);}
\DoxyCodeLine{693 \}}
\DoxyCodeLine{694 }
\DoxyCodeLine{695 \textcolor{comment}{// Matches the value against the given matcher, prints the value and explains}}
\DoxyCodeLine{696 \textcolor{comment}{// the match result to the listener. Returns the match result.}}
\DoxyCodeLine{697 \textcolor{comment}{// 'listener' must not be NULL.}}
\DoxyCodeLine{698 \textcolor{comment}{// Value cannot be passed by const reference, because some matchers take a}}
\DoxyCodeLine{699 \textcolor{comment}{// non-\/const argument.}}
\DoxyCodeLine{700 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{701 \textcolor{keywordtype}{bool} MatchPrintAndExplain(Value\& value, \textcolor{keyword}{const} Matcher<T>\& matcher,}
\DoxyCodeLine{702                           MatchResultListener* listener) \{}
\DoxyCodeLine{703   \textcolor{keywordflow}{if} (!listener-\/>IsInterested()) \{}
\DoxyCodeLine{704     \textcolor{comment}{// If the listener is not interested, we do not need to construct the}}
\DoxyCodeLine{705     \textcolor{comment}{// inner explanation.}}
\DoxyCodeLine{706     \textcolor{keywordflow}{return} matcher.Matches(value);}
\DoxyCodeLine{707   \}}
\DoxyCodeLine{708 }
\DoxyCodeLine{709   StringMatchResultListener inner\_listener;}
\DoxyCodeLine{710   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} match = matcher.MatchAndExplain(value, \&inner\_listener);}
\DoxyCodeLine{711 }
\DoxyCodeLine{712   UniversalPrint(value, listener-\/>stream());}
\DoxyCodeLine{713 \textcolor{preprocessor}{\#if GTEST\_HAS\_RTTI}}
\DoxyCodeLine{714   \textcolor{keyword}{const} \textcolor{keywordtype}{string}\& type\_name = GetTypeName<Value>();}
\DoxyCodeLine{715   \textcolor{keywordflow}{if} (IsReadableTypeName(type\_name))}
\DoxyCodeLine{716     *listener-\/>stream() << \textcolor{stringliteral}{"{} (of type "{}} << type\_name << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{717 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{718   PrintIfNotEmpty(inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{719 }
\DoxyCodeLine{720   \textcolor{keywordflow}{return} match;}
\DoxyCodeLine{721 \}}
\DoxyCodeLine{722 }
\DoxyCodeLine{723 \textcolor{comment}{// An internal helper class for doing compile-\/time loop on a tuple's}}
\DoxyCodeLine{724 \textcolor{comment}{// fields.}}
\DoxyCodeLine{725 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{726 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1TuplePrefix}{TuplePrefix}} \{}
\DoxyCodeLine{727  \textcolor{keyword}{public}:}
\DoxyCodeLine{728   \textcolor{comment}{// TuplePrefix<N>::Matches(matcher\_tuple, value\_tuple) returns true}}
\DoxyCodeLine{729   \textcolor{comment}{// iff the first N fields of matcher\_tuple matches the first N}}
\DoxyCodeLine{730   \textcolor{comment}{// fields of value\_tuple, respectively.}}
\DoxyCodeLine{731   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple, \textcolor{keyword}{typename} ValueTuple>}
\DoxyCodeLine{732   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Matches(\textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1MatcherTuple}{MatcherTuple}}\& matcher\_tuple,}
\DoxyCodeLine{733                       \textcolor{keyword}{const} ValueTuple\& value\_tuple) \{}
\DoxyCodeLine{734     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1TuplePrefix}{TuplePrefix<N -\/ 1>::Matches}}(matcher\_tuple, value\_tuple)}
\DoxyCodeLine{735         \&\& get<N -\/ 1>(matcher\_tuple).Matches(get<N -\/ 1>(value\_tuple));}
\DoxyCodeLine{736   \}}
\DoxyCodeLine{737 }
\DoxyCodeLine{738   \textcolor{comment}{// TuplePrefix<N>::ExplainMatchFailuresTo(matchers, values, os)}}
\DoxyCodeLine{739   \textcolor{comment}{// describes failures in matching the first N fields of matchers}}
\DoxyCodeLine{740   \textcolor{comment}{// against the first N fields of values.  If there is no failure,}}
\DoxyCodeLine{741   \textcolor{comment}{// nothing will be streamed to os.}}
\DoxyCodeLine{742   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple, \textcolor{keyword}{typename} ValueTuple>}
\DoxyCodeLine{743   \textcolor{keyword}{static} \textcolor{keywordtype}{void} ExplainMatchFailuresTo(\textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1MatcherTuple}{MatcherTuple}}\& matchers,}
\DoxyCodeLine{744                                      \textcolor{keyword}{const} ValueTuple\& values,}
\DoxyCodeLine{745                                      ::std::ostream* os) \{}
\DoxyCodeLine{746     \textcolor{comment}{// First, describes failures in the first N -\/ 1 fields.}}
\DoxyCodeLine{747     \mbox{\hyperlink{classtesting_1_1internal_1_1TuplePrefix}{TuplePrefix<N -\/ 1>::ExplainMatchFailuresTo}}(matchers, values, os);}
\DoxyCodeLine{748 }
\DoxyCodeLine{749     \textcolor{comment}{// Then describes the failure (if any) in the (N -\/ 1)-\/th (0-\/based)}}
\DoxyCodeLine{750     \textcolor{comment}{// field.}}
\DoxyCodeLine{751     \textcolor{keyword}{typename} tuple\_element<N -\/ 1, \mbox{\hyperlink{structtesting_1_1internal_1_1MatcherTuple}{MatcherTuple}}>::type matcher =}
\DoxyCodeLine{752         get<N -\/ 1>(matchers);}
\DoxyCodeLine{753     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} tuple\_element<N -\/ 1, ValueTuple>::type Value;}
\DoxyCodeLine{754     Value value = get<N -\/ 1>(values);}
\DoxyCodeLine{755     \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} listener;}
\DoxyCodeLine{756     \textcolor{keywordflow}{if} (!matcher.MatchAndExplain(value, \&listener)) \{}
\DoxyCodeLine{757       \textcolor{comment}{// TODO(wan): include in the message the name of the parameter}}
\DoxyCodeLine{758       \textcolor{comment}{// as used in MOCK\_METHOD*() when possible.}}
\DoxyCodeLine{759       *os << \textcolor{stringliteral}{"{}  Expected arg \#"{}} << N -\/ 1 << \textcolor{stringliteral}{"{}: "{}};}
\DoxyCodeLine{760       get<N -\/ 1>(matchers).DescribeTo(os);}
\DoxyCodeLine{761       *os << \textcolor{stringliteral}{"{}\(\backslash\)n           Actual: "{}};}
\DoxyCodeLine{762       \textcolor{comment}{// We remove the reference in type Value to prevent the}}
\DoxyCodeLine{763       \textcolor{comment}{// universal printer from printing the address of value, which}}
\DoxyCodeLine{764       \textcolor{comment}{// isn't interesting to the user most of the time.  The}}
\DoxyCodeLine{765       \textcolor{comment}{// matcher's MatchAndExplain() method handles the case when}}
\DoxyCodeLine{766       \textcolor{comment}{// the address is interesting.}}
\DoxyCodeLine{767       internal::UniversalPrint(value, os);}
\DoxyCodeLine{768       PrintIfNotEmpty(listener.str(), os);}
\DoxyCodeLine{769       *os << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{770     \}}
\DoxyCodeLine{771   \}}
\DoxyCodeLine{772 \};}
\DoxyCodeLine{773 }
\DoxyCodeLine{774 \textcolor{comment}{// The base case.}}
\DoxyCodeLine{775 \textcolor{keyword}{template} <>}
\DoxyCodeLine{776 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1TuplePrefix}{TuplePrefix}}<0> \{}
\DoxyCodeLine{777  \textcolor{keyword}{public}:}
\DoxyCodeLine{778   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple, \textcolor{keyword}{typename} ValueTuple>}
\DoxyCodeLine{779   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Matches(\textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1MatcherTuple}{MatcherTuple}}\& \textcolor{comment}{/* matcher\_tuple */},}
\DoxyCodeLine{780                       \textcolor{keyword}{const} ValueTuple\& \textcolor{comment}{/* value\_tuple */}) \{}
\DoxyCodeLine{781     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{782   \}}
\DoxyCodeLine{783 }
\DoxyCodeLine{784   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple, \textcolor{keyword}{typename} ValueTuple>}
\DoxyCodeLine{785   \textcolor{keyword}{static} \textcolor{keywordtype}{void} ExplainMatchFailuresTo(\textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1MatcherTuple}{MatcherTuple}}\& \textcolor{comment}{/* matchers */},}
\DoxyCodeLine{786                                      \textcolor{keyword}{const} ValueTuple\& \textcolor{comment}{/* values */},}
\DoxyCodeLine{787                                      ::std::ostream* \textcolor{comment}{/* os */}) \{\}}
\DoxyCodeLine{788 \};}
\DoxyCodeLine{789 }
\DoxyCodeLine{790 \textcolor{comment}{// TupleMatches(matcher\_tuple, value\_tuple) returns true iff all}}
\DoxyCodeLine{791 \textcolor{comment}{// matchers in matcher\_tuple match the corresponding fields in}}
\DoxyCodeLine{792 \textcolor{comment}{// value\_tuple.  It is a compiler error if matcher\_tuple and}}
\DoxyCodeLine{793 \textcolor{comment}{// value\_tuple have different number of fields or incompatible field}}
\DoxyCodeLine{794 \textcolor{comment}{// types.}}
\DoxyCodeLine{795 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple, \textcolor{keyword}{typename} ValueTuple>}
\DoxyCodeLine{796 \textcolor{keywordtype}{bool} TupleMatches(\textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1MatcherTuple}{MatcherTuple}}\& matcher\_tuple,}
\DoxyCodeLine{797                   \textcolor{keyword}{const} ValueTuple\& value\_tuple) \{}
\DoxyCodeLine{798   \textcolor{comment}{// Makes sure that matcher\_tuple and value\_tuple have the same}}
\DoxyCodeLine{799   \textcolor{comment}{// number of fields.}}
\DoxyCodeLine{800   GTEST\_COMPILE\_ASSERT\_(tuple\_size<MatcherTuple>::value ==}
\DoxyCodeLine{801                         tuple\_size<ValueTuple>::value,}
\DoxyCodeLine{802                         matcher\_and\_value\_have\_different\_numbers\_of\_fields);}
\DoxyCodeLine{803   \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1TuplePrefix}{TuplePrefix<tuple\_size<ValueTuple>::value}}>::}
\DoxyCodeLine{804       Matches(matcher\_tuple, value\_tuple);}
\DoxyCodeLine{805 \}}
\DoxyCodeLine{806 }
\DoxyCodeLine{807 \textcolor{comment}{// Describes failures in matching matchers against values.  If there}}
\DoxyCodeLine{808 \textcolor{comment}{// is no failure, nothing will be streamed to os.}}
\DoxyCodeLine{809 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple, \textcolor{keyword}{typename} ValueTuple>}
\DoxyCodeLine{810 \textcolor{keywordtype}{void} ExplainMatchFailureTupleTo(\textcolor{keyword}{const} MatcherTuple\& matchers,}
\DoxyCodeLine{811                                 \textcolor{keyword}{const} ValueTuple\& values,}
\DoxyCodeLine{812                                 ::std::ostream* os) \{}
\DoxyCodeLine{813   TuplePrefix<tuple\_size<MatcherTuple>::value>::ExplainMatchFailuresTo(}
\DoxyCodeLine{814       matchers, values, os);}
\DoxyCodeLine{815 \}}
\DoxyCodeLine{816 }
\DoxyCodeLine{817 \textcolor{comment}{// TransformTupleValues and its helper.}}
\DoxyCodeLine{818 \textcolor{comment}{//}}
\DoxyCodeLine{819 \textcolor{comment}{// TransformTupleValuesHelper hides the internal machinery that}}
\DoxyCodeLine{820 \textcolor{comment}{// TransformTupleValues uses to implement a tuple traversal.}}
\DoxyCodeLine{821 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple, \textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} OutIter>}
\DoxyCodeLine{822 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1TransformTupleValuesHelper}{TransformTupleValuesHelper}} \{}
\DoxyCodeLine{823  \textcolor{keyword}{private}:}
\DoxyCodeLine{824   typedef ::testing::tuple\_size<Tuple> TupleSize;}
\DoxyCodeLine{825 }
\DoxyCodeLine{826  \textcolor{keyword}{public}:}
\DoxyCodeLine{827   \textcolor{comment}{// For each member of tuple 't', taken in order, evaluates '*out++ = f(t)'.}}
\DoxyCodeLine{828   \textcolor{comment}{// Returns the final value of 'out' in case the caller needs it.}}
\DoxyCodeLine{829   \textcolor{keyword}{static} OutIter Run(Func f, \textcolor{keyword}{const} Tuple\& t, OutIter out) \{}
\DoxyCodeLine{830     \textcolor{keywordflow}{return} IterateOverTuple<Tuple, TupleSize::value>()(f, t, out);}
\DoxyCodeLine{831   \}}
\DoxyCodeLine{832 }
\DoxyCodeLine{833  \textcolor{keyword}{private}:}
\DoxyCodeLine{834   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tup, \textcolor{keywordtype}{size\_t} kRemainingSize>}
\DoxyCodeLine{835   \textcolor{keyword}{struct }IterateOverTuple \{}
\DoxyCodeLine{836     OutIter operator() (Func f, \textcolor{keyword}{const} Tup\& t, OutIter out)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{837       *out++ = f(::testing::get<TupleSize::value -\/ kRemainingSize>(t));}
\DoxyCodeLine{838       \textcolor{keywordflow}{return} IterateOverTuple<Tup, kRemainingSize -\/ 1>()(f, t, out);}
\DoxyCodeLine{839     \}}
\DoxyCodeLine{840   \};}
\DoxyCodeLine{841   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tup>}
\DoxyCodeLine{842   \textcolor{keyword}{struct }IterateOverTuple<Tup, 0> \{}
\DoxyCodeLine{843     OutIter operator() (Func \textcolor{comment}{/* f */}, \textcolor{keyword}{const} Tup\& \textcolor{comment}{/* t */}, OutIter out)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{844       \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{845     \}}
\DoxyCodeLine{846   \};}
\DoxyCodeLine{847 \};}
\DoxyCodeLine{848 }
\DoxyCodeLine{849 \textcolor{comment}{// Successively invokes 'f(element)' on each element of the tuple 't',}}
\DoxyCodeLine{850 \textcolor{comment}{// appending each result to the 'out' iterator. Returns the final value}}
\DoxyCodeLine{851 \textcolor{comment}{// of 'out'.}}
\DoxyCodeLine{852 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple, \textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} OutIter>}
\DoxyCodeLine{853 OutIter TransformTupleValues(Func f, \textcolor{keyword}{const} Tuple\& t, OutIter out) \{}
\DoxyCodeLine{854   \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1TransformTupleValuesHelper}{TransformTupleValuesHelper<Tuple, Func, OutIter>::Run}}(f, t, out);}
\DoxyCodeLine{855 \}}
\DoxyCodeLine{856 }
\DoxyCodeLine{857 \textcolor{comment}{// Implements A<T>().}}
\DoxyCodeLine{858 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{859 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1AnyMatcherImpl}{AnyMatcherImpl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<T> \{}
\DoxyCodeLine{860  \textcolor{keyword}{public}:}
\DoxyCodeLine{861   \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(}
\DoxyCodeLine{862       T \textcolor{comment}{/* x */}, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{863   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{ *os << \textcolor{stringliteral}{"{}is anything"{}}; \}}
\DoxyCodeLine{864   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{865     \textcolor{comment}{// This is mostly for completeness' safe, as it's not very useful}}
\DoxyCodeLine{866     \textcolor{comment}{// to write Not(A<bool>()).  However we cannot completely rule out}}
\DoxyCodeLine{867     \textcolor{comment}{// such a possibility, and it doesn't hurt to be prepared.}}
\DoxyCodeLine{868     *os << \textcolor{stringliteral}{"{}never matches"{}};}
\DoxyCodeLine{869   \}}
\DoxyCodeLine{870 \};}
\DoxyCodeLine{871 }
\DoxyCodeLine{872 \textcolor{comment}{// Implements \_, a matcher that matches any value of any}}
\DoxyCodeLine{873 \textcolor{comment}{// type.  This is a polymorphic matcher, so we need a template type}}
\DoxyCodeLine{874 \textcolor{comment}{// conversion operator to make it appearing as a Matcher<T> for any}}
\DoxyCodeLine{875 \textcolor{comment}{// type T.}}
\DoxyCodeLine{876 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1AnythingMatcher}{AnythingMatcher}} \{}
\DoxyCodeLine{877  \textcolor{keyword}{public}:}
\DoxyCodeLine{878   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{879   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} A<T>(); \}}
\DoxyCodeLine{880 \};}
\DoxyCodeLine{881 }
\DoxyCodeLine{882 \textcolor{comment}{// Implements a matcher that compares a given value with a}}
\DoxyCodeLine{883 \textcolor{comment}{// pre-\/supplied value using one of the ==, <=, <, etc, operators.  The}}
\DoxyCodeLine{884 \textcolor{comment}{// two values being compared don't have to have the same type.}}
\DoxyCodeLine{885 \textcolor{comment}{//}}
\DoxyCodeLine{886 \textcolor{comment}{// The matcher defined here is polymorphic (for example, Eq(5) can be}}
\DoxyCodeLine{887 \textcolor{comment}{// used to match an int, a short, a double, etc).  Therefore we use}}
\DoxyCodeLine{888 \textcolor{comment}{// a template type conversion operator in the implementation.}}
\DoxyCodeLine{889 \textcolor{comment}{//}}
\DoxyCodeLine{890 \textcolor{comment}{// The following template definition assumes that the Rhs parameter is}}
\DoxyCodeLine{891 \textcolor{comment}{// a "{}bare"{} type (i.e. neither 'const T' nor 'T\&').}}
\DoxyCodeLine{892 \textcolor{keyword}{template} <\textcolor{keyword}{typename} D, \textcolor{keyword}{typename} Rhs, \textcolor{keyword}{typename} Op>}
\DoxyCodeLine{893 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase}} \{}
\DoxyCodeLine{894  \textcolor{keyword}{public}:}
\DoxyCodeLine{895   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase}}(\textcolor{keyword}{const} Rhs\& rhs) : rhs\_(rhs) \{\}}
\DoxyCodeLine{896   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Lhs>}
\DoxyCodeLine{897   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<Lhs>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{898     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} Impl<Lhs>(rhs\_));}
\DoxyCodeLine{899   \}}
\DoxyCodeLine{900 }
\DoxyCodeLine{901  \textcolor{keyword}{private}:}
\DoxyCodeLine{902   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Lhs>}
\DoxyCodeLine{903   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<Lhs> \{}
\DoxyCodeLine{904    \textcolor{keyword}{public}:}
\DoxyCodeLine{905     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} Rhs\& rhs) : rhs\_(rhs) \{\}}
\DoxyCodeLine{906     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(}
\DoxyCodeLine{907         Lhs lhs, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{908       \textcolor{keywordflow}{return} Op()(lhs, rhs\_);}
\DoxyCodeLine{909     \}}
\DoxyCodeLine{910     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{911       *os << D::Desc() << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{912       UniversalPrint(rhs\_, os);}
\DoxyCodeLine{913     \}}
\DoxyCodeLine{914     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{915       *os << D::NegatedDesc() <<  \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{916       UniversalPrint(rhs\_, os);}
\DoxyCodeLine{917     \}}
\DoxyCodeLine{918    \textcolor{keyword}{private}:}
\DoxyCodeLine{919     Rhs rhs\_;}
\DoxyCodeLine{920     GTEST\_DISALLOW\_ASSIGN\_(Impl);}
\DoxyCodeLine{921   \};}
\DoxyCodeLine{922   Rhs rhs\_;}
\DoxyCodeLine{923   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase}});}
\DoxyCodeLine{924 \};}
\DoxyCodeLine{925 }
\DoxyCodeLine{926 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{927 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1EqMatcher}{EqMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase}}<EqMatcher<Rhs>, Rhs, AnyEq> \{}
\DoxyCodeLine{928  \textcolor{keyword}{public}:}
\DoxyCodeLine{929   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1EqMatcher}{EqMatcher}}(\textcolor{keyword}{const} Rhs\& rhs)}
\DoxyCodeLine{930       : \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase<EqMatcher<Rhs>}}, Rhs, \mbox{\hyperlink{structtesting_1_1internal_1_1AnyEq}{AnyEq}}>(rhs) \{ \}}
\DoxyCodeLine{931   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is equal to"{}}; \}}
\DoxyCodeLine{932   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NegatedDesc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}isn't equal to"{}}; \}}
\DoxyCodeLine{933 \};}
\DoxyCodeLine{934 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{935 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1NeMatcher}{NeMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase}}<NeMatcher<Rhs>, Rhs, AnyNe> \{}
\DoxyCodeLine{936  \textcolor{keyword}{public}:}
\DoxyCodeLine{937   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1NeMatcher}{NeMatcher}}(\textcolor{keyword}{const} Rhs\& rhs)}
\DoxyCodeLine{938       : \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase<NeMatcher<Rhs>}}, Rhs, \mbox{\hyperlink{structtesting_1_1internal_1_1AnyNe}{AnyNe}}>(rhs) \{ \}}
\DoxyCodeLine{939   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}isn't equal to"{}}; \}}
\DoxyCodeLine{940   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NegatedDesc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is equal to"{}}; \}}
\DoxyCodeLine{941 \};}
\DoxyCodeLine{942 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{943 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1LtMatcher}{LtMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase}}<LtMatcher<Rhs>, Rhs, AnyLt> \{}
\DoxyCodeLine{944  \textcolor{keyword}{public}:}
\DoxyCodeLine{945   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1LtMatcher}{LtMatcher}}(\textcolor{keyword}{const} Rhs\& rhs)}
\DoxyCodeLine{946       : \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase<LtMatcher<Rhs>}}, Rhs, \mbox{\hyperlink{structtesting_1_1internal_1_1AnyLt}{AnyLt}}>(rhs) \{ \}}
\DoxyCodeLine{947   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is <"{}}; \}}
\DoxyCodeLine{948   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NegatedDesc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}isn't <"{}}; \}}
\DoxyCodeLine{949 \};}
\DoxyCodeLine{950 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{951 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1GtMatcher}{GtMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase}}<GtMatcher<Rhs>, Rhs, AnyGt> \{}
\DoxyCodeLine{952  \textcolor{keyword}{public}:}
\DoxyCodeLine{953   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1GtMatcher}{GtMatcher}}(\textcolor{keyword}{const} Rhs\& rhs)}
\DoxyCodeLine{954       : \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase<GtMatcher<Rhs>}}, Rhs, \mbox{\hyperlink{structtesting_1_1internal_1_1AnyGt}{AnyGt}}>(rhs) \{ \}}
\DoxyCodeLine{955   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is >"{}}; \}}
\DoxyCodeLine{956   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NegatedDesc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}isn't >"{}}; \}}
\DoxyCodeLine{957 \};}
\DoxyCodeLine{958 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{959 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1LeMatcher}{LeMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase}}<LeMatcher<Rhs>, Rhs, AnyLe> \{}
\DoxyCodeLine{960  \textcolor{keyword}{public}:}
\DoxyCodeLine{961   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1LeMatcher}{LeMatcher}}(\textcolor{keyword}{const} Rhs\& rhs)}
\DoxyCodeLine{962       : \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase<LeMatcher<Rhs>}}, Rhs, \mbox{\hyperlink{structtesting_1_1internal_1_1AnyLe}{AnyLe}}>(rhs) \{ \}}
\DoxyCodeLine{963   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is <="{}}; \}}
\DoxyCodeLine{964   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NegatedDesc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}isn't <="{}}; \}}
\DoxyCodeLine{965 \};}
\DoxyCodeLine{966 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{967 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1GeMatcher}{GeMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase}}<GeMatcher<Rhs>, Rhs, AnyGe> \{}
\DoxyCodeLine{968  \textcolor{keyword}{public}:}
\DoxyCodeLine{969   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1GeMatcher}{GeMatcher}}(\textcolor{keyword}{const} Rhs\& rhs)}
\DoxyCodeLine{970       : \mbox{\hyperlink{classtesting_1_1internal_1_1ComparisonBase}{ComparisonBase<GeMatcher<Rhs>}}, Rhs, \mbox{\hyperlink{structtesting_1_1internal_1_1AnyGe}{AnyGe}}>(rhs) \{ \}}
\DoxyCodeLine{971   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is >="{}}; \}}
\DoxyCodeLine{972   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* NegatedDesc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}isn't >="{}}; \}}
\DoxyCodeLine{973 \};}
\DoxyCodeLine{974 }
\DoxyCodeLine{975 \textcolor{comment}{// Implements the polymorphic IsNull() matcher, which matches any raw or smart}}
\DoxyCodeLine{976 \textcolor{comment}{// pointer that is NULL.}}
\DoxyCodeLine{977 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1IsNullMatcher}{IsNullMatcher}} \{}
\DoxyCodeLine{978  \textcolor{keyword}{public}:}
\DoxyCodeLine{979   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{980   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} Pointer\& p,}
\DoxyCodeLine{981                        \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{982 \textcolor{preprocessor}{\#if GTEST\_LANG\_CXX11}}
\DoxyCodeLine{983     \textcolor{keywordflow}{return} p == \textcolor{keyword}{nullptr};}
\DoxyCodeLine{984 \textcolor{preprocessor}{\#else  }\textcolor{comment}{// GTEST\_LANG\_CXX11}}
\DoxyCodeLine{985     \textcolor{keywordflow}{return} GetRawPointer(p) == NULL;}
\DoxyCodeLine{986 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_LANG\_CXX11}}
\DoxyCodeLine{987   \}}
\DoxyCodeLine{988 }
\DoxyCodeLine{989   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{ *os << \textcolor{stringliteral}{"{}is NULL"{}}; \}}
\DoxyCodeLine{990   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{991     *os << \textcolor{stringliteral}{"{}isn't NULL"{}};}
\DoxyCodeLine{992   \}}
\DoxyCodeLine{993 \};}
\DoxyCodeLine{994 }
\DoxyCodeLine{995 \textcolor{comment}{// Implements the polymorphic NotNull() matcher, which matches any raw or smart}}
\DoxyCodeLine{996 \textcolor{comment}{// pointer that is not NULL.}}
\DoxyCodeLine{997 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1NotNullMatcher}{NotNullMatcher}} \{}
\DoxyCodeLine{998  \textcolor{keyword}{public}:}
\DoxyCodeLine{999   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{1000   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} Pointer\& p,}
\DoxyCodeLine{1001                        \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1002 \textcolor{preprocessor}{\#if GTEST\_LANG\_CXX11}}
\DoxyCodeLine{1003     \textcolor{keywordflow}{return} p != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{1004 \textcolor{preprocessor}{\#else  }\textcolor{comment}{// GTEST\_LANG\_CXX11}}
\DoxyCodeLine{1005     \textcolor{keywordflow}{return} GetRawPointer(p) != NULL;}
\DoxyCodeLine{1006 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_LANG\_CXX11}}
\DoxyCodeLine{1007   \}}
\DoxyCodeLine{1008 }
\DoxyCodeLine{1009   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{ *os << \textcolor{stringliteral}{"{}isn't NULL"{}}; \}}
\DoxyCodeLine{1010   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1011     *os << \textcolor{stringliteral}{"{}is NULL"{}};}
\DoxyCodeLine{1012   \}}
\DoxyCodeLine{1013 \};}
\DoxyCodeLine{1014 }
\DoxyCodeLine{1015 \textcolor{comment}{// Ref(variable) matches any argument that is a reference to}}
\DoxyCodeLine{1016 \textcolor{comment}{// 'variable'.  This matcher is polymorphic as it can match any}}
\DoxyCodeLine{1017 \textcolor{comment}{// super type of the type of 'variable'.}}
\DoxyCodeLine{1018 \textcolor{comment}{//}}
\DoxyCodeLine{1019 \textcolor{comment}{// The RefMatcher template class implements Ref(variable).  It can}}
\DoxyCodeLine{1020 \textcolor{comment}{// only be instantiated with a reference type.  This prevents a user}}
\DoxyCodeLine{1021 \textcolor{comment}{// from mistakenly using Ref(x) to match a non-\/reference function}}
\DoxyCodeLine{1022 \textcolor{comment}{// argument.  For example, the following will righteously cause a}}
\DoxyCodeLine{1023 \textcolor{comment}{// compiler error:}}
\DoxyCodeLine{1024 \textcolor{comment}{//}}
\DoxyCodeLine{1025 \textcolor{comment}{//   int n;}}
\DoxyCodeLine{1026 \textcolor{comment}{//   Matcher<int> m1 = Ref(n);   // This won't compile.}}
\DoxyCodeLine{1027 \textcolor{comment}{//   Matcher<int\&> m2 = Ref(n);  // This will compile.}}
\DoxyCodeLine{1028 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1029 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1RefMatcher}{RefMatcher}};}
\DoxyCodeLine{1030 }
\DoxyCodeLine{1031 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1032 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1RefMatcher}{RefMatcher}}<T\&> \{}
\DoxyCodeLine{1033   \textcolor{comment}{// Google Mock is a generic framework and thus needs to support}}
\DoxyCodeLine{1034   \textcolor{comment}{// mocking any function types, including those that take non-\/const}}
\DoxyCodeLine{1035   \textcolor{comment}{// reference arguments.  Therefore the template parameter T (and}}
\DoxyCodeLine{1036   \textcolor{comment}{// Super below) can be instantiated to either a const type or a}}
\DoxyCodeLine{1037   \textcolor{comment}{// non-\/const type.}}
\DoxyCodeLine{1038  \textcolor{keyword}{public}:}
\DoxyCodeLine{1039   \textcolor{comment}{// RefMatcher() takes a T\& instead of const T\&, as we want the}}
\DoxyCodeLine{1040   \textcolor{comment}{// compiler to catch using Ref(const\_value) as a matcher for a}}
\DoxyCodeLine{1041   \textcolor{comment}{// non-\/const reference.}}
\DoxyCodeLine{1042   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1RefMatcher}{RefMatcher}}(T\& x) : object\_(x) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1043 }
\DoxyCodeLine{1044   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Super>}
\DoxyCodeLine{1045   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<Super\&>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1046     \textcolor{comment}{// By passing object\_ (type T\&) to Impl(), which expects a Super\&,}}
\DoxyCodeLine{1047     \textcolor{comment}{// we make sure that Super is a super type of T.  In particular,}}
\DoxyCodeLine{1048     \textcolor{comment}{// this catches using Ref(const\_value) as a matcher for a}}
\DoxyCodeLine{1049     \textcolor{comment}{// non-\/const reference, as you cannot implicitly convert a const}}
\DoxyCodeLine{1050     \textcolor{comment}{// reference to a non-\/const reference.}}
\DoxyCodeLine{1051     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} Impl<Super>(object\_));}
\DoxyCodeLine{1052   \}}
\DoxyCodeLine{1053 }
\DoxyCodeLine{1054  \textcolor{keyword}{private}:}
\DoxyCodeLine{1055   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Super>}
\DoxyCodeLine{1056   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<Super\&> \{}
\DoxyCodeLine{1057    \textcolor{keyword}{public}:}
\DoxyCodeLine{1058     \textcolor{keyword}{explicit} Impl(Super\& x) : object\_(x) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1059 }
\DoxyCodeLine{1060     \textcolor{comment}{// MatchAndExplain() takes a Super\& (as opposed to const Super\&)}}
\DoxyCodeLine{1061     \textcolor{comment}{// in order to match the interface MatcherInterface<Super\&>.}}
\DoxyCodeLine{1062     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(}
\DoxyCodeLine{1063         Super\& x, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1064       *listener << \textcolor{stringliteral}{"{}which is located @"{}} << \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&x);}
\DoxyCodeLine{1065       \textcolor{keywordflow}{return} \&x == \&object\_;}
\DoxyCodeLine{1066     \}}
\DoxyCodeLine{1067 }
\DoxyCodeLine{1068     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1069       *os << \textcolor{stringliteral}{"{}references the variable "{}};}
\DoxyCodeLine{1070       \mbox{\hyperlink{classtesting_1_1internal_1_1UniversalPrinter}{UniversalPrinter<Super\&>::Print}}(object\_, os);}
\DoxyCodeLine{1071     \}}
\DoxyCodeLine{1072 }
\DoxyCodeLine{1073     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1074       *os << \textcolor{stringliteral}{"{}does not reference the variable "{}};}
\DoxyCodeLine{1075       \mbox{\hyperlink{classtesting_1_1internal_1_1UniversalPrinter}{UniversalPrinter<Super\&>::Print}}(object\_, os);}
\DoxyCodeLine{1076     \}}
\DoxyCodeLine{1077 }
\DoxyCodeLine{1078    \textcolor{keyword}{private}:}
\DoxyCodeLine{1079     \textcolor{keyword}{const} Super\& object\_;}
\DoxyCodeLine{1080 }
\DoxyCodeLine{1081     GTEST\_DISALLOW\_ASSIGN\_(Impl);}
\DoxyCodeLine{1082   \};}
\DoxyCodeLine{1083 }
\DoxyCodeLine{1084   T\& object\_;}
\DoxyCodeLine{1085 }
\DoxyCodeLine{1086   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1RefMatcher}{RefMatcher}});}
\DoxyCodeLine{1087 \};}
\DoxyCodeLine{1088 }
\DoxyCodeLine{1089 \textcolor{comment}{// Polymorphic helper functions for narrow and wide string matchers.}}
\DoxyCodeLine{1090 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} CaseInsensitiveCStringEquals(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* lhs, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* rhs) \{}
\DoxyCodeLine{1091   \textcolor{keywordflow}{return} String::CaseInsensitiveCStringEquals(lhs, rhs);}
\DoxyCodeLine{1092 \}}
\DoxyCodeLine{1093 }
\DoxyCodeLine{1094 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} CaseInsensitiveCStringEquals(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* lhs,}
\DoxyCodeLine{1095                                          \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* rhs) \{}
\DoxyCodeLine{1096   \textcolor{keywordflow}{return} String::CaseInsensitiveWideCStringEquals(lhs, rhs);}
\DoxyCodeLine{1097 \}}
\DoxyCodeLine{1098 }
\DoxyCodeLine{1099 \textcolor{comment}{// String comparison for narrow or wide strings that can have embedded NUL}}
\DoxyCodeLine{1100 \textcolor{comment}{// characters.}}
\DoxyCodeLine{1101 \textcolor{keyword}{template} <\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{1102 \textcolor{keywordtype}{bool} CaseInsensitiveStringEquals(\textcolor{keyword}{const} StringType\& s1,}
\DoxyCodeLine{1103                                  \textcolor{keyword}{const} StringType\& s2) \{}
\DoxyCodeLine{1104   \textcolor{comment}{// Are the heads equal?}}
\DoxyCodeLine{1105   \textcolor{keywordflow}{if} (!CaseInsensitiveCStringEquals(s1.c\_str(), s2.c\_str())) \{}
\DoxyCodeLine{1106     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1107   \}}
\DoxyCodeLine{1108 }
\DoxyCodeLine{1109   \textcolor{comment}{// Skip the equal heads.}}
\DoxyCodeLine{1110   \textcolor{keyword}{const} \textcolor{keyword}{typename} StringType::value\_type nul = 0;}
\DoxyCodeLine{1111   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} i1 = s1.find(nul), i2 = s2.find(nul);}
\DoxyCodeLine{1112 }
\DoxyCodeLine{1113   \textcolor{comment}{// Are we at the end of either s1 or s2?}}
\DoxyCodeLine{1114   \textcolor{keywordflow}{if} (i1 == StringType::npos || i2 == StringType::npos) \{}
\DoxyCodeLine{1115     \textcolor{keywordflow}{return} i1 == i2;}
\DoxyCodeLine{1116   \}}
\DoxyCodeLine{1117 }
\DoxyCodeLine{1118   \textcolor{comment}{// Are the tails equal?}}
\DoxyCodeLine{1119   \textcolor{keywordflow}{return} CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));}
\DoxyCodeLine{1120 \}}
\DoxyCodeLine{1121 }
\DoxyCodeLine{1122 \textcolor{comment}{// String matchers.}}
\DoxyCodeLine{1123 }
\DoxyCodeLine{1124 \textcolor{comment}{// Implements equality-\/based string matchers like StrEq, StrCaseNe, and etc.}}
\DoxyCodeLine{1125 \textcolor{keyword}{template} <\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{1126 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1StrEqualityMatcher}{StrEqualityMatcher}} \{}
\DoxyCodeLine{1127  \textcolor{keyword}{public}:}
\DoxyCodeLine{1128   \mbox{\hyperlink{classtesting_1_1internal_1_1StrEqualityMatcher}{StrEqualityMatcher}}(\textcolor{keyword}{const} StringType\& str, \textcolor{keywordtype}{bool} expect\_eq,}
\DoxyCodeLine{1129                      \textcolor{keywordtype}{bool} case\_sensitive)}
\DoxyCodeLine{1130       : string\_(str), expect\_eq\_(expect\_eq), case\_sensitive\_(case\_sensitive) \{\}}
\DoxyCodeLine{1131 }
\DoxyCodeLine{1132   \textcolor{comment}{// Accepts pointer types, particularly:}}
\DoxyCodeLine{1133   \textcolor{comment}{//   const char*}}
\DoxyCodeLine{1134   \textcolor{comment}{//   char*}}
\DoxyCodeLine{1135   \textcolor{comment}{//   const wchar\_t*}}
\DoxyCodeLine{1136   \textcolor{comment}{//   wchar\_t*}}
\DoxyCodeLine{1137   \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{1138   \textcolor{keywordtype}{bool} MatchAndExplain(CharType* s, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1139     \textcolor{keywordflow}{if} (s == NULL) \{}
\DoxyCodeLine{1140       \textcolor{keywordflow}{return} !expect\_eq\_;}
\DoxyCodeLine{1141     \}}
\DoxyCodeLine{1142     \textcolor{keywordflow}{return} MatchAndExplain(StringType(s), listener);}
\DoxyCodeLine{1143   \}}
\DoxyCodeLine{1144 }
\DoxyCodeLine{1145   \textcolor{comment}{// Matches anything that can convert to StringType.}}
\DoxyCodeLine{1146   \textcolor{comment}{//}}
\DoxyCodeLine{1147   \textcolor{comment}{// This is a template, not just a plain function with const StringType\&,}}
\DoxyCodeLine{1148   \textcolor{comment}{// because StringPiece has some interfering non-\/explicit constructors.}}
\DoxyCodeLine{1149   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcheeStringType>}
\DoxyCodeLine{1150   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} MatcheeStringType\& s,}
\DoxyCodeLine{1151                        \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1152     \textcolor{keyword}{const} StringType\& s2(s);}
\DoxyCodeLine{1153     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} eq = case\_sensitive\_ ? s2 == string\_ :}
\DoxyCodeLine{1154         CaseInsensitiveStringEquals(s2, string\_);}
\DoxyCodeLine{1155     \textcolor{keywordflow}{return} expect\_eq\_ == eq;}
\DoxyCodeLine{1156   \}}
\DoxyCodeLine{1157 }
\DoxyCodeLine{1158   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1159     DescribeToHelper(expect\_eq\_, os);}
\DoxyCodeLine{1160   \}}
\DoxyCodeLine{1161 }
\DoxyCodeLine{1162   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1163     DescribeToHelper(!expect\_eq\_, os);}
\DoxyCodeLine{1164   \}}
\DoxyCodeLine{1165 }
\DoxyCodeLine{1166  \textcolor{keyword}{private}:}
\DoxyCodeLine{1167   \textcolor{keywordtype}{void} DescribeToHelper(\textcolor{keywordtype}{bool} expect\_eq, ::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1168     *os << (expect\_eq ? \textcolor{stringliteral}{"{}is "{}} : \textcolor{stringliteral}{"{}isn't "{}});}
\DoxyCodeLine{1169     *os << \textcolor{stringliteral}{"{}equal to "{}};}
\DoxyCodeLine{1170     \textcolor{keywordflow}{if} (!case\_sensitive\_) \{}
\DoxyCodeLine{1171       *os << \textcolor{stringliteral}{"{}(ignoring case) "{}};}
\DoxyCodeLine{1172     \}}
\DoxyCodeLine{1173     UniversalPrint(string\_, os);}
\DoxyCodeLine{1174   \}}
\DoxyCodeLine{1175 }
\DoxyCodeLine{1176   \textcolor{keyword}{const} StringType string\_;}
\DoxyCodeLine{1177   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} expect\_eq\_;}
\DoxyCodeLine{1178   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} case\_sensitive\_;}
\DoxyCodeLine{1179 }
\DoxyCodeLine{1180   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1StrEqualityMatcher}{StrEqualityMatcher}});}
\DoxyCodeLine{1181 \};}
\DoxyCodeLine{1182 }
\DoxyCodeLine{1183 \textcolor{comment}{// Implements the polymorphic HasSubstr(substring) matcher, which}}
\DoxyCodeLine{1184 \textcolor{comment}{// can be used as a Matcher<T> as long as T can be converted to a}}
\DoxyCodeLine{1185 \textcolor{comment}{// string.}}
\DoxyCodeLine{1186 \textcolor{keyword}{template} <\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{1187 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1HasSubstrMatcher}{HasSubstrMatcher}} \{}
\DoxyCodeLine{1188  \textcolor{keyword}{public}:}
\DoxyCodeLine{1189   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1HasSubstrMatcher}{HasSubstrMatcher}}(\textcolor{keyword}{const} StringType\& substring)}
\DoxyCodeLine{1190       : substring\_(substring) \{\}}
\DoxyCodeLine{1191 }
\DoxyCodeLine{1192   \textcolor{comment}{// Accepts pointer types, particularly:}}
\DoxyCodeLine{1193   \textcolor{comment}{//   const char*}}
\DoxyCodeLine{1194   \textcolor{comment}{//   char*}}
\DoxyCodeLine{1195   \textcolor{comment}{//   const wchar\_t*}}
\DoxyCodeLine{1196   \textcolor{comment}{//   wchar\_t*}}
\DoxyCodeLine{1197   \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{1198   \textcolor{keywordtype}{bool} MatchAndExplain(CharType* s, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1199     \textcolor{keywordflow}{return} s != NULL \&\& MatchAndExplain(StringType(s), listener);}
\DoxyCodeLine{1200   \}}
\DoxyCodeLine{1201 }
\DoxyCodeLine{1202   \textcolor{comment}{// Matches anything that can convert to StringType.}}
\DoxyCodeLine{1203   \textcolor{comment}{//}}
\DoxyCodeLine{1204   \textcolor{comment}{// This is a template, not just a plain function with const StringType\&,}}
\DoxyCodeLine{1205   \textcolor{comment}{// because StringPiece has some interfering non-\/explicit constructors.}}
\DoxyCodeLine{1206   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcheeStringType>}
\DoxyCodeLine{1207   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} MatcheeStringType\& s,}
\DoxyCodeLine{1208                        \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1209     \textcolor{keyword}{const} StringType\& s2(s);}
\DoxyCodeLine{1210     \textcolor{keywordflow}{return} s2.find(substring\_) != StringType::npos;}
\DoxyCodeLine{1211   \}}
\DoxyCodeLine{1212 }
\DoxyCodeLine{1213   \textcolor{comment}{// Describes what this matcher matches.}}
\DoxyCodeLine{1214   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1215     *os << \textcolor{stringliteral}{"{}has substring "{}};}
\DoxyCodeLine{1216     UniversalPrint(substring\_, os);}
\DoxyCodeLine{1217   \}}
\DoxyCodeLine{1218 }
\DoxyCodeLine{1219   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1220     *os << \textcolor{stringliteral}{"{}has no substring "{}};}
\DoxyCodeLine{1221     UniversalPrint(substring\_, os);}
\DoxyCodeLine{1222   \}}
\DoxyCodeLine{1223 }
\DoxyCodeLine{1224  \textcolor{keyword}{private}:}
\DoxyCodeLine{1225   \textcolor{keyword}{const} StringType substring\_;}
\DoxyCodeLine{1226 }
\DoxyCodeLine{1227   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1HasSubstrMatcher}{HasSubstrMatcher}});}
\DoxyCodeLine{1228 \};}
\DoxyCodeLine{1229 }
\DoxyCodeLine{1230 \textcolor{comment}{// Implements the polymorphic StartsWith(substring) matcher, which}}
\DoxyCodeLine{1231 \textcolor{comment}{// can be used as a Matcher<T> as long as T can be converted to a}}
\DoxyCodeLine{1232 \textcolor{comment}{// string.}}
\DoxyCodeLine{1233 \textcolor{keyword}{template} <\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{1234 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1StartsWithMatcher}{StartsWithMatcher}} \{}
\DoxyCodeLine{1235  \textcolor{keyword}{public}:}
\DoxyCodeLine{1236   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1StartsWithMatcher}{StartsWithMatcher}}(\textcolor{keyword}{const} StringType\& prefix) : prefix\_(prefix) \{}
\DoxyCodeLine{1237   \}}
\DoxyCodeLine{1238 }
\DoxyCodeLine{1239   \textcolor{comment}{// Accepts pointer types, particularly:}}
\DoxyCodeLine{1240   \textcolor{comment}{//   const char*}}
\DoxyCodeLine{1241   \textcolor{comment}{//   char*}}
\DoxyCodeLine{1242   \textcolor{comment}{//   const wchar\_t*}}
\DoxyCodeLine{1243   \textcolor{comment}{//   wchar\_t*}}
\DoxyCodeLine{1244   \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{1245   \textcolor{keywordtype}{bool} MatchAndExplain(CharType* s, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1246     \textcolor{keywordflow}{return} s != NULL \&\& MatchAndExplain(StringType(s), listener);}
\DoxyCodeLine{1247   \}}
\DoxyCodeLine{1248 }
\DoxyCodeLine{1249   \textcolor{comment}{// Matches anything that can convert to StringType.}}
\DoxyCodeLine{1250   \textcolor{comment}{//}}
\DoxyCodeLine{1251   \textcolor{comment}{// This is a template, not just a plain function with const StringType\&,}}
\DoxyCodeLine{1252   \textcolor{comment}{// because StringPiece has some interfering non-\/explicit constructors.}}
\DoxyCodeLine{1253   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcheeStringType>}
\DoxyCodeLine{1254   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} MatcheeStringType\& s,}
\DoxyCodeLine{1255                        \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1256     \textcolor{keyword}{const} StringType\& s2(s);}
\DoxyCodeLine{1257     \textcolor{keywordflow}{return} s2.length() >= prefix\_.length() \&\&}
\DoxyCodeLine{1258         s2.substr(0, prefix\_.length()) == prefix\_;}
\DoxyCodeLine{1259   \}}
\DoxyCodeLine{1260 }
\DoxyCodeLine{1261   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1262     *os << \textcolor{stringliteral}{"{}starts with "{}};}
\DoxyCodeLine{1263     UniversalPrint(prefix\_, os);}
\DoxyCodeLine{1264   \}}
\DoxyCodeLine{1265 }
\DoxyCodeLine{1266   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1267     *os << \textcolor{stringliteral}{"{}doesn't start with "{}};}
\DoxyCodeLine{1268     UniversalPrint(prefix\_, os);}
\DoxyCodeLine{1269   \}}
\DoxyCodeLine{1270 }
\DoxyCodeLine{1271  \textcolor{keyword}{private}:}
\DoxyCodeLine{1272   \textcolor{keyword}{const} StringType prefix\_;}
\DoxyCodeLine{1273 }
\DoxyCodeLine{1274   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1StartsWithMatcher}{StartsWithMatcher}});}
\DoxyCodeLine{1275 \};}
\DoxyCodeLine{1276 }
\DoxyCodeLine{1277 \textcolor{comment}{// Implements the polymorphic EndsWith(substring) matcher, which}}
\DoxyCodeLine{1278 \textcolor{comment}{// can be used as a Matcher<T> as long as T can be converted to a}}
\DoxyCodeLine{1279 \textcolor{comment}{// string.}}
\DoxyCodeLine{1280 \textcolor{keyword}{template} <\textcolor{keyword}{typename} StringType>}
\DoxyCodeLine{1281 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1EndsWithMatcher}{EndsWithMatcher}} \{}
\DoxyCodeLine{1282  \textcolor{keyword}{public}:}
\DoxyCodeLine{1283   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1EndsWithMatcher}{EndsWithMatcher}}(\textcolor{keyword}{const} StringType\& suffix) : suffix\_(suffix) \{\}}
\DoxyCodeLine{1284 }
\DoxyCodeLine{1285   \textcolor{comment}{// Accepts pointer types, particularly:}}
\DoxyCodeLine{1286   \textcolor{comment}{//   const char*}}
\DoxyCodeLine{1287   \textcolor{comment}{//   char*}}
\DoxyCodeLine{1288   \textcolor{comment}{//   const wchar\_t*}}
\DoxyCodeLine{1289   \textcolor{comment}{//   wchar\_t*}}
\DoxyCodeLine{1290   \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{1291   \textcolor{keywordtype}{bool} MatchAndExplain(CharType* s, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1292     \textcolor{keywordflow}{return} s != NULL \&\& MatchAndExplain(StringType(s), listener);}
\DoxyCodeLine{1293   \}}
\DoxyCodeLine{1294 }
\DoxyCodeLine{1295   \textcolor{comment}{// Matches anything that can convert to StringType.}}
\DoxyCodeLine{1296   \textcolor{comment}{//}}
\DoxyCodeLine{1297   \textcolor{comment}{// This is a template, not just a plain function with const StringType\&,}}
\DoxyCodeLine{1298   \textcolor{comment}{// because StringPiece has some interfering non-\/explicit constructors.}}
\DoxyCodeLine{1299   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcheeStringType>}
\DoxyCodeLine{1300   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} MatcheeStringType\& s,}
\DoxyCodeLine{1301                        \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1302     \textcolor{keyword}{const} StringType\& s2(s);}
\DoxyCodeLine{1303     \textcolor{keywordflow}{return} s2.length() >= suffix\_.length() \&\&}
\DoxyCodeLine{1304         s2.substr(s2.length() -\/ suffix\_.length()) == suffix\_;}
\DoxyCodeLine{1305   \}}
\DoxyCodeLine{1306 }
\DoxyCodeLine{1307   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1308     *os << \textcolor{stringliteral}{"{}ends with "{}};}
\DoxyCodeLine{1309     UniversalPrint(suffix\_, os);}
\DoxyCodeLine{1310   \}}
\DoxyCodeLine{1311 }
\DoxyCodeLine{1312   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1313     *os << \textcolor{stringliteral}{"{}doesn't end with "{}};}
\DoxyCodeLine{1314     UniversalPrint(suffix\_, os);}
\DoxyCodeLine{1315   \}}
\DoxyCodeLine{1316 }
\DoxyCodeLine{1317  \textcolor{keyword}{private}:}
\DoxyCodeLine{1318   \textcolor{keyword}{const} StringType suffix\_;}
\DoxyCodeLine{1319 }
\DoxyCodeLine{1320   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1EndsWithMatcher}{EndsWithMatcher}});}
\DoxyCodeLine{1321 \};}
\DoxyCodeLine{1322 }
\DoxyCodeLine{1323 \textcolor{comment}{// Implements polymorphic matchers MatchesRegex(regex) and}}
\DoxyCodeLine{1324 \textcolor{comment}{// ContainsRegex(regex), which can be used as a Matcher<T> as long as}}
\DoxyCodeLine{1325 \textcolor{comment}{// T can be converted to a string.}}
\DoxyCodeLine{1326 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1MatchesRegexMatcher}{MatchesRegexMatcher}} \{}
\DoxyCodeLine{1327  \textcolor{keyword}{public}:}
\DoxyCodeLine{1328   \mbox{\hyperlink{classtesting_1_1internal_1_1MatchesRegexMatcher}{MatchesRegexMatcher}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1RE}{RE}}* regex, \textcolor{keywordtype}{bool} full\_match)}
\DoxyCodeLine{1329       : regex\_(regex), full\_match\_(full\_match) \{\}}
\DoxyCodeLine{1330 }
\DoxyCodeLine{1331   \textcolor{comment}{// Accepts pointer types, particularly:}}
\DoxyCodeLine{1332   \textcolor{comment}{//   const char*}}
\DoxyCodeLine{1333   \textcolor{comment}{//   char*}}
\DoxyCodeLine{1334   \textcolor{comment}{//   const wchar\_t*}}
\DoxyCodeLine{1335   \textcolor{comment}{//   wchar\_t*}}
\DoxyCodeLine{1336   \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharType>}
\DoxyCodeLine{1337   \textcolor{keywordtype}{bool} MatchAndExplain(CharType* s, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1338     \textcolor{keywordflow}{return} s != NULL \&\& MatchAndExplain(internal::string(s), listener);}
\DoxyCodeLine{1339   \}}
\DoxyCodeLine{1340 }
\DoxyCodeLine{1341   \textcolor{comment}{// Matches anything that can convert to internal::string.}}
\DoxyCodeLine{1342   \textcolor{comment}{//}}
\DoxyCodeLine{1343   \textcolor{comment}{// This is a template, not just a plain function with const internal::string\&,}}
\DoxyCodeLine{1344   \textcolor{comment}{// because StringPiece has some interfering non-\/explicit constructors.}}
\DoxyCodeLine{1345   \textcolor{keyword}{template} <\textcolor{keyword}{class} MatcheeStringType>}
\DoxyCodeLine{1346   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} MatcheeStringType\& s,}
\DoxyCodeLine{1347                        \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1348     \textcolor{keyword}{const} internal::string\& s2(s);}
\DoxyCodeLine{1349     \textcolor{keywordflow}{return} full\_match\_ ? RE::FullMatch(s2, *regex\_) :}
\DoxyCodeLine{1350         RE::PartialMatch(s2, *regex\_);}
\DoxyCodeLine{1351   \}}
\DoxyCodeLine{1352 }
\DoxyCodeLine{1353   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1354     *os << (full\_match\_ ? \textcolor{stringliteral}{"{}matches"{}} : \textcolor{stringliteral}{"{}contains"{}})}
\DoxyCodeLine{1355         << \textcolor{stringliteral}{"{} regular expression "{}};}
\DoxyCodeLine{1356     \mbox{\hyperlink{classtesting_1_1internal_1_1UniversalPrinter}{UniversalPrinter<internal::string>::Print}}(regex\_-\/>pattern(), os);}
\DoxyCodeLine{1357   \}}
\DoxyCodeLine{1358 }
\DoxyCodeLine{1359   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1360     *os << \textcolor{stringliteral}{"{}doesn't "{}} << (full\_match\_ ? \textcolor{stringliteral}{"{}match"{}} : \textcolor{stringliteral}{"{}contain"{}})}
\DoxyCodeLine{1361         << \textcolor{stringliteral}{"{} regular expression "{}};}
\DoxyCodeLine{1362     \mbox{\hyperlink{classtesting_1_1internal_1_1UniversalPrinter}{UniversalPrinter<internal::string>::Print}}(regex\_-\/>pattern(), os);}
\DoxyCodeLine{1363   \}}
\DoxyCodeLine{1364 }
\DoxyCodeLine{1365  \textcolor{keyword}{private}:}
\DoxyCodeLine{1366   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1linked__ptr}{internal::linked\_ptr<const RE>}} regex\_;}
\DoxyCodeLine{1367   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} full\_match\_;}
\DoxyCodeLine{1368 }
\DoxyCodeLine{1369   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1MatchesRegexMatcher}{MatchesRegexMatcher}});}
\DoxyCodeLine{1370 \};}
\DoxyCodeLine{1371 }
\DoxyCodeLine{1372 \textcolor{comment}{// Implements a matcher that compares the two fields of a 2-\/tuple}}
\DoxyCodeLine{1373 \textcolor{comment}{// using one of the ==, <=, <, etc, operators.  The two fields being}}
\DoxyCodeLine{1374 \textcolor{comment}{// compared don't have to have the same type.}}
\DoxyCodeLine{1375 \textcolor{comment}{//}}
\DoxyCodeLine{1376 \textcolor{comment}{// The matcher defined here is polymorphic (for example, Eq() can be}}
\DoxyCodeLine{1377 \textcolor{comment}{// used to match a tuple<int, short>, a tuple<const long\&, double>,}}
\DoxyCodeLine{1378 \textcolor{comment}{// etc).  Therefore we use a template type conversion operator in the}}
\DoxyCodeLine{1379 \textcolor{comment}{// implementation.}}
\DoxyCodeLine{1380 \textcolor{keyword}{template} <\textcolor{keyword}{typename} D, \textcolor{keyword}{typename} Op>}
\DoxyCodeLine{1381 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1PairMatchBase}{PairMatchBase}} \{}
\DoxyCodeLine{1382  \textcolor{keyword}{public}:}
\DoxyCodeLine{1383   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1384   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher< ::testing::tuple<T1, T2>}} >() \textcolor{keyword}{const} \{}
\DoxyCodeLine{1385     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} Impl< ::testing::tuple<T1, T2> >);}
\DoxyCodeLine{1386   \}}
\DoxyCodeLine{1387   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1388   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<const ::testing::tuple<T1, T2>}}\&>() \textcolor{keyword}{const} \{}
\DoxyCodeLine{1389     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} Impl<const ::testing::tuple<T1, T2>\&>);}
\DoxyCodeLine{1390   \}}
\DoxyCodeLine{1391 }
\DoxyCodeLine{1392  \textcolor{keyword}{private}:}
\DoxyCodeLine{1393   static ::std::ostream\& GetDesc(::std::ostream\& os) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1394     \textcolor{keywordflow}{return} os << D::Desc();}
\DoxyCodeLine{1395   \}}
\DoxyCodeLine{1396 }
\DoxyCodeLine{1397   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{1398   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<Tuple> \{}
\DoxyCodeLine{1399    \textcolor{keyword}{public}:}
\DoxyCodeLine{1400     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(}
\DoxyCodeLine{1401         Tuple args,}
\DoxyCodeLine{1402         \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1403       \textcolor{keywordflow}{return} Op()(::testing::get<0>(args), ::testing::get<1>(args));}
\DoxyCodeLine{1404     \}}
\DoxyCodeLine{1405     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1406       *os << \textcolor{stringliteral}{"{}are "{}} << GetDesc;}
\DoxyCodeLine{1407     \}}
\DoxyCodeLine{1408     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1409       *os << \textcolor{stringliteral}{"{}aren't "{}} << GetDesc;}
\DoxyCodeLine{1410     \}}
\DoxyCodeLine{1411   \};}
\DoxyCodeLine{1412 \};}
\DoxyCodeLine{1413 }
\DoxyCodeLine{1414 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1Eq2Matcher}{Eq2Matcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1PairMatchBase}{PairMatchBase}}<Eq2Matcher, AnyEq> \{}
\DoxyCodeLine{1415  \textcolor{keyword}{public}:}
\DoxyCodeLine{1416   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}an equal pair"{}}; \}}
\DoxyCodeLine{1417 \};}
\DoxyCodeLine{1418 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1Ne2Matcher}{Ne2Matcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1PairMatchBase}{PairMatchBase}}<Ne2Matcher, AnyNe> \{}
\DoxyCodeLine{1419  \textcolor{keyword}{public}:}
\DoxyCodeLine{1420   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}an unequal pair"{}}; \}}
\DoxyCodeLine{1421 \};}
\DoxyCodeLine{1422 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1Lt2Matcher}{Lt2Matcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1PairMatchBase}{PairMatchBase}}<Lt2Matcher, AnyLt> \{}
\DoxyCodeLine{1423  \textcolor{keyword}{public}:}
\DoxyCodeLine{1424   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}a pair where the first < the second"{}}; \}}
\DoxyCodeLine{1425 \};}
\DoxyCodeLine{1426 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1Gt2Matcher}{Gt2Matcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1PairMatchBase}{PairMatchBase}}<Gt2Matcher, AnyGt> \{}
\DoxyCodeLine{1427  \textcolor{keyword}{public}:}
\DoxyCodeLine{1428   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}a pair where the first > the second"{}}; \}}
\DoxyCodeLine{1429 \};}
\DoxyCodeLine{1430 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1Le2Matcher}{Le2Matcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1PairMatchBase}{PairMatchBase}}<Le2Matcher, AnyLe> \{}
\DoxyCodeLine{1431  \textcolor{keyword}{public}:}
\DoxyCodeLine{1432   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}a pair where the first <= the second"{}}; \}}
\DoxyCodeLine{1433 \};}
\DoxyCodeLine{1434 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1Ge2Matcher}{Ge2Matcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1PairMatchBase}{PairMatchBase}}<Ge2Matcher, AnyGe> \{}
\DoxyCodeLine{1435  \textcolor{keyword}{public}:}
\DoxyCodeLine{1436   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* Desc() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}a pair where the first >= the second"{}}; \}}
\DoxyCodeLine{1437 \};}
\DoxyCodeLine{1438 }
\DoxyCodeLine{1439 \textcolor{comment}{// Implements the Not(...) matcher for a particular argument type T.}}
\DoxyCodeLine{1440 \textcolor{comment}{// We do not nest it inside the NotMatcher class template, as that}}
\DoxyCodeLine{1441 \textcolor{comment}{// will prevent different instantiations of NotMatcher from sharing}}
\DoxyCodeLine{1442 \textcolor{comment}{// the same NotMatcherImpl<T> class.}}
\DoxyCodeLine{1443 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1444 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1NotMatcherImpl}{NotMatcherImpl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<T> \{}
\DoxyCodeLine{1445  \textcolor{keyword}{public}:}
\DoxyCodeLine{1446   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1NotMatcherImpl}{NotMatcherImpl}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}\& matcher)}
\DoxyCodeLine{1447       : matcher\_(matcher) \{\}}
\DoxyCodeLine{1448 }
\DoxyCodeLine{1449   \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(T x, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1450     \textcolor{keywordflow}{return} !matcher\_.MatchAndExplain(x, listener);}
\DoxyCodeLine{1451   \}}
\DoxyCodeLine{1452 }
\DoxyCodeLine{1453   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1454     matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{1455   \}}
\DoxyCodeLine{1456 }
\DoxyCodeLine{1457   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1458     matcher\_.DescribeTo(os);}
\DoxyCodeLine{1459   \}}
\DoxyCodeLine{1460 }
\DoxyCodeLine{1461  \textcolor{keyword}{private}:}
\DoxyCodeLine{1462   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} matcher\_;}
\DoxyCodeLine{1463 }
\DoxyCodeLine{1464   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1NotMatcherImpl}{NotMatcherImpl}});}
\DoxyCodeLine{1465 \};}
\DoxyCodeLine{1466 }
\DoxyCodeLine{1467 \textcolor{comment}{// Implements the Not(m) matcher, which matches a value that doesn't}}
\DoxyCodeLine{1468 \textcolor{comment}{// match matcher m.}}
\DoxyCodeLine{1469 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{1470 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1NotMatcher}{NotMatcher}} \{}
\DoxyCodeLine{1471  \textcolor{keyword}{public}:}
\DoxyCodeLine{1472   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1NotMatcher}{NotMatcher}}(InnerMatcher matcher) : matcher\_(matcher) \{\}}
\DoxyCodeLine{1473 }
\DoxyCodeLine{1474   \textcolor{comment}{// This template type conversion operator allows Not(m) to be used}}
\DoxyCodeLine{1475   \textcolor{comment}{// to match any type m can match.}}
\DoxyCodeLine{1476   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1477   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1478     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1NotMatcherImpl}{NotMatcherImpl<T>}}(SafeMatcherCast<T>(matcher\_)));}
\DoxyCodeLine{1479   \}}
\DoxyCodeLine{1480 }
\DoxyCodeLine{1481  \textcolor{keyword}{private}:}
\DoxyCodeLine{1482   InnerMatcher matcher\_;}
\DoxyCodeLine{1483 }
\DoxyCodeLine{1484   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1NotMatcher}{NotMatcher}});}
\DoxyCodeLine{1485 \};}
\DoxyCodeLine{1486 }
\DoxyCodeLine{1487 \textcolor{comment}{// Implements the AllOf(m1, m2) matcher for a particular argument type}}
\DoxyCodeLine{1488 \textcolor{comment}{// T. We do not nest it inside the BothOfMatcher class template, as}}
\DoxyCodeLine{1489 \textcolor{comment}{// that will prevent different instantiations of BothOfMatcher from}}
\DoxyCodeLine{1490 \textcolor{comment}{// sharing the same BothOfMatcherImpl<T> class.}}
\DoxyCodeLine{1491 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1492 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1BothOfMatcherImpl}{BothOfMatcherImpl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<T> \{}
\DoxyCodeLine{1493  \textcolor{keyword}{public}:}
\DoxyCodeLine{1494   \mbox{\hyperlink{classtesting_1_1internal_1_1BothOfMatcherImpl}{BothOfMatcherImpl}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}\& matcher1, \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}\& matcher2)}
\DoxyCodeLine{1495       : matcher1\_(matcher1), matcher2\_(matcher2) \{\}}
\DoxyCodeLine{1496 }
\DoxyCodeLine{1497   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1498     *os << \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{1499     matcher1\_.DescribeTo(os);}
\DoxyCodeLine{1500     *os << \textcolor{stringliteral}{"{}) and ("{}};}
\DoxyCodeLine{1501     matcher2\_.DescribeTo(os);}
\DoxyCodeLine{1502     *os << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1503   \}}
\DoxyCodeLine{1504 }
\DoxyCodeLine{1505   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1506     *os << \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{1507     matcher1\_.DescribeNegationTo(os);}
\DoxyCodeLine{1508     *os << \textcolor{stringliteral}{"{}) or ("{}};}
\DoxyCodeLine{1509     matcher2\_.DescribeNegationTo(os);}
\DoxyCodeLine{1510     *os << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1511   \}}
\DoxyCodeLine{1512 }
\DoxyCodeLine{1513   \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(T x, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1514     \textcolor{comment}{// If either matcher1\_ or matcher2\_ doesn't match x, we only need}}
\DoxyCodeLine{1515     \textcolor{comment}{// to explain why one of them fails.}}
\DoxyCodeLine{1516     \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} listener1;}
\DoxyCodeLine{1517     \textcolor{keywordflow}{if} (!matcher1\_.MatchAndExplain(x, \&listener1)) \{}
\DoxyCodeLine{1518       *listener << listener1.str();}
\DoxyCodeLine{1519       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1520     \}}
\DoxyCodeLine{1521 }
\DoxyCodeLine{1522     \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} listener2;}
\DoxyCodeLine{1523     \textcolor{keywordflow}{if} (!matcher2\_.MatchAndExplain(x, \&listener2)) \{}
\DoxyCodeLine{1524       *listener << listener2.str();}
\DoxyCodeLine{1525       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1526     \}}
\DoxyCodeLine{1527 }
\DoxyCodeLine{1528     \textcolor{comment}{// Otherwise we need to explain why *both* of them match.}}
\DoxyCodeLine{1529     \textcolor{keyword}{const} internal::string s1 = listener1.str();}
\DoxyCodeLine{1530     \textcolor{keyword}{const} internal::string s2 = listener2.str();}
\DoxyCodeLine{1531 }
\DoxyCodeLine{1532     \textcolor{keywordflow}{if} (s1 == \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{1533       *listener << s2;}
\DoxyCodeLine{1534     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1535       *listener << s1;}
\DoxyCodeLine{1536       \textcolor{keywordflow}{if} (s2 != \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{1537         *listener << \textcolor{stringliteral}{"{}, and "{}} << s2;}
\DoxyCodeLine{1538       \}}
\DoxyCodeLine{1539     \}}
\DoxyCodeLine{1540     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1541   \}}
\DoxyCodeLine{1542 }
\DoxyCodeLine{1543  \textcolor{keyword}{private}:}
\DoxyCodeLine{1544   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} matcher1\_;}
\DoxyCodeLine{1545   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} matcher2\_;}
\DoxyCodeLine{1546 }
\DoxyCodeLine{1547   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1BothOfMatcherImpl}{BothOfMatcherImpl}});}
\DoxyCodeLine{1548 \};}
\DoxyCodeLine{1549 }
\DoxyCodeLine{1550 \textcolor{preprocessor}{\#if GTEST\_LANG\_CXX11}}
\DoxyCodeLine{1551 \textcolor{comment}{// MatcherList provides mechanisms for storing a variable number of matchers in}}
\DoxyCodeLine{1552 \textcolor{comment}{// a list structure (ListType) and creating a combining matcher from such a}}
\DoxyCodeLine{1553 \textcolor{comment}{// list.}}
\DoxyCodeLine{1554 \textcolor{comment}{// The template is defined recursively using the following template paramters:}}
\DoxyCodeLine{1555 \textcolor{comment}{//   * kSize is the length of the MatcherList.}}
\DoxyCodeLine{1556 \textcolor{comment}{//   * Head is the type of the first matcher of the list.}}
\DoxyCodeLine{1557 \textcolor{comment}{//   * Tail denotes the types of the remaining matchers of the list.}}
\DoxyCodeLine{1558 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} kSize, \textcolor{keyword}{typename} Head, \textcolor{keyword}{typename}... Tail>}
\DoxyCodeLine{1559 \textcolor{keyword}{struct }MatcherList \{}
\DoxyCodeLine{1560   \textcolor{keyword}{typedef} MatcherList<kSize -\/ 1, Tail...> MatcherListTail;}
\DoxyCodeLine{1561   typedef ::std::pair<Head, typename MatcherListTail::ListType> ListType;}
\DoxyCodeLine{1562 }
\DoxyCodeLine{1563   \textcolor{comment}{// BuildList stores variadic type values in a nested pair structure.}}
\DoxyCodeLine{1564   \textcolor{comment}{// Example:}}
\DoxyCodeLine{1565   \textcolor{comment}{// MatcherList<3, int, string, float>::BuildList(5, "{}foo"{}, 2.0) will return}}
\DoxyCodeLine{1566   \textcolor{comment}{// the corresponding result of type pair<int, pair<string, float>>.}}
\DoxyCodeLine{1567   \textcolor{keyword}{static} ListType BuildList(\textcolor{keyword}{const} Head\& matcher, \textcolor{keyword}{const} Tail\&... tail) \{}
\DoxyCodeLine{1568     \textcolor{keywordflow}{return} ListType(matcher, MatcherListTail::BuildList(tail...));}
\DoxyCodeLine{1569   \}}
\DoxyCodeLine{1570 }
\DoxyCodeLine{1571   \textcolor{comment}{// CreateMatcher<T> creates a Matcher<T> from a given list of matchers (built}}
\DoxyCodeLine{1572   \textcolor{comment}{// by BuildList()). CombiningMatcher<T> is used to combine the matchers of the}}
\DoxyCodeLine{1573   \textcolor{comment}{// list. CombiningMatcher<T> must implement MatcherInterface<T> and have a}}
\DoxyCodeLine{1574   \textcolor{comment}{// constructor taking two Matcher<T>s as input.}}
\DoxyCodeLine{1575   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{template} <\textcolor{keyword}{typename} \textcolor{comment}{/* T */}> \textcolor{keyword}{class }CombiningMatcher>}
\DoxyCodeLine{1576   static \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher}}<T> CreateMatcher(const ListType\& matchers) \{}
\DoxyCodeLine{1577     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}(\textcolor{keyword}{new} CombiningMatcher<T>(}
\DoxyCodeLine{1578         SafeMatcherCast<T>(matchers.first),}
\DoxyCodeLine{1579         MatcherListTail::template CreateMatcher<T, CombiningMatcher>(}
\DoxyCodeLine{1580             matchers.second)));}
\DoxyCodeLine{1581   \}}
\DoxyCodeLine{1582 \};}
\DoxyCodeLine{1583 }
\DoxyCodeLine{1584 \textcolor{comment}{// The following defines the base case for the recursive definition of}}
\DoxyCodeLine{1585 \textcolor{comment}{// MatcherList.}}
\DoxyCodeLine{1586 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Matcher1, \textcolor{keyword}{typename} Matcher2>}
\DoxyCodeLine{1587 \textcolor{keyword}{struct }MatcherList<2, Matcher1, Matcher2> \{}
\DoxyCodeLine{1588   typedef ::std::pair<Matcher1, Matcher2> ListType;}
\DoxyCodeLine{1589 }
\DoxyCodeLine{1590   \textcolor{keyword}{static} ListType BuildList(\textcolor{keyword}{const} Matcher1\& matcher1,}
\DoxyCodeLine{1591                             \textcolor{keyword}{const} Matcher2\& matcher2) \{}
\DoxyCodeLine{1592     return ::std::pair<Matcher1, Matcher2>(matcher1, matcher2);}
\DoxyCodeLine{1593   \}}
\DoxyCodeLine{1594 }
\DoxyCodeLine{1595   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{template} <\textcolor{keyword}{typename} \textcolor{comment}{/* T */}> \textcolor{keyword}{class }CombiningMatcher>}
\DoxyCodeLine{1596   static Matcher<T> CreateMatcher(const ListType\& matchers) \{}
\DoxyCodeLine{1597     \textcolor{keywordflow}{return} Matcher<T>(\textcolor{keyword}{new} CombiningMatcher<T>(}
\DoxyCodeLine{1598         SafeMatcherCast<T>(matchers.first),}
\DoxyCodeLine{1599         SafeMatcherCast<T>(matchers.second)));}
\DoxyCodeLine{1600   \}}
\DoxyCodeLine{1601 \};}
\DoxyCodeLine{1602 }
\DoxyCodeLine{1603 \textcolor{comment}{// VariadicMatcher is used for the variadic implementation of}}
\DoxyCodeLine{1604 \textcolor{comment}{// AllOf(m\_1, m\_2, ...) and AnyOf(m\_1, m\_2, ...).}}
\DoxyCodeLine{1605 \textcolor{comment}{// CombiningMatcher<T> is used to recursively combine the provided matchers}}
\DoxyCodeLine{1606 \textcolor{comment}{// (of type Args...).}}
\DoxyCodeLine{1607 \textcolor{keyword}{template} <\textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }CombiningMatcher, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1608 \textcolor{keyword}{class }VariadicMatcher \{}
\DoxyCodeLine{1609  \textcolor{keyword}{public}:}
\DoxyCodeLine{1610   VariadicMatcher(\textcolor{keyword}{const} Args\&... matchers)  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1611       : matchers\_(MatcherListType::BuildList(matchers...)) \{\}}
\DoxyCodeLine{1612 }
\DoxyCodeLine{1613   \textcolor{comment}{// This template type conversion operator allows an}}
\DoxyCodeLine{1614   \textcolor{comment}{// VariadicMatcher<Matcher1, Matcher2...> object to match any type that}}
\DoxyCodeLine{1615   \textcolor{comment}{// all of the provided matchers (Matcher1, Matcher2, ...) can match.}}
\DoxyCodeLine{1616   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1617   \textcolor{keyword}{operator} Matcher<T>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1618     \textcolor{keywordflow}{return} MatcherListType::template CreateMatcher<T, CombiningMatcher>(}
\DoxyCodeLine{1619         matchers\_);}
\DoxyCodeLine{1620   \}}
\DoxyCodeLine{1621 }
\DoxyCodeLine{1622  \textcolor{keyword}{private}:}
\DoxyCodeLine{1623   \textcolor{keyword}{typedef} MatcherList<\textcolor{keyword}{sizeof}...(Args), Args...> MatcherListType;}
\DoxyCodeLine{1624 }
\DoxyCodeLine{1625   \textcolor{keyword}{const} \textcolor{keyword}{typename} MatcherListType::ListType matchers\_;}
\DoxyCodeLine{1626 }
\DoxyCodeLine{1627   GTEST\_DISALLOW\_ASSIGN\_(VariadicMatcher);}
\DoxyCodeLine{1628 \};}
\DoxyCodeLine{1629 }
\DoxyCodeLine{1630 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1631 \textcolor{keyword}{using} AllOfMatcher = VariadicMatcher<BothOfMatcherImpl, Args...>;}
\DoxyCodeLine{1632 }
\DoxyCodeLine{1633 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_LANG\_CXX11}}
\DoxyCodeLine{1634 }
\DoxyCodeLine{1635 \textcolor{comment}{// Used for implementing the AllOf(m\_1, ..., m\_n) matcher, which}}
\DoxyCodeLine{1636 \textcolor{comment}{// matches a value that matches all of the matchers m\_1, ..., and m\_n.}}
\DoxyCodeLine{1637 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Matcher1, \textcolor{keyword}{typename} Matcher2>}
\DoxyCodeLine{1638 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1BothOfMatcher}{BothOfMatcher}} \{}
\DoxyCodeLine{1639  \textcolor{keyword}{public}:}
\DoxyCodeLine{1640   \mbox{\hyperlink{classtesting_1_1internal_1_1BothOfMatcher}{BothOfMatcher}}(Matcher1 matcher1, Matcher2 matcher2)}
\DoxyCodeLine{1641       : matcher1\_(matcher1), matcher2\_(matcher2) \{\}}
\DoxyCodeLine{1642 }
\DoxyCodeLine{1643   \textcolor{comment}{// This template type conversion operator allows a}}
\DoxyCodeLine{1644   \textcolor{comment}{// BothOfMatcher<Matcher1, Matcher2> object to match any type that}}
\DoxyCodeLine{1645   \textcolor{comment}{// both Matcher1 and Matcher2 can match.}}
\DoxyCodeLine{1646   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1647   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1648     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1BothOfMatcherImpl}{BothOfMatcherImpl<T>}}(SafeMatcherCast<T>(matcher1\_),}
\DoxyCodeLine{1649                                                SafeMatcherCast<T>(matcher2\_)));}
\DoxyCodeLine{1650   \}}
\DoxyCodeLine{1651 }
\DoxyCodeLine{1652  \textcolor{keyword}{private}:}
\DoxyCodeLine{1653   Matcher1 matcher1\_;}
\DoxyCodeLine{1654   Matcher2 matcher2\_;}
\DoxyCodeLine{1655 }
\DoxyCodeLine{1656   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1BothOfMatcher}{BothOfMatcher}});}
\DoxyCodeLine{1657 \};}
\DoxyCodeLine{1658 }
\DoxyCodeLine{1659 \textcolor{comment}{// Implements the AnyOf(m1, m2) matcher for a particular argument type}}
\DoxyCodeLine{1660 \textcolor{comment}{// T.  We do not nest it inside the AnyOfMatcher class template, as}}
\DoxyCodeLine{1661 \textcolor{comment}{// that will prevent different instantiations of AnyOfMatcher from}}
\DoxyCodeLine{1662 \textcolor{comment}{// sharing the same EitherOfMatcherImpl<T> class.}}
\DoxyCodeLine{1663 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1664 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1EitherOfMatcherImpl}{EitherOfMatcherImpl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<T> \{}
\DoxyCodeLine{1665  \textcolor{keyword}{public}:}
\DoxyCodeLine{1666   \mbox{\hyperlink{classtesting_1_1internal_1_1EitherOfMatcherImpl}{EitherOfMatcherImpl}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}\& matcher1, \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}\& matcher2)}
\DoxyCodeLine{1667       : matcher1\_(matcher1), matcher2\_(matcher2) \{\}}
\DoxyCodeLine{1668 }
\DoxyCodeLine{1669   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1670     *os << \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{1671     matcher1\_.DescribeTo(os);}
\DoxyCodeLine{1672     *os << \textcolor{stringliteral}{"{}) or ("{}};}
\DoxyCodeLine{1673     matcher2\_.DescribeTo(os);}
\DoxyCodeLine{1674     *os << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1675   \}}
\DoxyCodeLine{1676 }
\DoxyCodeLine{1677   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1678     *os << \textcolor{stringliteral}{"{}("{}};}
\DoxyCodeLine{1679     matcher1\_.DescribeNegationTo(os);}
\DoxyCodeLine{1680     *os << \textcolor{stringliteral}{"{}) and ("{}};}
\DoxyCodeLine{1681     matcher2\_.DescribeNegationTo(os);}
\DoxyCodeLine{1682     *os << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1683   \}}
\DoxyCodeLine{1684 }
\DoxyCodeLine{1685   \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(T x, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1686     \textcolor{comment}{// If either matcher1\_ or matcher2\_ matches x, we just need to}}
\DoxyCodeLine{1687     \textcolor{comment}{// explain why *one* of them matches.}}
\DoxyCodeLine{1688     \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} listener1;}
\DoxyCodeLine{1689     \textcolor{keywordflow}{if} (matcher1\_.MatchAndExplain(x, \&listener1)) \{}
\DoxyCodeLine{1690       *listener << listener1.str();}
\DoxyCodeLine{1691       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1692     \}}
\DoxyCodeLine{1693 }
\DoxyCodeLine{1694     \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} listener2;}
\DoxyCodeLine{1695     \textcolor{keywordflow}{if} (matcher2\_.MatchAndExplain(x, \&listener2)) \{}
\DoxyCodeLine{1696       *listener << listener2.str();}
\DoxyCodeLine{1697       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1698     \}}
\DoxyCodeLine{1699 }
\DoxyCodeLine{1700     \textcolor{comment}{// Otherwise we need to explain why *both* of them fail.}}
\DoxyCodeLine{1701     \textcolor{keyword}{const} internal::string s1 = listener1.str();}
\DoxyCodeLine{1702     \textcolor{keyword}{const} internal::string s2 = listener2.str();}
\DoxyCodeLine{1703 }
\DoxyCodeLine{1704     \textcolor{keywordflow}{if} (s1 == \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{1705       *listener << s2;}
\DoxyCodeLine{1706     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1707       *listener << s1;}
\DoxyCodeLine{1708       \textcolor{keywordflow}{if} (s2 != \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{1709         *listener << \textcolor{stringliteral}{"{}, and "{}} << s2;}
\DoxyCodeLine{1710       \}}
\DoxyCodeLine{1711     \}}
\DoxyCodeLine{1712     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1713   \}}
\DoxyCodeLine{1714 }
\DoxyCodeLine{1715  \textcolor{keyword}{private}:}
\DoxyCodeLine{1716   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} matcher1\_;}
\DoxyCodeLine{1717   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}} matcher2\_;}
\DoxyCodeLine{1718 }
\DoxyCodeLine{1719   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1EitherOfMatcherImpl}{EitherOfMatcherImpl}});}
\DoxyCodeLine{1720 \};}
\DoxyCodeLine{1721 }
\DoxyCodeLine{1722 \textcolor{preprocessor}{\#if GTEST\_LANG\_CXX11}}
\DoxyCodeLine{1723 \textcolor{comment}{// AnyOfMatcher is used for the variadic implementation of AnyOf(m\_1, m\_2, ...).}}
\DoxyCodeLine{1724 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{1725 \textcolor{keyword}{using} AnyOfMatcher = VariadicMatcher<\mbox{\hyperlink{classtesting_1_1internal_1_1EitherOfMatcherImpl}{EitherOfMatcherImpl}}, Args...>;}
\DoxyCodeLine{1726 }
\DoxyCodeLine{1727 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_LANG\_CXX11}}
\DoxyCodeLine{1728 }
\DoxyCodeLine{1729 \textcolor{comment}{// Used for implementing the AnyOf(m\_1, ..., m\_n) matcher, which}}
\DoxyCodeLine{1730 \textcolor{comment}{// matches a value that matches at least one of the matchers m\_1, ...,}}
\DoxyCodeLine{1731 \textcolor{comment}{// and m\_n.}}
\DoxyCodeLine{1732 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Matcher1, \textcolor{keyword}{typename} Matcher2>}
\DoxyCodeLine{1733 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1EitherOfMatcher}{EitherOfMatcher}} \{}
\DoxyCodeLine{1734  \textcolor{keyword}{public}:}
\DoxyCodeLine{1735   \mbox{\hyperlink{classtesting_1_1internal_1_1EitherOfMatcher}{EitherOfMatcher}}(Matcher1 matcher1, Matcher2 matcher2)}
\DoxyCodeLine{1736       : matcher1\_(matcher1), matcher2\_(matcher2) \{\}}
\DoxyCodeLine{1737 }
\DoxyCodeLine{1738   \textcolor{comment}{// This template type conversion operator allows a}}
\DoxyCodeLine{1739   \textcolor{comment}{// EitherOfMatcher<Matcher1, Matcher2> object to match any type that}}
\DoxyCodeLine{1740   \textcolor{comment}{// both Matcher1 and Matcher2 can match.}}
\DoxyCodeLine{1741   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1742   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1743     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1EitherOfMatcherImpl}{EitherOfMatcherImpl<T>}}(}
\DoxyCodeLine{1744         SafeMatcherCast<T>(matcher1\_), SafeMatcherCast<T>(matcher2\_)));}
\DoxyCodeLine{1745   \}}
\DoxyCodeLine{1746 }
\DoxyCodeLine{1747  \textcolor{keyword}{private}:}
\DoxyCodeLine{1748   Matcher1 matcher1\_;}
\DoxyCodeLine{1749   Matcher2 matcher2\_;}
\DoxyCodeLine{1750 }
\DoxyCodeLine{1751   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1EitherOfMatcher}{EitherOfMatcher}});}
\DoxyCodeLine{1752 \};}
\DoxyCodeLine{1753 }
\DoxyCodeLine{1754 \textcolor{comment}{// Used for implementing Truly(pred), which turns a predicate into a}}
\DoxyCodeLine{1755 \textcolor{comment}{// matcher.}}
\DoxyCodeLine{1756 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Predicate>}
\DoxyCodeLine{1757 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1TrulyMatcher}{TrulyMatcher}} \{}
\DoxyCodeLine{1758  \textcolor{keyword}{public}:}
\DoxyCodeLine{1759   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1TrulyMatcher}{TrulyMatcher}}(Predicate pred) : predicate\_(pred) \{\}}
\DoxyCodeLine{1760 }
\DoxyCodeLine{1761   \textcolor{comment}{// This method template allows Truly(pred) to be used as a matcher}}
\DoxyCodeLine{1762   \textcolor{comment}{// for type T where T is the argument type of predicate 'pred'.  The}}
\DoxyCodeLine{1763   \textcolor{comment}{// argument is passed by reference as the predicate may be}}
\DoxyCodeLine{1764   \textcolor{comment}{// interested in the address of the argument.}}
\DoxyCodeLine{1765   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1766   \textcolor{keywordtype}{bool} MatchAndExplain(T\& x,  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1767                        \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* \textcolor{comment}{/* listener */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1768     \textcolor{comment}{// Without the if-\/statement, MSVC sometimes warns about converting}}
\DoxyCodeLine{1769     \textcolor{comment}{// a value to bool (warning 4800).}}
\DoxyCodeLine{1770     \textcolor{comment}{//}}
\DoxyCodeLine{1771     \textcolor{comment}{// We cannot write 'return !!predicate\_(x);' as that doesn't work}}
\DoxyCodeLine{1772     \textcolor{comment}{// when predicate\_(x) returns a class convertible to bool but}}
\DoxyCodeLine{1773     \textcolor{comment}{// having no operator!().}}
\DoxyCodeLine{1774     \textcolor{keywordflow}{if} (predicate\_(x))}
\DoxyCodeLine{1775       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1776     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1777   \}}
\DoxyCodeLine{1778 }
\DoxyCodeLine{1779   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1780     *os << \textcolor{stringliteral}{"{}satisfies the given predicate"{}};}
\DoxyCodeLine{1781   \}}
\DoxyCodeLine{1782 }
\DoxyCodeLine{1783   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1784     *os << \textcolor{stringliteral}{"{}doesn't satisfy the given predicate"{}};}
\DoxyCodeLine{1785   \}}
\DoxyCodeLine{1786 }
\DoxyCodeLine{1787  \textcolor{keyword}{private}:}
\DoxyCodeLine{1788   Predicate predicate\_;}
\DoxyCodeLine{1789 }
\DoxyCodeLine{1790   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1TrulyMatcher}{TrulyMatcher}});}
\DoxyCodeLine{1791 \};}
\DoxyCodeLine{1792 }
\DoxyCodeLine{1793 \textcolor{comment}{// Used for implementing Matches(matcher), which turns a matcher into}}
\DoxyCodeLine{1794 \textcolor{comment}{// a predicate.}}
\DoxyCodeLine{1795 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{1796 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1MatcherAsPredicate}{MatcherAsPredicate}} \{}
\DoxyCodeLine{1797  \textcolor{keyword}{public}:}
\DoxyCodeLine{1798   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1MatcherAsPredicate}{MatcherAsPredicate}}(M matcher) : matcher\_(matcher) \{\}}
\DoxyCodeLine{1799 }
\DoxyCodeLine{1800   \textcolor{comment}{// This template operator() allows Matches(m) to be used as a}}
\DoxyCodeLine{1801   \textcolor{comment}{// predicate on type T where m is a matcher on type T.}}
\DoxyCodeLine{1802   \textcolor{comment}{//}}
\DoxyCodeLine{1803   \textcolor{comment}{// The argument x is passed by reference instead of by value, as}}
\DoxyCodeLine{1804   \textcolor{comment}{// some matcher may be interested in its address (e.g. as in}}
\DoxyCodeLine{1805   \textcolor{comment}{// Matches(Ref(n))(x)).}}
\DoxyCodeLine{1806   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1807   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} T\& x)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1808     \textcolor{comment}{// We let matcher\_ commit to a particular type here instead of}}
\DoxyCodeLine{1809     \textcolor{comment}{// when the MatcherAsPredicate object was constructed.  This}}
\DoxyCodeLine{1810     \textcolor{comment}{// allows us to write Matches(m) where m is a polymorphic matcher}}
\DoxyCodeLine{1811     \textcolor{comment}{// (e.g. Eq(5)).}}
\DoxyCodeLine{1812     \textcolor{comment}{//}}
\DoxyCodeLine{1813     \textcolor{comment}{// If we write Matcher<T>(matcher\_).Matches(x) here, it won't}}
\DoxyCodeLine{1814     \textcolor{comment}{// compile when matcher\_ has type Matcher<const T\&>; if we write}}
\DoxyCodeLine{1815     \textcolor{comment}{// Matcher<const T\&>(matcher\_).Matches(x) here, it won't compile}}
\DoxyCodeLine{1816     \textcolor{comment}{// when matcher\_ has type Matcher<T>; if we just write}}
\DoxyCodeLine{1817     \textcolor{comment}{// matcher\_.Matches(x), it won't compile when matcher\_ is}}
\DoxyCodeLine{1818     \textcolor{comment}{// polymorphic, e.g. Eq(5).}}
\DoxyCodeLine{1819     \textcolor{comment}{//}}
\DoxyCodeLine{1820     \textcolor{comment}{// MatcherCast<const T\&>() is necessary for making the code work}}
\DoxyCodeLine{1821     \textcolor{comment}{// in all of the above situations.}}
\DoxyCodeLine{1822     \textcolor{keywordflow}{return} MatcherCast<const T\&>(matcher\_).Matches(x);}
\DoxyCodeLine{1823   \}}
\DoxyCodeLine{1824 }
\DoxyCodeLine{1825  \textcolor{keyword}{private}:}
\DoxyCodeLine{1826   M matcher\_;}
\DoxyCodeLine{1827 }
\DoxyCodeLine{1828   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1MatcherAsPredicate}{MatcherAsPredicate}});}
\DoxyCodeLine{1829 \};}
\DoxyCodeLine{1830 }
\DoxyCodeLine{1831 \textcolor{comment}{// For implementing ASSERT\_THAT() and EXPECT\_THAT().  The template}}
\DoxyCodeLine{1832 \textcolor{comment}{// argument M must be a type that can be converted to a matcher.}}
\DoxyCodeLine{1833 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{1834 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1PredicateFormatterFromMatcher}{PredicateFormatterFromMatcher}} \{}
\DoxyCodeLine{1835  \textcolor{keyword}{public}:}
\DoxyCodeLine{1836   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1PredicateFormatterFromMatcher}{PredicateFormatterFromMatcher}}(M m) : matcher\_(internal::move(m)) \{\}}
\DoxyCodeLine{1837 }
\DoxyCodeLine{1838   \textcolor{comment}{// This template () operator allows a PredicateFormatterFromMatcher}}
\DoxyCodeLine{1839   \textcolor{comment}{// object to act as a predicate-\/formatter suitable for using with}}
\DoxyCodeLine{1840   \textcolor{comment}{// Google Test's EXPECT\_PRED\_FORMAT1() macro.}}
\DoxyCodeLine{1841   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1842   \mbox{\hyperlink{classtesting_1_1AssertionResult}{AssertionResult}} operator()(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* value\_text, \textcolor{keyword}{const} T\& x)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1843     \textcolor{comment}{// We convert matcher\_ to a Matcher<const T\&> *now* instead of}}
\DoxyCodeLine{1844     \textcolor{comment}{// when the PredicateFormatterFromMatcher object was constructed,}}
\DoxyCodeLine{1845     \textcolor{comment}{// as matcher\_ may be polymorphic (e.g. NotNull()) and we won't}}
\DoxyCodeLine{1846     \textcolor{comment}{// know which type to instantiate it to until we actually see the}}
\DoxyCodeLine{1847     \textcolor{comment}{// type of x here.}}
\DoxyCodeLine{1848     \textcolor{comment}{//}}
\DoxyCodeLine{1849     \textcolor{comment}{// We write SafeMatcherCast<const T\&>(matcher\_) instead of}}
\DoxyCodeLine{1850     \textcolor{comment}{// Matcher<const T\&>(matcher\_), as the latter won't compile when}}
\DoxyCodeLine{1851     \textcolor{comment}{// matcher\_ has type Matcher<T> (e.g. An<int>()).}}
\DoxyCodeLine{1852     \textcolor{comment}{// We don't write MatcherCast<const T\&> either, as that allows}}
\DoxyCodeLine{1853     \textcolor{comment}{// potentially unsafe downcasting of the matcher argument.}}
\DoxyCodeLine{1854     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<const T\&>}} matcher = SafeMatcherCast<const T\&>(matcher\_);}
\DoxyCodeLine{1855     \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} listener;}
\DoxyCodeLine{1856     \textcolor{keywordflow}{if} (MatchPrintAndExplain(x, matcher, \&listener))}
\DoxyCodeLine{1857       \textcolor{keywordflow}{return} AssertionSuccess();}
\DoxyCodeLine{1858 }
\DoxyCodeLine{1859     ::std::stringstream ss;}
\DoxyCodeLine{1860     ss << \textcolor{stringliteral}{"{}Value of: "{}} << value\_text << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{1861        << \textcolor{stringliteral}{"{}Expected: "{}};}
\DoxyCodeLine{1862     matcher.DescribeTo(\&ss);}
\DoxyCodeLine{1863     ss << \textcolor{stringliteral}{"{}\(\backslash\)n  Actual: "{}} << listener.str();}
\DoxyCodeLine{1864     \textcolor{keywordflow}{return} AssertionFailure() << ss.str();}
\DoxyCodeLine{1865   \}}
\DoxyCodeLine{1866 }
\DoxyCodeLine{1867  \textcolor{keyword}{private}:}
\DoxyCodeLine{1868   \textcolor{keyword}{const} M matcher\_;}
\DoxyCodeLine{1869 }
\DoxyCodeLine{1870   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1PredicateFormatterFromMatcher}{PredicateFormatterFromMatcher}});}
\DoxyCodeLine{1871 \};}
\DoxyCodeLine{1872 }
\DoxyCodeLine{1873 \textcolor{comment}{// A helper function for converting a matcher to a predicate-\/formatter}}
\DoxyCodeLine{1874 \textcolor{comment}{// without the user needing to explicitly write the type.  This is}}
\DoxyCodeLine{1875 \textcolor{comment}{// used for implementing ASSERT\_THAT() and EXPECT\_THAT().}}
\DoxyCodeLine{1876 \textcolor{comment}{// Implementation detail: 'matcher' is received by-\/value to force decaying.}}
\DoxyCodeLine{1877 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{1878 \textcolor{keyword}{inline} \mbox{\hyperlink{classtesting_1_1internal_1_1PredicateFormatterFromMatcher}{PredicateFormatterFromMatcher<M>}}}
\DoxyCodeLine{1879 MakePredicateFormatterFromMatcher(M matcher) \{}
\DoxyCodeLine{1880   \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1PredicateFormatterFromMatcher}{PredicateFormatterFromMatcher<M>}}(internal::move(matcher));}
\DoxyCodeLine{1881 \}}
\DoxyCodeLine{1882 }
\DoxyCodeLine{1883 \textcolor{comment}{// Implements the polymorphic floating point equality matcher, which matches}}
\DoxyCodeLine{1884 \textcolor{comment}{// two float values using ULP-\/based approximation or, optionally, a}}
\DoxyCodeLine{1885 \textcolor{comment}{// user-\/specified epsilon.  The template is meant to be instantiated with}}
\DoxyCodeLine{1886 \textcolor{comment}{// FloatType being either float or double.}}
\DoxyCodeLine{1887 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FloatType>}
\DoxyCodeLine{1888 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1FloatingEqMatcher}{FloatingEqMatcher}} \{}
\DoxyCodeLine{1889  \textcolor{keyword}{public}:}
\DoxyCodeLine{1890   \textcolor{comment}{// Constructor for FloatingEqMatcher.}}
\DoxyCodeLine{1891   \textcolor{comment}{// The matcher's input will be compared with expected.  The matcher treats two}}
\DoxyCodeLine{1892   \textcolor{comment}{// NANs as equal if nan\_eq\_nan is true.  Otherwise, under IEEE standards,}}
\DoxyCodeLine{1893   \textcolor{comment}{// equality comparisons between NANs will always return false.  We specify a}}
\DoxyCodeLine{1894   \textcolor{comment}{// negative max\_abs\_error\_ term to indicate that ULP-\/based approximation will}}
\DoxyCodeLine{1895   \textcolor{comment}{// be used for comparison.}}
\DoxyCodeLine{1896   \mbox{\hyperlink{classtesting_1_1internal_1_1FloatingEqMatcher}{FloatingEqMatcher}}(FloatType expected, \textcolor{keywordtype}{bool} nan\_eq\_nan) :}
\DoxyCodeLine{1897     expected\_(expected), nan\_eq\_nan\_(nan\_eq\_nan), max\_abs\_error\_(-\/1) \{}
\DoxyCodeLine{1898   \}}
\DoxyCodeLine{1899 }
\DoxyCodeLine{1900   \textcolor{comment}{// Constructor that supports a user-\/specified max\_abs\_error that will be used}}
\DoxyCodeLine{1901   \textcolor{comment}{// for comparison instead of ULP-\/based approximation.  The max absolute}}
\DoxyCodeLine{1902   \textcolor{comment}{// should be non-\/negative.}}
\DoxyCodeLine{1903   \mbox{\hyperlink{classtesting_1_1internal_1_1FloatingEqMatcher}{FloatingEqMatcher}}(FloatType expected, \textcolor{keywordtype}{bool} nan\_eq\_nan,}
\DoxyCodeLine{1904                     FloatType max\_abs\_error)}
\DoxyCodeLine{1905       : expected\_(expected),}
\DoxyCodeLine{1906         nan\_eq\_nan\_(nan\_eq\_nan),}
\DoxyCodeLine{1907         max\_abs\_error\_(max\_abs\_error) \{}
\DoxyCodeLine{1908     GTEST\_CHECK\_(max\_abs\_error >= 0)}
\DoxyCodeLine{1909         << \textcolor{stringliteral}{"{}, where max\_abs\_error is"{}} << max\_abs\_error;}
\DoxyCodeLine{1910   \}}
\DoxyCodeLine{1911 }
\DoxyCodeLine{1912   \textcolor{comment}{// Implements floating point equality matcher as a Matcher<T>.}}
\DoxyCodeLine{1913   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1914   \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1FloatingEqMatcher_1_1Impl}{Impl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<T> \{}
\DoxyCodeLine{1915    \textcolor{keyword}{public}:}
\DoxyCodeLine{1916     \mbox{\hyperlink{classtesting_1_1internal_1_1FloatingEqMatcher_1_1Impl}{Impl}}(FloatType expected, \textcolor{keywordtype}{bool} nan\_eq\_nan, FloatType max\_abs\_error)}
\DoxyCodeLine{1917         : expected\_(expected),}
\DoxyCodeLine{1918           nan\_eq\_nan\_(nan\_eq\_nan),}
\DoxyCodeLine{1919           max\_abs\_error\_(max\_abs\_error) \{\}}
\DoxyCodeLine{1920 }
\DoxyCodeLine{1921     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(T value,}
\DoxyCodeLine{1922                                  \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1923       \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1FloatingPoint}{FloatingPoint<FloatType>}} actual(value), expected(expected\_);}
\DoxyCodeLine{1924 }
\DoxyCodeLine{1925       \textcolor{comment}{// Compares NaNs first, if nan\_eq\_nan\_ is true.}}
\DoxyCodeLine{1926       \textcolor{keywordflow}{if} (actual.is\_nan() || expected.is\_nan()) \{}
\DoxyCodeLine{1927         \textcolor{keywordflow}{if} (actual.is\_nan() \&\& expected.is\_nan()) \{}
\DoxyCodeLine{1928           \textcolor{keywordflow}{return} nan\_eq\_nan\_;}
\DoxyCodeLine{1929         \}}
\DoxyCodeLine{1930         \textcolor{comment}{// One is nan; the other is not nan.}}
\DoxyCodeLine{1931         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1932       \}}
\DoxyCodeLine{1933       \textcolor{keywordflow}{if} (HasMaxAbsError()) \{}
\DoxyCodeLine{1934         \textcolor{comment}{// We perform an equality check so that inf will match inf, regardless}}
\DoxyCodeLine{1935         \textcolor{comment}{// of error bounds.  If the result of value -\/ expected\_ would result in}}
\DoxyCodeLine{1936         \textcolor{comment}{// overflow or if either value is inf, the default result is infinity,}}
\DoxyCodeLine{1937         \textcolor{comment}{// which should only match if max\_abs\_error\_ is also infinity.}}
\DoxyCodeLine{1938         \textcolor{keywordflow}{if} (value == expected\_) \{}
\DoxyCodeLine{1939           \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1940         \}}
\DoxyCodeLine{1941 }
\DoxyCodeLine{1942         \textcolor{keyword}{const} FloatType diff = value -\/ expected\_;}
\DoxyCodeLine{1943         \textcolor{keywordflow}{if} (fabs(diff) <= max\_abs\_error\_) \{}
\DoxyCodeLine{1944           \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1945         \}}
\DoxyCodeLine{1946 }
\DoxyCodeLine{1947         \textcolor{keywordflow}{if} (listener-\/>IsInterested()) \{}
\DoxyCodeLine{1948           *listener << \textcolor{stringliteral}{"{}which is "{}} << diff << \textcolor{stringliteral}{"{} from "{}} << expected\_;}
\DoxyCodeLine{1949         \}}
\DoxyCodeLine{1950         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1951       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1952         \textcolor{keywordflow}{return} actual.AlmostEquals(expected);}
\DoxyCodeLine{1953       \}}
\DoxyCodeLine{1954     \}}
\DoxyCodeLine{1955 }
\DoxyCodeLine{1956     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1957       \textcolor{comment}{// os-\/>precision() returns the previously set precision, which we}}
\DoxyCodeLine{1958       \textcolor{comment}{// store to restore the ostream to its original configuration}}
\DoxyCodeLine{1959       \textcolor{comment}{// after outputting.}}
\DoxyCodeLine{1960       const ::std::streamsize old\_precision = os-\/>precision(}
\DoxyCodeLine{1961           ::std::numeric\_limits<FloatType>::digits10 + 2);}
\DoxyCodeLine{1962       \textcolor{keywordflow}{if} (\mbox{\hyperlink{classtesting_1_1internal_1_1FloatingPoint}{FloatingPoint<FloatType>}}(expected\_).is\_nan()) \{}
\DoxyCodeLine{1963         \textcolor{keywordflow}{if} (nan\_eq\_nan\_) \{}
\DoxyCodeLine{1964           *os << \textcolor{stringliteral}{"{}is NaN"{}};}
\DoxyCodeLine{1965         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1966           *os << \textcolor{stringliteral}{"{}never matches"{}};}
\DoxyCodeLine{1967         \}}
\DoxyCodeLine{1968       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1969         *os << \textcolor{stringliteral}{"{}is approximately "{}} << expected\_;}
\DoxyCodeLine{1970         \textcolor{keywordflow}{if} (HasMaxAbsError()) \{}
\DoxyCodeLine{1971           *os << \textcolor{stringliteral}{"{} (absolute error <= "{}} << max\_abs\_error\_ << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1972         \}}
\DoxyCodeLine{1973       \}}
\DoxyCodeLine{1974       os-\/>precision(old\_precision);}
\DoxyCodeLine{1975     \}}
\DoxyCodeLine{1976 }
\DoxyCodeLine{1977     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1978       \textcolor{comment}{// As before, get original precision.}}
\DoxyCodeLine{1979       const ::std::streamsize old\_precision = os-\/>precision(}
\DoxyCodeLine{1980           ::std::numeric\_limits<FloatType>::digits10 + 2);}
\DoxyCodeLine{1981       \textcolor{keywordflow}{if} (\mbox{\hyperlink{classtesting_1_1internal_1_1FloatingPoint}{FloatingPoint<FloatType>}}(expected\_).is\_nan()) \{}
\DoxyCodeLine{1982         \textcolor{keywordflow}{if} (nan\_eq\_nan\_) \{}
\DoxyCodeLine{1983           *os << \textcolor{stringliteral}{"{}isn't NaN"{}};}
\DoxyCodeLine{1984         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1985           *os << \textcolor{stringliteral}{"{}is anything"{}};}
\DoxyCodeLine{1986         \}}
\DoxyCodeLine{1987       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1988         *os << \textcolor{stringliteral}{"{}isn't approximately "{}} << expected\_;}
\DoxyCodeLine{1989         \textcolor{keywordflow}{if} (HasMaxAbsError()) \{}
\DoxyCodeLine{1990           *os << \textcolor{stringliteral}{"{} (absolute error > "{}} << max\_abs\_error\_ << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{1991         \}}
\DoxyCodeLine{1992       \}}
\DoxyCodeLine{1993       \textcolor{comment}{// Restore original precision.}}
\DoxyCodeLine{1994       os-\/>precision(old\_precision);}
\DoxyCodeLine{1995     \}}
\DoxyCodeLine{1996 }
\DoxyCodeLine{1997    \textcolor{keyword}{private}:}
\DoxyCodeLine{1998     \textcolor{keywordtype}{bool} HasMaxAbsError()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1999       \textcolor{keywordflow}{return} max\_abs\_error\_ >= 0;}
\DoxyCodeLine{2000     \}}
\DoxyCodeLine{2001 }
\DoxyCodeLine{2002     \textcolor{keyword}{const} FloatType expected\_;}
\DoxyCodeLine{2003     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} nan\_eq\_nan\_;}
\DoxyCodeLine{2004     \textcolor{comment}{// max\_abs\_error will be used for value comparison when >= 0.}}
\DoxyCodeLine{2005     \textcolor{keyword}{const} FloatType max\_abs\_error\_;}
\DoxyCodeLine{2006 }
\DoxyCodeLine{2007     GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1FloatingEqMatcher_1_1Impl}{Impl}});}
\DoxyCodeLine{2008   \};}
\DoxyCodeLine{2009 }
\DoxyCodeLine{2010   \textcolor{comment}{// The following 3 type conversion operators allow FloatEq(expected) and}}
\DoxyCodeLine{2011   \textcolor{comment}{// NanSensitiveFloatEq(expected) to be used as a Matcher<float>, a}}
\DoxyCodeLine{2012   \textcolor{comment}{// Matcher<const float\&>, or a Matcher<float\&>, but nothing else.}}
\DoxyCodeLine{2013   \textcolor{comment}{// (While Google's C++ coding style doesn't allow arguments passed}}
\DoxyCodeLine{2014   \textcolor{comment}{// by non-\/const reference, we may see them in code not conforming to}}
\DoxyCodeLine{2015   \textcolor{comment}{// the style.  Therefore Google Mock needs to support them.)}}
\DoxyCodeLine{2016   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<FloatType>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2017     \textcolor{keywordflow}{return} MakeMatcher(}
\DoxyCodeLine{2018         \textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1FloatingEqMatcher_1_1Impl}{Impl<FloatType>}}(expected\_, nan\_eq\_nan\_, max\_abs\_error\_));}
\DoxyCodeLine{2019   \}}
\DoxyCodeLine{2020 }
\DoxyCodeLine{2021   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<const FloatType\&>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2022     \textcolor{keywordflow}{return} MakeMatcher(}
\DoxyCodeLine{2023         \textcolor{keyword}{new} Impl<const FloatType\&>(expected\_, nan\_eq\_nan\_, max\_abs\_error\_));}
\DoxyCodeLine{2024   \}}
\DoxyCodeLine{2025 }
\DoxyCodeLine{2026   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<FloatType\&>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2027     \textcolor{keywordflow}{return} MakeMatcher(}
\DoxyCodeLine{2028         \textcolor{keyword}{new} Impl<FloatType\&>(expected\_, nan\_eq\_nan\_, max\_abs\_error\_));}
\DoxyCodeLine{2029   \}}
\DoxyCodeLine{2030 }
\DoxyCodeLine{2031  \textcolor{keyword}{private}:}
\DoxyCodeLine{2032   \textcolor{keyword}{const} FloatType expected\_;}
\DoxyCodeLine{2033   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} nan\_eq\_nan\_;}
\DoxyCodeLine{2034   \textcolor{comment}{// max\_abs\_error will be used for value comparison when >= 0.}}
\DoxyCodeLine{2035   \textcolor{keyword}{const} FloatType max\_abs\_error\_;}
\DoxyCodeLine{2036 }
\DoxyCodeLine{2037   GTEST\_DISALLOW\_ASSIGN\_(FloatingEqMatcher);}
\DoxyCodeLine{2038 \};}
\DoxyCodeLine{2039 }
\DoxyCodeLine{2040 \textcolor{comment}{// Implements the Pointee(m) matcher for matching a pointer whose}}
\DoxyCodeLine{2041 \textcolor{comment}{// pointee matches matcher m.  The pointer can be either raw or smart.}}
\DoxyCodeLine{2042 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{2043 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1PointeeMatcher}{PointeeMatcher}} \{}
\DoxyCodeLine{2044  \textcolor{keyword}{public}:}
\DoxyCodeLine{2045   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1PointeeMatcher}{PointeeMatcher}}(\textcolor{keyword}{const} InnerMatcher\& matcher) : matcher\_(matcher) \{\}}
\DoxyCodeLine{2046 }
\DoxyCodeLine{2047   \textcolor{comment}{// This type conversion operator template allows Pointee(m) to be}}
\DoxyCodeLine{2048   \textcolor{comment}{// used as a matcher for any pointer type whose pointee type is}}
\DoxyCodeLine{2049   \textcolor{comment}{// compatible with the inner matcher, where type Pointer can be}}
\DoxyCodeLine{2050   \textcolor{comment}{// either a raw pointer or a smart pointer.}}
\DoxyCodeLine{2051   \textcolor{comment}{//}}
\DoxyCodeLine{2052   \textcolor{comment}{// The reason we do this instead of relying on}}
\DoxyCodeLine{2053   \textcolor{comment}{// MakePolymorphicMatcher() is that the latter is not flexible}}
\DoxyCodeLine{2054   \textcolor{comment}{// enough for implementing the DescribeTo() method of Pointee().}}
\DoxyCodeLine{2055   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{2056   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<Pointer>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2057     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} Impl<Pointer>(matcher\_));}
\DoxyCodeLine{2058   \}}
\DoxyCodeLine{2059 }
\DoxyCodeLine{2060  \textcolor{keyword}{private}:}
\DoxyCodeLine{2061   \textcolor{comment}{// The monomorphic implementation that works for a particular pointer type.}}
\DoxyCodeLine{2062   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Po\textcolor{keywordtype}{int}er>}
\DoxyCodeLine{2063   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<Pointer> \{}
\DoxyCodeLine{2064    \textcolor{keyword}{public}:}
\DoxyCodeLine{2065     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1PointeeOf}{PointeeOf}}<GTEST\_REMOVE\_CONST\_(  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{2066         GTEST\_REMOVE\_REFERENCE\_(Pointer))>::type Pointee;}
\DoxyCodeLine{2067 }
\DoxyCodeLine{2068     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} InnerMatcher\& matcher)}
\DoxyCodeLine{2069         : matcher\_(MatcherCast<const Pointee\&>(matcher)) \{\}}
\DoxyCodeLine{2070 }
\DoxyCodeLine{2071     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2072       *os << \textcolor{stringliteral}{"{}points to a value that "{}};}
\DoxyCodeLine{2073       matcher\_.DescribeTo(os);}
\DoxyCodeLine{2074     \}}
\DoxyCodeLine{2075 }
\DoxyCodeLine{2076     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2077       *os << \textcolor{stringliteral}{"{}does not point to a value that "{}};}
\DoxyCodeLine{2078       matcher\_.DescribeTo(os);}
\DoxyCodeLine{2079     \}}
\DoxyCodeLine{2080 }
\DoxyCodeLine{2081     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(Pointer pointer,}
\DoxyCodeLine{2082                                  \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2083       \textcolor{keywordflow}{if} (GetRawPointer(pointer) == NULL)}
\DoxyCodeLine{2084         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2085 }
\DoxyCodeLine{2086       *listener << \textcolor{stringliteral}{"{}which points to "{}};}
\DoxyCodeLine{2087       \textcolor{keywordflow}{return} MatchPrintAndExplain(*pointer, matcher\_, listener);}
\DoxyCodeLine{2088     \}}
\DoxyCodeLine{2089 }
\DoxyCodeLine{2090    \textcolor{keyword}{private}:}
\DoxyCodeLine{2091     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<const Pointee\&>}} matcher\_;}
\DoxyCodeLine{2092 }
\DoxyCodeLine{2093     GTEST\_DISALLOW\_ASSIGN\_(Impl);}
\DoxyCodeLine{2094   \};}
\DoxyCodeLine{2095 }
\DoxyCodeLine{2096   \textcolor{keyword}{const} InnerMatcher matcher\_;}
\DoxyCodeLine{2097 }
\DoxyCodeLine{2098   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1PointeeMatcher}{PointeeMatcher}});}
\DoxyCodeLine{2099 \};}
\DoxyCodeLine{2100 }
\DoxyCodeLine{2101 \textcolor{comment}{// Implements the WhenDynamicCastTo<T>(m) matcher that matches a pointer or}}
\DoxyCodeLine{2102 \textcolor{comment}{// reference that matches inner\_matcher when dynamic\_cast<T> is applied.}}
\DoxyCodeLine{2103 \textcolor{comment}{// The result of dynamic\_cast<To> is forwarded to the inner matcher.}}
\DoxyCodeLine{2104 \textcolor{comment}{// If To is a pointer and the cast fails, the inner matcher will receive NULL.}}
\DoxyCodeLine{2105 \textcolor{comment}{// If To is a reference and the cast fails, this matcher returns false}}
\DoxyCodeLine{2106 \textcolor{comment}{// immediately.}}
\DoxyCodeLine{2107 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To>}
\DoxyCodeLine{2108 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1WhenDynamicCastToMatcherBase}{WhenDynamicCastToMatcherBase}} \{}
\DoxyCodeLine{2109  \textcolor{keyword}{public}:}
\DoxyCodeLine{2110   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1WhenDynamicCastToMatcherBase}{WhenDynamicCastToMatcherBase}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<To>}}\& matcher)}
\DoxyCodeLine{2111       : matcher\_(matcher) \{\}}
\DoxyCodeLine{2112 }
\DoxyCodeLine{2113   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2114     GetCastTypeDescription(os);}
\DoxyCodeLine{2115     matcher\_.DescribeTo(os);}
\DoxyCodeLine{2116   \}}
\DoxyCodeLine{2117 }
\DoxyCodeLine{2118   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2119     GetCastTypeDescription(os);}
\DoxyCodeLine{2120     matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2121   \}}
\DoxyCodeLine{2122 }
\DoxyCodeLine{2123  \textcolor{keyword}{protected}:}
\DoxyCodeLine{2124   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<To>}} matcher\_;}
\DoxyCodeLine{2125 }
\DoxyCodeLine{2126   \textcolor{keyword}{static} \textcolor{keywordtype}{string} GetToName() \{}
\DoxyCodeLine{2127 \textcolor{preprocessor}{\#if GTEST\_HAS\_RTTI}}
\DoxyCodeLine{2128     \textcolor{keywordflow}{return} GetTypeName<To>();}
\DoxyCodeLine{2129 \textcolor{preprocessor}{\#else  }\textcolor{comment}{// GTEST\_HAS\_RTTI}}
\DoxyCodeLine{2130     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}the target type"{}};}
\DoxyCodeLine{2131 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_RTTI}}
\DoxyCodeLine{2132   \}}
\DoxyCodeLine{2133 }
\DoxyCodeLine{2134  \textcolor{keyword}{private}:}
\DoxyCodeLine{2135   \textcolor{keyword}{static} \textcolor{keywordtype}{void} GetCastTypeDescription(::std::ostream* os) \{}
\DoxyCodeLine{2136     *os << \textcolor{stringliteral}{"{}when dynamic\_cast to "{}} << GetToName() << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{2137   \}}
\DoxyCodeLine{2138 }
\DoxyCodeLine{2139   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1WhenDynamicCastToMatcherBase}{WhenDynamicCastToMatcherBase}});}
\DoxyCodeLine{2140 \};}
\DoxyCodeLine{2141 }
\DoxyCodeLine{2142 \textcolor{comment}{// Primary template.}}
\DoxyCodeLine{2143 \textcolor{comment}{// To is a pointer. Cast and forward the result.}}
\DoxyCodeLine{2144 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To>}
\DoxyCodeLine{2145 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1WhenDynamicCastToMatcher}{WhenDynamicCastToMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1WhenDynamicCastToMatcherBase}{WhenDynamicCastToMatcherBase}}<To> \{}
\DoxyCodeLine{2146  \textcolor{keyword}{public}:}
\DoxyCodeLine{2147   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1WhenDynamicCastToMatcher}{WhenDynamicCastToMatcher}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<To>}}\& matcher)}
\DoxyCodeLine{2148       : \mbox{\hyperlink{classtesting_1_1internal_1_1WhenDynamicCastToMatcherBase}{WhenDynamicCastToMatcherBase<To>}}(matcher) \{\}}
\DoxyCodeLine{2149 }
\DoxyCodeLine{2150   \textcolor{keyword}{template} <\textcolor{keyword}{typename} From>}
\DoxyCodeLine{2151   \textcolor{keywordtype}{bool} MatchAndExplain(From from, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2152     \textcolor{comment}{// TODO(sbenza): Add more detail on failures. ie did the dyn\_cast fail?}}
\DoxyCodeLine{2153     \mbox{\hyperlink{classtesting_1_1internal_1_1To}{To}} to = \textcolor{keyword}{dynamic\_cast<}\mbox{\hyperlink{classtesting_1_1internal_1_1To}{To}}\textcolor{keyword}{>}(from);}
\DoxyCodeLine{2154     \textcolor{keywordflow}{return} MatchPrintAndExplain(to, this-\/>matcher\_, listener);}
\DoxyCodeLine{2155   \}}
\DoxyCodeLine{2156 \};}
\DoxyCodeLine{2157 }
\DoxyCodeLine{2158 \textcolor{comment}{// Specialize for references.}}
\DoxyCodeLine{2159 \textcolor{comment}{// In this case we return false if the dynamic\_cast fails.}}
\DoxyCodeLine{2160 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To>}
\DoxyCodeLine{2161 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1WhenDynamicCastToMatcher}{WhenDynamicCastToMatcher}}<\mbox{\hyperlink{classtesting_1_1internal_1_1To}{To}}\&> : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1WhenDynamicCastToMatcherBase}{WhenDynamicCastToMatcherBase<To\&>}} \{}
\DoxyCodeLine{2162  \textcolor{keyword}{public}:}
\DoxyCodeLine{2163   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1WhenDynamicCastToMatcher}{WhenDynamicCastToMatcher}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<To\&>}}\& matcher)}
\DoxyCodeLine{2164       : \mbox{\hyperlink{classtesting_1_1internal_1_1WhenDynamicCastToMatcherBase}{WhenDynamicCastToMatcherBase<To\&>}}(matcher) \{\}}
\DoxyCodeLine{2165 }
\DoxyCodeLine{2166   \textcolor{keyword}{template} <\textcolor{keyword}{typename} From>}
\DoxyCodeLine{2167   \textcolor{keywordtype}{bool} MatchAndExplain(From\& from, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2168     \textcolor{comment}{// We don't want an std::bad\_cast here, so do the cast with pointers.}}
\DoxyCodeLine{2169     \mbox{\hyperlink{classtesting_1_1internal_1_1To}{To}}* to = \textcolor{keyword}{dynamic\_cast<}\mbox{\hyperlink{classtesting_1_1internal_1_1To}{To}}*\textcolor{keyword}{>}(\&from);}
\DoxyCodeLine{2170     \textcolor{keywordflow}{if} (to == NULL) \{}
\DoxyCodeLine{2171       *listener << \textcolor{stringliteral}{"{}which cannot be dynamic\_cast to "{}} << this-\/>GetToName();}
\DoxyCodeLine{2172       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2173     \}}
\DoxyCodeLine{2174     \textcolor{keywordflow}{return} MatchPrintAndExplain(*to, this-\/>matcher\_, listener);}
\DoxyCodeLine{2175   \}}
\DoxyCodeLine{2176 \};}
\DoxyCodeLine{2177 }
\DoxyCodeLine{2178 \textcolor{comment}{// Implements the Field() matcher for matching a field (i.e. member}}
\DoxyCodeLine{2179 \textcolor{comment}{// variable) of an object.}}
\DoxyCodeLine{2180 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Class, \textcolor{keyword}{typename} FieldType>}
\DoxyCodeLine{2181 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1FieldMatcher}{FieldMatcher}} \{}
\DoxyCodeLine{2182  \textcolor{keyword}{public}:}
\DoxyCodeLine{2183   \mbox{\hyperlink{classtesting_1_1internal_1_1FieldMatcher}{FieldMatcher}}(FieldType Class::*field,}
\DoxyCodeLine{2184                \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<const FieldType\&>}}\& matcher)}
\DoxyCodeLine{2185       : field\_(field), matcher\_(matcher) \{\}}
\DoxyCodeLine{2186 }
\DoxyCodeLine{2187   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2188     *os << \textcolor{stringliteral}{"{}is an object whose given field "{}};}
\DoxyCodeLine{2189     matcher\_.DescribeTo(os);}
\DoxyCodeLine{2190   \}}
\DoxyCodeLine{2191 }
\DoxyCodeLine{2192   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2193     *os << \textcolor{stringliteral}{"{}is an object whose given field "{}};}
\DoxyCodeLine{2194     matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2195   \}}
\DoxyCodeLine{2196 }
\DoxyCodeLine{2197   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2198   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} T\& value, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2199     \textcolor{keywordflow}{return} MatchAndExplainImpl(}
\DoxyCodeLine{2200         typename ::testing::internal::}
\DoxyCodeLine{2201             \mbox{\hyperlink{structtesting_1_1internal_1_1is__pointer}{is\_pointer}}<GTEST\_REMOVE\_CONST\_(T)>::type(),}
\DoxyCodeLine{2202         value, listener);}
\DoxyCodeLine{2203   \}}
\DoxyCodeLine{2204 }
\DoxyCodeLine{2205  \textcolor{keyword}{private}:}
\DoxyCodeLine{2206   \textcolor{comment}{// The first argument of MatchAndExplainImpl() is needed to help}}
\DoxyCodeLine{2207   \textcolor{comment}{// Symbian's C++ compiler choose which overload to use.  Its type is}}
\DoxyCodeLine{2208   \textcolor{comment}{// true\_type iff the Field() matcher is used to match a pointer.}}
\DoxyCodeLine{2209   \textcolor{keywordtype}{bool} MatchAndExplainImpl(\mbox{\hyperlink{structtesting_1_1internal_1_1bool__constant}{false\_type}} \textcolor{comment}{/* is\_not\_pointer */}, \textcolor{keyword}{const} Class\& obj,}
\DoxyCodeLine{2210                            \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2211     *listener << \textcolor{stringliteral}{"{}whose given field is "{}};}
\DoxyCodeLine{2212     \textcolor{keywordflow}{return} MatchPrintAndExplain(obj.*field\_, matcher\_, listener);}
\DoxyCodeLine{2213   \}}
\DoxyCodeLine{2214 }
\DoxyCodeLine{2215   \textcolor{keywordtype}{bool} MatchAndExplainImpl(\mbox{\hyperlink{structtesting_1_1internal_1_1bool__constant}{true\_type}} \textcolor{comment}{/* is\_pointer */}, \textcolor{keyword}{const} Class* p,}
\DoxyCodeLine{2216                            \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2217     \textcolor{keywordflow}{if} (p == NULL)}
\DoxyCodeLine{2218       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2219 }
\DoxyCodeLine{2220     *listener << \textcolor{stringliteral}{"{}which points to an object "{}};}
\DoxyCodeLine{2221     \textcolor{comment}{// Since *p has a field, it must be a class/struct/union type and}}
\DoxyCodeLine{2222     \textcolor{comment}{// thus cannot be a pointer.  Therefore we pass false\_type() as}}
\DoxyCodeLine{2223     \textcolor{comment}{// the first argument.}}
\DoxyCodeLine{2224     \textcolor{keywordflow}{return} MatchAndExplainImpl(\mbox{\hyperlink{structtesting_1_1internal_1_1bool__constant}{false\_type}}(), *p, listener);}
\DoxyCodeLine{2225   \}}
\DoxyCodeLine{2226 }
\DoxyCodeLine{2227   \textcolor{keyword}{const} FieldType Class::*field\_;}
\DoxyCodeLine{2228   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<const FieldType\&>}} matcher\_;}
\DoxyCodeLine{2229 }
\DoxyCodeLine{2230   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1FieldMatcher}{FieldMatcher}});}
\DoxyCodeLine{2231 \};}
\DoxyCodeLine{2232 }
\DoxyCodeLine{2233 \textcolor{comment}{// Implements the Property() matcher for matching a property}}
\DoxyCodeLine{2234 \textcolor{comment}{// (i.e. return value of a getter method) of an object.}}
\DoxyCodeLine{2235 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Class, \textcolor{keyword}{typename} PropertyType>}
\DoxyCodeLine{2236 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1PropertyMatcher}{PropertyMatcher}} \{}
\DoxyCodeLine{2237  \textcolor{keyword}{public}:}
\DoxyCodeLine{2238   \textcolor{comment}{// The property may have a reference type, so 'const PropertyType\&'}}
\DoxyCodeLine{2239   \textcolor{comment}{// may cause double references and fail to compile.  That's why we}}
\DoxyCodeLine{2240   \textcolor{comment}{// need GTEST\_REFERENCE\_TO\_CONST, which works regardless of}}
\DoxyCodeLine{2241   \textcolor{comment}{// PropertyType being a reference or not.}}
\DoxyCodeLine{2242   \textcolor{keyword}{typedef} GTEST\_REFERENCE\_TO\_CONST\_(PropertyType) RefToConstProperty;}
\DoxyCodeLine{2243 }
\DoxyCodeLine{2244   \mbox{\hyperlink{classtesting_1_1internal_1_1PropertyMatcher}{PropertyMatcher}}(PropertyType (Class::*property)() \textcolor{keyword}{const},}
\DoxyCodeLine{2245                   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<RefToConstProperty>}}\& matcher)}
\DoxyCodeLine{2246       : property\_(property), matcher\_(matcher) \{\}}
\DoxyCodeLine{2247 }
\DoxyCodeLine{2248   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2249     *os << \textcolor{stringliteral}{"{}is an object whose given property "{}};}
\DoxyCodeLine{2250     matcher\_.DescribeTo(os);}
\DoxyCodeLine{2251   \}}
\DoxyCodeLine{2252 }
\DoxyCodeLine{2253   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2254     *os << \textcolor{stringliteral}{"{}is an object whose given property "{}};}
\DoxyCodeLine{2255     matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2256   \}}
\DoxyCodeLine{2257 }
\DoxyCodeLine{2258   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2259   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} T\&value, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2260     \textcolor{keywordflow}{return} MatchAndExplainImpl(}
\DoxyCodeLine{2261         typename ::testing::internal::}
\DoxyCodeLine{2262             \mbox{\hyperlink{structtesting_1_1internal_1_1is__pointer}{is\_pointer}}<GTEST\_REMOVE\_CONST\_(T)>::type(),}
\DoxyCodeLine{2263         value, listener);}
\DoxyCodeLine{2264   \}}
\DoxyCodeLine{2265 }
\DoxyCodeLine{2266  \textcolor{keyword}{private}:}
\DoxyCodeLine{2267   \textcolor{comment}{// The first argument of MatchAndExplainImpl() is needed to help}}
\DoxyCodeLine{2268   \textcolor{comment}{// Symbian's C++ compiler choose which overload to use.  Its type is}}
\DoxyCodeLine{2269   \textcolor{comment}{// true\_type iff the Property() matcher is used to match a pointer.}}
\DoxyCodeLine{2270   \textcolor{keywordtype}{bool} MatchAndExplainImpl(\mbox{\hyperlink{structtesting_1_1internal_1_1bool__constant}{false\_type}} \textcolor{comment}{/* is\_not\_pointer */}, \textcolor{keyword}{const} Class\& obj,}
\DoxyCodeLine{2271                            \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2272     *listener << \textcolor{stringliteral}{"{}whose given property is "{}};}
\DoxyCodeLine{2273     \textcolor{comment}{// Cannot pass the return value (for example, int) to MatchPrintAndExplain,}}
\DoxyCodeLine{2274     \textcolor{comment}{// which takes a non-\/const reference as argument.}}
\DoxyCodeLine{2275 \textcolor{preprocessor}{\#if defined(\_PREFAST\_ ) \&\& \_MSC\_VER == 1800}}
\DoxyCodeLine{2276     \textcolor{comment}{// Workaround bug in VC++ 2013's /analyze parser.}}
\DoxyCodeLine{2277     \textcolor{comment}{// https://connect.microsoft.com/VisualStudio/feedback/details/1106363/internal-\/compiler-\/error-\/with-\/analyze-\/due-\/to-\/failure-\/to-\/infer-\/move}}
\DoxyCodeLine{2278     posix::Abort();  \textcolor{comment}{// To make sure it is never run.}}
\DoxyCodeLine{2279     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2280 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2281     RefToConstProperty result = (obj.*property\_)();}
\DoxyCodeLine{2282     \textcolor{keywordflow}{return} MatchPrintAndExplain(result, matcher\_, listener);}
\DoxyCodeLine{2283 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2284   \}}
\DoxyCodeLine{2285 }
\DoxyCodeLine{2286   \textcolor{keywordtype}{bool} MatchAndExplainImpl(\mbox{\hyperlink{structtesting_1_1internal_1_1bool__constant}{true\_type}} \textcolor{comment}{/* is\_pointer */}, \textcolor{keyword}{const} Class* p,}
\DoxyCodeLine{2287                            \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2288     \textcolor{keywordflow}{if} (p == NULL)}
\DoxyCodeLine{2289       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2290 }
\DoxyCodeLine{2291     *listener << \textcolor{stringliteral}{"{}which points to an object "{}};}
\DoxyCodeLine{2292     \textcolor{comment}{// Since *p has a property method, it must be a class/struct/union}}
\DoxyCodeLine{2293     \textcolor{comment}{// type and thus cannot be a pointer.  Therefore we pass}}
\DoxyCodeLine{2294     \textcolor{comment}{// false\_type() as the first argument.}}
\DoxyCodeLine{2295     \textcolor{keywordflow}{return} MatchAndExplainImpl(\mbox{\hyperlink{structtesting_1_1internal_1_1bool__constant}{false\_type}}(), *p, listener);}
\DoxyCodeLine{2296   \}}
\DoxyCodeLine{2297 }
\DoxyCodeLine{2298   PropertyType (Class::*property\_)() \textcolor{keyword}{const};}
\DoxyCodeLine{2299   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<RefToConstProperty>}} matcher\_;}
\DoxyCodeLine{2300 }
\DoxyCodeLine{2301   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1PropertyMatcher}{PropertyMatcher}});}
\DoxyCodeLine{2302 \};}
\DoxyCodeLine{2303 }
\DoxyCodeLine{2304 \textcolor{comment}{// Type traits specifying various features of different functors for ResultOf.}}
\DoxyCodeLine{2305 \textcolor{comment}{// The default template specifies features for functor objects.}}
\DoxyCodeLine{2306 \textcolor{comment}{// Functor classes have to typedef argument\_type and result\_type}}
\DoxyCodeLine{2307 \textcolor{comment}{// to be compatible with ResultOf.}}
\DoxyCodeLine{2308 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Functor>}
\DoxyCodeLine{2309 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1CallableTraits}{CallableTraits}} \{}
\DoxyCodeLine{2310   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Functor::result\_type ResultType;}
\DoxyCodeLine{2311   \textcolor{keyword}{typedef} Functor StorageType;}
\DoxyCodeLine{2312 }
\DoxyCodeLine{2313   \textcolor{keyword}{static} \textcolor{keywordtype}{void} CheckIsValid(Functor \textcolor{comment}{/* functor */}) \{\}}
\DoxyCodeLine{2314   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2315   \textcolor{keyword}{static} ResultType Invoke(Functor f, T arg) \{ \textcolor{keywordflow}{return} f(arg); \}}
\DoxyCodeLine{2316 \};}
\DoxyCodeLine{2317 }
\DoxyCodeLine{2318 \textcolor{comment}{// Specialization for function pointers.}}
\DoxyCodeLine{2319 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} ResType>}
\DoxyCodeLine{2320 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1CallableTraits}{CallableTraits}}<ResType(*)(ArgType)> \{}
\DoxyCodeLine{2321   \textcolor{keyword}{typedef} ResType ResultType;}
\DoxyCodeLine{2322   \textcolor{keyword}{typedef} ResType(*StorageType)(ArgType);}
\DoxyCodeLine{2323 }
\DoxyCodeLine{2324   \textcolor{keyword}{static} \textcolor{keywordtype}{void} CheckIsValid(ResType(*f)(ArgType)) \{}
\DoxyCodeLine{2325     GTEST\_CHECK\_(f != NULL)}
\DoxyCodeLine{2326         << \textcolor{stringliteral}{"{}NULL function pointer is passed into ResultOf()."{}};}
\DoxyCodeLine{2327   \}}
\DoxyCodeLine{2328   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2329   \textcolor{keyword}{static} ResType Invoke(ResType(*f)(ArgType), T arg) \{}
\DoxyCodeLine{2330     \textcolor{keywordflow}{return} (*f)(arg);}
\DoxyCodeLine{2331   \}}
\DoxyCodeLine{2332 \};}
\DoxyCodeLine{2333 }
\DoxyCodeLine{2334 \textcolor{comment}{// Implements the ResultOf() matcher for matching a return value of a}}
\DoxyCodeLine{2335 \textcolor{comment}{// unary function of an object.}}
\DoxyCodeLine{2336 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable>}
\DoxyCodeLine{2337 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ResultOfMatcher}{ResultOfMatcher}} \{}
\DoxyCodeLine{2338  \textcolor{keyword}{public}:}
\DoxyCodeLine{2339   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1CallableTraits}{CallableTraits<Callable>::ResultType}} ResultType;}
\DoxyCodeLine{2340 }
\DoxyCodeLine{2341   \mbox{\hyperlink{classtesting_1_1internal_1_1ResultOfMatcher}{ResultOfMatcher}}(Callable callable, \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<ResultType>}}\& matcher)}
\DoxyCodeLine{2342       : callable\_(callable), matcher\_(matcher) \{}
\DoxyCodeLine{2343     \mbox{\hyperlink{structtesting_1_1internal_1_1CallableTraits}{CallableTraits<Callable>::CheckIsValid}}(callable\_);}
\DoxyCodeLine{2344   \}}
\DoxyCodeLine{2345 }
\DoxyCodeLine{2346   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2347   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2348     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}(\textcolor{keyword}{new} Impl<T>(callable\_, matcher\_));}
\DoxyCodeLine{2349   \}}
\DoxyCodeLine{2350 }
\DoxyCodeLine{2351  \textcolor{keyword}{private}:}
\DoxyCodeLine{2352   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1CallableTraits}{CallableTraits<Callable>::StorageType}} CallableStorageType;}
\DoxyCodeLine{2353 }
\DoxyCodeLine{2354   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2355   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<T> \{}
\DoxyCodeLine{2356    \textcolor{keyword}{public}:}
\DoxyCodeLine{2357     Impl(CallableStorageType callable, \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<ResultType>}}\& matcher)}
\DoxyCodeLine{2358         : callable\_(callable), matcher\_(matcher) \{\}}
\DoxyCodeLine{2359 }
\DoxyCodeLine{2360     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2361       *os << \textcolor{stringliteral}{"{}is mapped by the given callable to a value that "{}};}
\DoxyCodeLine{2362       matcher\_.DescribeTo(os);}
\DoxyCodeLine{2363     \}}
\DoxyCodeLine{2364 }
\DoxyCodeLine{2365     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2366       *os << \textcolor{stringliteral}{"{}is mapped by the given callable to a value that "{}};}
\DoxyCodeLine{2367       matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2368     \}}
\DoxyCodeLine{2369 }
\DoxyCodeLine{2370     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(T obj, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2371       *listener << \textcolor{stringliteral}{"{}which is mapped by the given callable to "{}};}
\DoxyCodeLine{2372       \textcolor{comment}{// Cannot pass the return value (for example, int) to}}
\DoxyCodeLine{2373       \textcolor{comment}{// MatchPrintAndExplain, which takes a non-\/const reference as argument.}}
\DoxyCodeLine{2374       ResultType result =}
\DoxyCodeLine{2375           \mbox{\hyperlink{structtesting_1_1internal_1_1CallableTraits}{CallableTraits<Callable>::template}} Invoke<T>(callable\_, obj);}
\DoxyCodeLine{2376       \textcolor{keywordflow}{return} MatchPrintAndExplain(result, matcher\_, listener);}
\DoxyCodeLine{2377     \}}
\DoxyCodeLine{2378 }
\DoxyCodeLine{2379    \textcolor{keyword}{private}:}
\DoxyCodeLine{2380     \textcolor{comment}{// Functors often define operator() as non-\/const method even though}}
\DoxyCodeLine{2381     \textcolor{comment}{// they are actualy stateless. But we need to use them even when}}
\DoxyCodeLine{2382     \textcolor{comment}{// 'this' is a const pointer. It's the user's responsibility not to}}
\DoxyCodeLine{2383     \textcolor{comment}{// use stateful callables with ResultOf(), which does't guarantee}}
\DoxyCodeLine{2384     \textcolor{comment}{// how many times the callable will be invoked.}}
\DoxyCodeLine{2385     \textcolor{keyword}{mutable} CallableStorageType callable\_;}
\DoxyCodeLine{2386     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<ResultType>}} matcher\_;}
\DoxyCodeLine{2387 }
\DoxyCodeLine{2388     GTEST\_DISALLOW\_ASSIGN\_(Impl);}
\DoxyCodeLine{2389   \};  \textcolor{comment}{// class Impl}}
\DoxyCodeLine{2390 }
\DoxyCodeLine{2391   \textcolor{keyword}{const} CallableStorageType callable\_;}
\DoxyCodeLine{2392   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<ResultType>}} matcher\_;}
\DoxyCodeLine{2393 }
\DoxyCodeLine{2394   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1ResultOfMatcher}{ResultOfMatcher}});}
\DoxyCodeLine{2395 \};}
\DoxyCodeLine{2396 }
\DoxyCodeLine{2397 \textcolor{comment}{// Implements a matcher that checks the size of an STL-\/style container.}}
\DoxyCodeLine{2398 \textcolor{keyword}{template} <\textcolor{keyword}{typename} SizeMatcher>}
\DoxyCodeLine{2399 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1SizeIsMatcher}{SizeIsMatcher}} \{}
\DoxyCodeLine{2400  \textcolor{keyword}{public}:}
\DoxyCodeLine{2401   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1SizeIsMatcher}{SizeIsMatcher}}(\textcolor{keyword}{const} SizeMatcher\& size\_matcher)}
\DoxyCodeLine{2402        : size\_matcher\_(size\_matcher) \{}
\DoxyCodeLine{2403   \}}
\DoxyCodeLine{2404 }
\DoxyCodeLine{2405   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2406   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<Container>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2407     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1SizeIsMatcher_1_1Impl}{Impl<Container>}}(size\_matcher\_));}
\DoxyCodeLine{2408   \}}
\DoxyCodeLine{2409 }
\DoxyCodeLine{2410   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2411   \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1SizeIsMatcher_1_1Impl}{Impl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<Container> \{}
\DoxyCodeLine{2412    \textcolor{keyword}{public}:}
\DoxyCodeLine{2413     \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{internal::StlContainerView}}<}
\DoxyCodeLine{2414          GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)> \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{ContainerView}};}
\DoxyCodeLine{2415     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ContainerView::type::size\_type SizeType;}
\DoxyCodeLine{2416     \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1SizeIsMatcher_1_1Impl}{Impl}}(\textcolor{keyword}{const} SizeMatcher\& size\_matcher)}
\DoxyCodeLine{2417         : size\_matcher\_(MatcherCast<SizeType>(size\_matcher)) \{\}}
\DoxyCodeLine{2418 }
\DoxyCodeLine{2419     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2420       *os << \textcolor{stringliteral}{"{}size "{}};}
\DoxyCodeLine{2421       size\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2422     \}}
\DoxyCodeLine{2423     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2424       *os << \textcolor{stringliteral}{"{}size "{}};}
\DoxyCodeLine{2425       size\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2426     \}}
\DoxyCodeLine{2427 }
\DoxyCodeLine{2428     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{2429                                  \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2430       SizeType size = container.size();}
\DoxyCodeLine{2431       \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} size\_listener;}
\DoxyCodeLine{2432       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} result = size\_matcher\_.MatchAndExplain(size, \&size\_listener);}
\DoxyCodeLine{2433       *listener}
\DoxyCodeLine{2434           << \textcolor{stringliteral}{"{}whose size "{}} << size << (result ? \textcolor{stringliteral}{"{} matches"{}} : \textcolor{stringliteral}{"{} doesn't match"{}});}
\DoxyCodeLine{2435       PrintIfNotEmpty(size\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{2436       \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2437     \}}
\DoxyCodeLine{2438 }
\DoxyCodeLine{2439    \textcolor{keyword}{private}:}
\DoxyCodeLine{2440     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<SizeType>}} size\_matcher\_;}
\DoxyCodeLine{2441     GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1SizeIsMatcher_1_1Impl}{Impl}});}
\DoxyCodeLine{2442   \};}
\DoxyCodeLine{2443 }
\DoxyCodeLine{2444  \textcolor{keyword}{private}:}
\DoxyCodeLine{2445   \textcolor{keyword}{const} SizeMatcher size\_matcher\_;}
\DoxyCodeLine{2446   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1SizeIsMatcher}{SizeIsMatcher}});}
\DoxyCodeLine{2447 \};}
\DoxyCodeLine{2448 }
\DoxyCodeLine{2449 \textcolor{comment}{// Implements a matcher that checks the begin()..end() distance of an STL-\/style}}
\DoxyCodeLine{2450 \textcolor{comment}{// container.}}
\DoxyCodeLine{2451 \textcolor{keyword}{template} <\textcolor{keyword}{typename} DistanceMatcher>}
\DoxyCodeLine{2452 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1BeginEndDistanceIsMatcher}{BeginEndDistanceIsMatcher}} \{}
\DoxyCodeLine{2453  \textcolor{keyword}{public}:}
\DoxyCodeLine{2454   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1BeginEndDistanceIsMatcher}{BeginEndDistanceIsMatcher}}(\textcolor{keyword}{const} DistanceMatcher\& distance\_matcher)}
\DoxyCodeLine{2455       : distance\_matcher\_(distance\_matcher) \{\}}
\DoxyCodeLine{2456 }
\DoxyCodeLine{2457   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2458   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<Container>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2459     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1BeginEndDistanceIsMatcher_1_1Impl}{Impl<Container>}}(distance\_matcher\_));}
\DoxyCodeLine{2460   \}}
\DoxyCodeLine{2461 }
\DoxyCodeLine{2462   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2463   \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1BeginEndDistanceIsMatcher_1_1Impl}{Impl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<Container> \{}
\DoxyCodeLine{2464    \textcolor{keyword}{public}:}
\DoxyCodeLine{2465     \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{internal::StlContainerView}}<}
\DoxyCodeLine{2466         GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)> \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{ContainerView}};}
\DoxyCodeLine{2467     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} std::iterator\_traits<}
\DoxyCodeLine{2468         \textcolor{keyword}{typename} ContainerView::type::const\_iterator>::difference\_type}
\DoxyCodeLine{2469         DistanceType;}
\DoxyCodeLine{2470     \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1BeginEndDistanceIsMatcher_1_1Impl}{Impl}}(\textcolor{keyword}{const} DistanceMatcher\& distance\_matcher)}
\DoxyCodeLine{2471         : distance\_matcher\_(MatcherCast<DistanceType>(distance\_matcher)) \{\}}
\DoxyCodeLine{2472 }
\DoxyCodeLine{2473     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2474       *os << \textcolor{stringliteral}{"{}distance between begin() and end() "{}};}
\DoxyCodeLine{2475       distance\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2476     \}}
\DoxyCodeLine{2477     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2478       *os << \textcolor{stringliteral}{"{}distance between begin() and end() "{}};}
\DoxyCodeLine{2479       distance\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2480     \}}
\DoxyCodeLine{2481 }
\DoxyCodeLine{2482     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{2483                                  \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2484 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_BEGIN\_AND\_END\_}}
\DoxyCodeLine{2485       \textcolor{keyword}{using} std::begin;}
\DoxyCodeLine{2486       \textcolor{keyword}{using} std::end;}
\DoxyCodeLine{2487       DistanceType distance = std::distance(begin(container), end(container));}
\DoxyCodeLine{2488 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2489       DistanceType distance = std::distance(container.begin(), container.end());}
\DoxyCodeLine{2490 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2491       \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} distance\_listener;}
\DoxyCodeLine{2492       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} result =}
\DoxyCodeLine{2493           distance\_matcher\_.MatchAndExplain(distance, \&distance\_listener);}
\DoxyCodeLine{2494       *listener << \textcolor{stringliteral}{"{}whose distance between begin() and end() "{}} << distance}
\DoxyCodeLine{2495                 << (result ? \textcolor{stringliteral}{"{} matches"{}} : \textcolor{stringliteral}{"{} doesn't match"{}});}
\DoxyCodeLine{2496       PrintIfNotEmpty(distance\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{2497       \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2498     \}}
\DoxyCodeLine{2499 }
\DoxyCodeLine{2500    \textcolor{keyword}{private}:}
\DoxyCodeLine{2501     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<DistanceType>}} distance\_matcher\_;}
\DoxyCodeLine{2502     GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1BeginEndDistanceIsMatcher_1_1Impl}{Impl}});}
\DoxyCodeLine{2503   \};}
\DoxyCodeLine{2504 }
\DoxyCodeLine{2505  \textcolor{keyword}{private}:}
\DoxyCodeLine{2506   \textcolor{keyword}{const} DistanceMatcher distance\_matcher\_;}
\DoxyCodeLine{2507   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1BeginEndDistanceIsMatcher}{BeginEndDistanceIsMatcher}});}
\DoxyCodeLine{2508 \};}
\DoxyCodeLine{2509 }
\DoxyCodeLine{2510 \textcolor{comment}{// Implements an equality matcher for any STL-\/style container whose elements}}
\DoxyCodeLine{2511 \textcolor{comment}{// support ==. This matcher is like Eq(), but its failure explanations provide}}
\DoxyCodeLine{2512 \textcolor{comment}{// more detailed information that is useful when the container is used as a set.}}
\DoxyCodeLine{2513 \textcolor{comment}{// The failure message reports elements that are in one of the operands but not}}
\DoxyCodeLine{2514 \textcolor{comment}{// the other. The failure messages do not report duplicate or out-\/of-\/order}}
\DoxyCodeLine{2515 \textcolor{comment}{// elements in the containers (which don't properly matter to sets, but can}}
\DoxyCodeLine{2516 \textcolor{comment}{// occur if the containers are vectors or lists, for example).}}
\DoxyCodeLine{2517 \textcolor{comment}{//}}
\DoxyCodeLine{2518 \textcolor{comment}{// Uses the container's const\_iterator, value\_type, operator ==,}}
\DoxyCodeLine{2519 \textcolor{comment}{// begin(), and end().}}
\DoxyCodeLine{2520 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2521 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ContainerEqMatcher}{ContainerEqMatcher}} \{}
\DoxyCodeLine{2522  \textcolor{keyword}{public}:}
\DoxyCodeLine{2523   \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{internal::StlContainerView<Container>}} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{View}};}
\DoxyCodeLine{2524   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::type StlContainer;}
\DoxyCodeLine{2525   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::const\_reference StlContainerReference;}
\DoxyCodeLine{2526 }
\DoxyCodeLine{2527   \textcolor{comment}{// We make a copy of expected in case the elements in it are modified}}
\DoxyCodeLine{2528   \textcolor{comment}{// after this matcher is created.}}
\DoxyCodeLine{2529   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ContainerEqMatcher}{ContainerEqMatcher}}(\textcolor{keyword}{const} Container\& expected)}
\DoxyCodeLine{2530       : expected\_(View::Copy(expected)) \{}
\DoxyCodeLine{2531     \textcolor{comment}{// Makes sure the user doesn't instantiate this class template}}
\DoxyCodeLine{2532     \textcolor{comment}{// with a const or reference type.}}
\DoxyCodeLine{2533     (void)testing::StaticAssertTypeEq<Container,}
\DoxyCodeLine{2534         GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container)>();}
\DoxyCodeLine{2535   \}}
\DoxyCodeLine{2536 }
\DoxyCodeLine{2537   \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2538     *os << \textcolor{stringliteral}{"{}equals "{}};}
\DoxyCodeLine{2539     UniversalPrint(expected\_, os);}
\DoxyCodeLine{2540   \}}
\DoxyCodeLine{2541   \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2542     *os << \textcolor{stringliteral}{"{}does not equal "{}};}
\DoxyCodeLine{2543     UniversalPrint(expected\_, os);}
\DoxyCodeLine{2544   \}}
\DoxyCodeLine{2545 }
\DoxyCodeLine{2546   \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsContainer>}
\DoxyCodeLine{2547   \textcolor{keywordtype}{bool} MatchAndExplain(\textcolor{keyword}{const} LhsContainer\& lhs,}
\DoxyCodeLine{2548                        \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2549     \textcolor{comment}{// GTEST\_REMOVE\_CONST\_() is needed to work around an MSVC 8.0 bug}}
\DoxyCodeLine{2550     \textcolor{comment}{// that causes LhsContainer to be a const type sometimes.}}
\DoxyCodeLine{2551     \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{internal::StlContainerView}}<GTEST\_REMOVE\_CONST\_(LhsContainer)>}
\DoxyCodeLine{2552         LhsView;}
\DoxyCodeLine{2553     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsView::type LhsStlContainer;}
\DoxyCodeLine{2554     StlContainerReference lhs\_stl\_container = LhsView::ConstReference(lhs);}
\DoxyCodeLine{2555     \textcolor{keywordflow}{if} (lhs\_stl\_container == expected\_)}
\DoxyCodeLine{2556       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2557 }
\DoxyCodeLine{2558     ::std::ostream* \textcolor{keyword}{const} os = listener-\/>stream();}
\DoxyCodeLine{2559     \textcolor{keywordflow}{if} (os != NULL) \{}
\DoxyCodeLine{2560       \textcolor{comment}{// Something is different. Check for extra values first.}}
\DoxyCodeLine{2561       \textcolor{keywordtype}{bool} printed\_header = \textcolor{keyword}{false};}
\DoxyCodeLine{2562       \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} LhsStlContainer::const\_iterator it =}
\DoxyCodeLine{2563                lhs\_stl\_container.begin();}
\DoxyCodeLine{2564            it != lhs\_stl\_container.end(); ++it) \{}
\DoxyCodeLine{2565         \textcolor{keywordflow}{if} (internal::ArrayAwareFind(expected\_.begin(), expected\_.end(), *it) ==}
\DoxyCodeLine{2566             expected\_.end()) \{}
\DoxyCodeLine{2567           \textcolor{keywordflow}{if} (printed\_header) \{}
\DoxyCodeLine{2568             *os << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{2569           \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2570             *os << \textcolor{stringliteral}{"{}which has these unexpected elements: "{}};}
\DoxyCodeLine{2571             printed\_header = \textcolor{keyword}{true};}
\DoxyCodeLine{2572           \}}
\DoxyCodeLine{2573           UniversalPrint(*it, os);}
\DoxyCodeLine{2574         \}}
\DoxyCodeLine{2575       \}}
\DoxyCodeLine{2576 }
\DoxyCodeLine{2577       \textcolor{comment}{// Now check for missing values.}}
\DoxyCodeLine{2578       \textcolor{keywordtype}{bool} printed\_header2 = \textcolor{keyword}{false};}
\DoxyCodeLine{2579       \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} StlContainer::const\_iterator it = expected\_.begin();}
\DoxyCodeLine{2580            it != expected\_.end(); ++it) \{}
\DoxyCodeLine{2581         \textcolor{keywordflow}{if} (internal::ArrayAwareFind(}
\DoxyCodeLine{2582                 lhs\_stl\_container.begin(), lhs\_stl\_container.end(), *it) ==}
\DoxyCodeLine{2583             lhs\_stl\_container.end()) \{}
\DoxyCodeLine{2584           \textcolor{keywordflow}{if} (printed\_header2) \{}
\DoxyCodeLine{2585             *os << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{2586           \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2587             *os << (printed\_header ? \textcolor{stringliteral}{"{},\(\backslash\)nand"{}} : \textcolor{stringliteral}{"{}which"{}})}
\DoxyCodeLine{2588                 << \textcolor{stringliteral}{"{} doesn't have these expected elements: "{}};}
\DoxyCodeLine{2589             printed\_header2 = \textcolor{keyword}{true};}
\DoxyCodeLine{2590           \}}
\DoxyCodeLine{2591           UniversalPrint(*it, os);}
\DoxyCodeLine{2592         \}}
\DoxyCodeLine{2593       \}}
\DoxyCodeLine{2594     \}}
\DoxyCodeLine{2595 }
\DoxyCodeLine{2596     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2597   \}}
\DoxyCodeLine{2598 }
\DoxyCodeLine{2599  \textcolor{keyword}{private}:}
\DoxyCodeLine{2600   \textcolor{keyword}{const} StlContainer expected\_;}
\DoxyCodeLine{2601 }
\DoxyCodeLine{2602   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1ContainerEqMatcher}{ContainerEqMatcher}});}
\DoxyCodeLine{2603 \};}
\DoxyCodeLine{2604 }
\DoxyCodeLine{2605 \textcolor{comment}{// A comparator functor that uses the < operator to compare two values.}}
\DoxyCodeLine{2606 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1LessComparator}{LessComparator}} \{}
\DoxyCodeLine{2607   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{2608   \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} T\& lhs, \textcolor{keyword}{const} U\& rhs)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} lhs < rhs; \}}
\DoxyCodeLine{2609 \};}
\DoxyCodeLine{2610 }
\DoxyCodeLine{2611 \textcolor{comment}{// Implements WhenSortedBy(comparator, container\_matcher).}}
\DoxyCodeLine{2612 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Comparator, \textcolor{keyword}{typename} ContainerMatcher>}
\DoxyCodeLine{2613 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1WhenSortedByMatcher}{WhenSortedByMatcher}} \{}
\DoxyCodeLine{2614  \textcolor{keyword}{public}:}
\DoxyCodeLine{2615   \mbox{\hyperlink{classtesting_1_1internal_1_1WhenSortedByMatcher}{WhenSortedByMatcher}}(\textcolor{keyword}{const} Comparator\& comparator,}
\DoxyCodeLine{2616                       \textcolor{keyword}{const} ContainerMatcher\& matcher)}
\DoxyCodeLine{2617       : comparator\_(comparator), matcher\_(matcher) \{\}}
\DoxyCodeLine{2618 }
\DoxyCodeLine{2619   \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsContainer>}
\DoxyCodeLine{2620   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<LhsContainer>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2621     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1WhenSortedByMatcher_1_1Impl}{Impl<LhsContainer>}}(comparator\_, matcher\_));}
\DoxyCodeLine{2622   \}}
\DoxyCodeLine{2623 }
\DoxyCodeLine{2624   \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsContainer>}
\DoxyCodeLine{2625   \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1WhenSortedByMatcher_1_1Impl}{Impl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<LhsContainer> \{}
\DoxyCodeLine{2626    \textcolor{keyword}{public}:}
\DoxyCodeLine{2627     \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{internal::StlContainerView}}<}
\DoxyCodeLine{2628          GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(LhsContainer)> \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{LhsView}};}
\DoxyCodeLine{2629     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsView::type LhsStlContainer;}
\DoxyCodeLine{2630     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsView::const\_reference LhsStlContainerReference;}
\DoxyCodeLine{2631     \textcolor{comment}{// Transforms std::pair<const Key, Value> into std::pair<Key, Value>}}
\DoxyCodeLine{2632     \textcolor{comment}{// so that we can match associative containers.}}
\DoxyCodeLine{2633     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1RemoveConstFromKey}{RemoveConstFromKey}}<}
\DoxyCodeLine{2634         \textcolor{keyword}{typename} LhsStlContainer::value\_type>::type LhsValue;}
\DoxyCodeLine{2635 }
\DoxyCodeLine{2636     \mbox{\hyperlink{classtesting_1_1internal_1_1WhenSortedByMatcher_1_1Impl}{Impl}}(\textcolor{keyword}{const} Comparator\& comparator, \textcolor{keyword}{const} ContainerMatcher\& matcher)}
\DoxyCodeLine{2637         : comparator\_(comparator), matcher\_(matcher) \{\}}
\DoxyCodeLine{2638 }
\DoxyCodeLine{2639     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2640       *os << \textcolor{stringliteral}{"{}(when sorted) "{}};}
\DoxyCodeLine{2641       matcher\_.DescribeTo(os);}
\DoxyCodeLine{2642     \}}
\DoxyCodeLine{2643 }
\DoxyCodeLine{2644     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2645       *os << \textcolor{stringliteral}{"{}(when sorted) "{}};}
\DoxyCodeLine{2646       matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2647     \}}
\DoxyCodeLine{2648 }
\DoxyCodeLine{2649     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(LhsContainer lhs,}
\DoxyCodeLine{2650                                  \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2651       LhsStlContainerReference lhs\_stl\_container = LhsView::ConstReference(lhs);}
\DoxyCodeLine{2652       ::std::vector<LhsValue> sorted\_container(lhs\_stl\_container.begin(),}
\DoxyCodeLine{2653                                                lhs\_stl\_container.end());}
\DoxyCodeLine{2654       ::std::sort(}
\DoxyCodeLine{2655            sorted\_container.begin(), sorted\_container.end(), comparator\_);}
\DoxyCodeLine{2656 }
\DoxyCodeLine{2657       \textcolor{keywordflow}{if} (!listener-\/>IsInterested()) \{}
\DoxyCodeLine{2658         \textcolor{comment}{// If the listener is not interested, we do not need to}}
\DoxyCodeLine{2659         \textcolor{comment}{// construct the inner explanation.}}
\DoxyCodeLine{2660         \textcolor{keywordflow}{return} matcher\_.Matches(sorted\_container);}
\DoxyCodeLine{2661       \}}
\DoxyCodeLine{2662 }
\DoxyCodeLine{2663       *listener << \textcolor{stringliteral}{"{}which is "{}};}
\DoxyCodeLine{2664       UniversalPrint(sorted\_container, listener-\/>stream());}
\DoxyCodeLine{2665       *listener << \textcolor{stringliteral}{"{} when sorted"{}};}
\DoxyCodeLine{2666 }
\DoxyCodeLine{2667       \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} inner\_listener;}
\DoxyCodeLine{2668       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} match = matcher\_.MatchAndExplain(sorted\_container,}
\DoxyCodeLine{2669                                                   \&inner\_listener);}
\DoxyCodeLine{2670       PrintIfNotEmpty(inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{2671       \textcolor{keywordflow}{return} match;}
\DoxyCodeLine{2672     \}}
\DoxyCodeLine{2673 }
\DoxyCodeLine{2674    \textcolor{keyword}{private}:}
\DoxyCodeLine{2675     \textcolor{keyword}{const} Comparator comparator\_;}
\DoxyCodeLine{2676     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<const ::std::vector<LhsValue>}}\&> matcher\_;}
\DoxyCodeLine{2677 }
\DoxyCodeLine{2678     GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1WhenSortedByMatcher_1_1Impl}{Impl}});}
\DoxyCodeLine{2679   \};}
\DoxyCodeLine{2680 }
\DoxyCodeLine{2681  \textcolor{keyword}{private}:}
\DoxyCodeLine{2682   \textcolor{keyword}{const} Comparator comparator\_;}
\DoxyCodeLine{2683   \textcolor{keyword}{const} ContainerMatcher matcher\_;}
\DoxyCodeLine{2684 }
\DoxyCodeLine{2685   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1WhenSortedByMatcher}{WhenSortedByMatcher}});}
\DoxyCodeLine{2686 \};}
\DoxyCodeLine{2687 }
\DoxyCodeLine{2688 \textcolor{comment}{// Implements Pointwise(tuple\_matcher, rhs\_container).  tuple\_matcher}}
\DoxyCodeLine{2689 \textcolor{comment}{// must be able to be safely cast to Matcher<tuple<const T1\&, const}}
\DoxyCodeLine{2690 \textcolor{comment}{// T2\&> >, where T1 and T2 are the types of elements in the LHS}}
\DoxyCodeLine{2691 \textcolor{comment}{// container and the RHS container respectively.}}
\DoxyCodeLine{2692 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TupleMatcher, \textcolor{keyword}{typename} RhsContainer>}
\DoxyCodeLine{2693 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1PointwiseMatcher}{PointwiseMatcher}} \{}
\DoxyCodeLine{2694  \textcolor{keyword}{public}:}
\DoxyCodeLine{2695   \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{internal::StlContainerView<RhsContainer>}} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{RhsView}};}
\DoxyCodeLine{2696   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsView::type RhsStlContainer;}
\DoxyCodeLine{2697   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsStlContainer::value\_type RhsValue;}
\DoxyCodeLine{2698 }
\DoxyCodeLine{2699   \textcolor{comment}{// Like ContainerEq, we make a copy of rhs in case the elements in}}
\DoxyCodeLine{2700   \textcolor{comment}{// it are modified after this matcher is created.}}
\DoxyCodeLine{2701   \mbox{\hyperlink{classtesting_1_1internal_1_1PointwiseMatcher}{PointwiseMatcher}}(\textcolor{keyword}{const} TupleMatcher\& tuple\_matcher, \textcolor{keyword}{const} RhsContainer\& rhs)}
\DoxyCodeLine{2702       : tuple\_matcher\_(tuple\_matcher), rhs\_(RhsView::Copy(rhs)) \{}
\DoxyCodeLine{2703     \textcolor{comment}{// Makes sure the user doesn't instantiate this class template}}
\DoxyCodeLine{2704     \textcolor{comment}{// with a const or reference type.}}
\DoxyCodeLine{2705     (void)testing::StaticAssertTypeEq<RhsContainer,}
\DoxyCodeLine{2706         GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(RhsContainer)>();}
\DoxyCodeLine{2707   \}}
\DoxyCodeLine{2708 }
\DoxyCodeLine{2709   \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsContainer>}
\DoxyCodeLine{2710   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<LhsContainer>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2711     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1PointwiseMatcher_1_1Impl}{Impl<LhsContainer>}}(tuple\_matcher\_, rhs\_));}
\DoxyCodeLine{2712   \}}
\DoxyCodeLine{2713 }
\DoxyCodeLine{2714   \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsContainer>}
\DoxyCodeLine{2715   \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1PointwiseMatcher_1_1Impl}{Impl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<LhsContainer> \{}
\DoxyCodeLine{2716    \textcolor{keyword}{public}:}
\DoxyCodeLine{2717     \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{internal::StlContainerView}}<}
\DoxyCodeLine{2718          GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(LhsContainer)> \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{LhsView}};}
\DoxyCodeLine{2719     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsView::type LhsStlContainer;}
\DoxyCodeLine{2720     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsView::const\_reference LhsStlContainerReference;}
\DoxyCodeLine{2721     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsStlContainer::value\_type LhsValue;}
\DoxyCodeLine{2722     \textcolor{comment}{// We pass the LHS value and the RHS value to the inner matcher by}}
\DoxyCodeLine{2723     \textcolor{comment}{// reference, as they may be expensive to copy.  We must use tuple}}
\DoxyCodeLine{2724     \textcolor{comment}{// instead of pair here, as a pair cannot hold references (C++ 98,}}
\DoxyCodeLine{2725     \textcolor{comment}{// 20.2.2 [lib.pairs]).}}
\DoxyCodeLine{2726     typedef ::testing::tuple<const LhsValue\&, const RhsValue\&> InnerMatcherArg;}
\DoxyCodeLine{2727 }
\DoxyCodeLine{2728     \mbox{\hyperlink{classtesting_1_1internal_1_1PointwiseMatcher_1_1Impl}{Impl}}(\textcolor{keyword}{const} TupleMatcher\& tuple\_matcher, \textcolor{keyword}{const} RhsStlContainer\& rhs)}
\DoxyCodeLine{2729         \textcolor{comment}{// mono\_tuple\_matcher\_ holds a monomorphic version of the tuple matcher.}}
\DoxyCodeLine{2730         : mono\_tuple\_matcher\_(SafeMatcherCast<InnerMatcherArg>(tuple\_matcher)),}
\DoxyCodeLine{2731           rhs\_(rhs) \{\}}
\DoxyCodeLine{2732 }
\DoxyCodeLine{2733     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2734       *os << \textcolor{stringliteral}{"{}contains "{}} << rhs\_.size()}
\DoxyCodeLine{2735           << \textcolor{stringliteral}{"{} values, where each value and its corresponding value in "{}};}
\DoxyCodeLine{2736       \mbox{\hyperlink{classtesting_1_1internal_1_1UniversalPrinter}{UniversalPrinter<RhsStlContainer>::Print}}(rhs\_, os);}
\DoxyCodeLine{2737       *os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{2738       mono\_tuple\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2739     \}}
\DoxyCodeLine{2740     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2741       *os << \textcolor{stringliteral}{"{}doesn't contain exactly "{}} << rhs\_.size()}
\DoxyCodeLine{2742           << \textcolor{stringliteral}{"{} values, or contains a value x at some index i"{}}}
\DoxyCodeLine{2743           << \textcolor{stringliteral}{"{} where x and the i-\/th value of "{}};}
\DoxyCodeLine{2744       UniversalPrint(rhs\_, os);}
\DoxyCodeLine{2745       *os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{2746       mono\_tuple\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2747     \}}
\DoxyCodeLine{2748 }
\DoxyCodeLine{2749     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(LhsContainer lhs,}
\DoxyCodeLine{2750                                  \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2751       LhsStlContainerReference lhs\_stl\_container = LhsView::ConstReference(lhs);}
\DoxyCodeLine{2752       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} actual\_size = lhs\_stl\_container.size();}
\DoxyCodeLine{2753       \textcolor{keywordflow}{if} (actual\_size != rhs\_.size()) \{}
\DoxyCodeLine{2754         *listener << \textcolor{stringliteral}{"{}which contains "{}} << actual\_size << \textcolor{stringliteral}{"{} values"{}};}
\DoxyCodeLine{2755         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2756       \}}
\DoxyCodeLine{2757 }
\DoxyCodeLine{2758       \textcolor{keyword}{typename} LhsStlContainer::const\_iterator left = lhs\_stl\_container.begin();}
\DoxyCodeLine{2759       \textcolor{keyword}{typename} RhsStlContainer::const\_iterator right = rhs\_.begin();}
\DoxyCodeLine{2760       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i != actual\_size; ++i, ++left, ++right) \{}
\DoxyCodeLine{2761         \textcolor{keyword}{const} InnerMatcherArg value\_pair(*left, *right);}
\DoxyCodeLine{2762 }
\DoxyCodeLine{2763         \textcolor{keywordflow}{if} (listener-\/>IsInterested()) \{}
\DoxyCodeLine{2764           \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} inner\_listener;}
\DoxyCodeLine{2765           \textcolor{keywordflow}{if} (!mono\_tuple\_matcher\_.MatchAndExplain(}
\DoxyCodeLine{2766                   value\_pair, \&inner\_listener)) \{}
\DoxyCodeLine{2767             *listener << \textcolor{stringliteral}{"{}where the value pair ("{}};}
\DoxyCodeLine{2768             UniversalPrint(*left, listener-\/>stream());}
\DoxyCodeLine{2769             *listener << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{2770             UniversalPrint(*right, listener-\/>stream());}
\DoxyCodeLine{2771             *listener << \textcolor{stringliteral}{"{}) at index \#"{}} << i << \textcolor{stringliteral}{"{} don't match"{}};}
\DoxyCodeLine{2772             PrintIfNotEmpty(inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{2773             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2774           \}}
\DoxyCodeLine{2775         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2776           \textcolor{keywordflow}{if} (!mono\_tuple\_matcher\_.Matches(value\_pair))}
\DoxyCodeLine{2777             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2778         \}}
\DoxyCodeLine{2779       \}}
\DoxyCodeLine{2780 }
\DoxyCodeLine{2781       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2782     \}}
\DoxyCodeLine{2783 }
\DoxyCodeLine{2784    \textcolor{keyword}{private}:}
\DoxyCodeLine{2785     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<InnerMatcherArg>}} mono\_tuple\_matcher\_;}
\DoxyCodeLine{2786     \textcolor{keyword}{const} RhsStlContainer rhs\_;}
\DoxyCodeLine{2787 }
\DoxyCodeLine{2788     GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1PointwiseMatcher_1_1Impl}{Impl}});}
\DoxyCodeLine{2789   \};}
\DoxyCodeLine{2790 }
\DoxyCodeLine{2791  \textcolor{keyword}{private}:}
\DoxyCodeLine{2792   \textcolor{keyword}{const} TupleMatcher tuple\_matcher\_;}
\DoxyCodeLine{2793   \textcolor{keyword}{const} RhsStlContainer rhs\_;}
\DoxyCodeLine{2794 }
\DoxyCodeLine{2795   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1PointwiseMatcher}{PointwiseMatcher}});}
\DoxyCodeLine{2796 \};}
\DoxyCodeLine{2797 }
\DoxyCodeLine{2798 \textcolor{comment}{// Holds the logic common to ContainsMatcherImpl and EachMatcherImpl.}}
\DoxyCodeLine{2799 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2800 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1QuantifierMatcherImpl}{QuantifierMatcherImpl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<Container> \{}
\DoxyCodeLine{2801  \textcolor{keyword}{public}:}
\DoxyCodeLine{2802   \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container) RawContainer;}
\DoxyCodeLine{2803   \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{StlContainerView<RawContainer>}} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{View}};}
\DoxyCodeLine{2804   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::type StlContainer;}
\DoxyCodeLine{2805   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::const\_reference StlContainerReference;}
\DoxyCodeLine{2806   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} StlContainer::value\_type Element;}
\DoxyCodeLine{2807 }
\DoxyCodeLine{2808   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{2809   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1QuantifierMatcherImpl}{QuantifierMatcherImpl}}(InnerMatcher inner\_matcher)}
\DoxyCodeLine{2810       : inner\_matcher\_(}
\DoxyCodeLine{2811            testing::SafeMatcherCast<const Element\&>(inner\_matcher)) \{\}}
\DoxyCodeLine{2812 }
\DoxyCodeLine{2813   \textcolor{comment}{// Checks whether:}}
\DoxyCodeLine{2814   \textcolor{comment}{// * All elements in the container match, if all\_elements\_should\_match.}}
\DoxyCodeLine{2815   \textcolor{comment}{// * Any element in the container matches, if !all\_elements\_should\_match.}}
\DoxyCodeLine{2816   \textcolor{keywordtype}{bool} MatchAndExplainImpl(\textcolor{keywordtype}{bool} all\_elements\_should\_match,}
\DoxyCodeLine{2817                            Container container,}
\DoxyCodeLine{2818                            \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2819     StlContainerReference stl\_container = View::ConstReference(container);}
\DoxyCodeLine{2820     \textcolor{keywordtype}{size\_t} i = 0;}
\DoxyCodeLine{2821     \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} StlContainer::const\_iterator it = stl\_container.begin();}
\DoxyCodeLine{2822          it != stl\_container.end(); ++it, ++i) \{}
\DoxyCodeLine{2823       \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} inner\_listener;}
\DoxyCodeLine{2824       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} matches = inner\_matcher\_.MatchAndExplain(*it, \&inner\_listener);}
\DoxyCodeLine{2825 }
\DoxyCodeLine{2826       \textcolor{keywordflow}{if} (matches != all\_elements\_should\_match) \{}
\DoxyCodeLine{2827         *listener << \textcolor{stringliteral}{"{}whose element \#"{}} << i}
\DoxyCodeLine{2828                   << (matches ? \textcolor{stringliteral}{"{} matches"{}} : \textcolor{stringliteral}{"{} doesn't match"{}});}
\DoxyCodeLine{2829         PrintIfNotEmpty(inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{2830         \textcolor{keywordflow}{return} !all\_elements\_should\_match;}
\DoxyCodeLine{2831       \}}
\DoxyCodeLine{2832     \}}
\DoxyCodeLine{2833     \textcolor{keywordflow}{return} all\_elements\_should\_match;}
\DoxyCodeLine{2834   \}}
\DoxyCodeLine{2835 }
\DoxyCodeLine{2836  \textcolor{keyword}{protected}:}
\DoxyCodeLine{2837   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<const Element\&>}} inner\_matcher\_;}
\DoxyCodeLine{2838 }
\DoxyCodeLine{2839   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1QuantifierMatcherImpl}{QuantifierMatcherImpl}});}
\DoxyCodeLine{2840 \};}
\DoxyCodeLine{2841 }
\DoxyCodeLine{2842 \textcolor{comment}{// Implements Contains(element\_matcher) for the given argument type Container.}}
\DoxyCodeLine{2843 \textcolor{comment}{// Symmetric to EachMatcherImpl.}}
\DoxyCodeLine{2844 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2845 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ContainsMatcherImpl}{ContainsMatcherImpl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1QuantifierMatcherImpl}{QuantifierMatcherImpl}}<Container> \{}
\DoxyCodeLine{2846  \textcolor{keyword}{public}:}
\DoxyCodeLine{2847   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{2848   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ContainsMatcherImpl}{ContainsMatcherImpl}}(InnerMatcher inner\_matcher)}
\DoxyCodeLine{2849       : \mbox{\hyperlink{classtesting_1_1internal_1_1QuantifierMatcherImpl}{QuantifierMatcherImpl<Container>}}(inner\_matcher) \{\}}
\DoxyCodeLine{2850 }
\DoxyCodeLine{2851   \textcolor{comment}{// Describes what this matcher does.}}
\DoxyCodeLine{2852   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2853     *os << \textcolor{stringliteral}{"{}contains at least one element that "{}};}
\DoxyCodeLine{2854     this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2855   \}}
\DoxyCodeLine{2856 }
\DoxyCodeLine{2857   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2858     *os << \textcolor{stringliteral}{"{}doesn't contain any element that "{}};}
\DoxyCodeLine{2859     this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2860   \}}
\DoxyCodeLine{2861 }
\DoxyCodeLine{2862   \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{2863                                \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2864     \textcolor{keywordflow}{return} this-\/>MatchAndExplainImpl(\textcolor{keyword}{false}, container, listener);}
\DoxyCodeLine{2865   \}}
\DoxyCodeLine{2866 }
\DoxyCodeLine{2867  \textcolor{keyword}{private}:}
\DoxyCodeLine{2868   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1ContainsMatcherImpl}{ContainsMatcherImpl}});}
\DoxyCodeLine{2869 \};}
\DoxyCodeLine{2870 }
\DoxyCodeLine{2871 \textcolor{comment}{// Implements Each(element\_matcher) for the given argument type Container.}}
\DoxyCodeLine{2872 \textcolor{comment}{// Symmetric to ContainsMatcherImpl.}}
\DoxyCodeLine{2873 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2874 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1EachMatcherImpl}{EachMatcherImpl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1QuantifierMatcherImpl}{QuantifierMatcherImpl}}<Container> \{}
\DoxyCodeLine{2875  \textcolor{keyword}{public}:}
\DoxyCodeLine{2876   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{2877   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1EachMatcherImpl}{EachMatcherImpl}}(InnerMatcher inner\_matcher)}
\DoxyCodeLine{2878       : \mbox{\hyperlink{classtesting_1_1internal_1_1QuantifierMatcherImpl}{QuantifierMatcherImpl<Container>}}(inner\_matcher) \{\}}
\DoxyCodeLine{2879 }
\DoxyCodeLine{2880   \textcolor{comment}{// Describes what this matcher does.}}
\DoxyCodeLine{2881   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2882     *os << \textcolor{stringliteral}{"{}only contains elements that "{}};}
\DoxyCodeLine{2883     this-\/>inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2884   \}}
\DoxyCodeLine{2885 }
\DoxyCodeLine{2886   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2887     *os << \textcolor{stringliteral}{"{}contains some element that "{}};}
\DoxyCodeLine{2888     this-\/>inner\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{2889   \}}
\DoxyCodeLine{2890 }
\DoxyCodeLine{2891   \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{2892                                \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2893     \textcolor{keywordflow}{return} this-\/>MatchAndExplainImpl(\textcolor{keyword}{true}, container, listener);}
\DoxyCodeLine{2894   \}}
\DoxyCodeLine{2895 }
\DoxyCodeLine{2896  \textcolor{keyword}{private}:}
\DoxyCodeLine{2897   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1EachMatcherImpl}{EachMatcherImpl}});}
\DoxyCodeLine{2898 \};}
\DoxyCodeLine{2899 }
\DoxyCodeLine{2900 \textcolor{comment}{// Implements polymorphic Contains(element\_matcher).}}
\DoxyCodeLine{2901 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{2902 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ContainsMatcher}{ContainsMatcher}} \{}
\DoxyCodeLine{2903  \textcolor{keyword}{public}:}
\DoxyCodeLine{2904   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ContainsMatcher}{ContainsMatcher}}(M m) : inner\_matcher\_(m) \{\}}
\DoxyCodeLine{2905 }
\DoxyCodeLine{2906   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2907   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<Container>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2908     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1ContainsMatcherImpl}{ContainsMatcherImpl<Container>}}(inner\_matcher\_));}
\DoxyCodeLine{2909   \}}
\DoxyCodeLine{2910 }
\DoxyCodeLine{2911  \textcolor{keyword}{private}:}
\DoxyCodeLine{2912   \textcolor{keyword}{const} M inner\_matcher\_;}
\DoxyCodeLine{2913 }
\DoxyCodeLine{2914   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1ContainsMatcher}{ContainsMatcher}});}
\DoxyCodeLine{2915 \};}
\DoxyCodeLine{2916 }
\DoxyCodeLine{2917 \textcolor{comment}{// Implements polymorphic Each(element\_matcher).}}
\DoxyCodeLine{2918 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{2919 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1EachMatcher}{EachMatcher}} \{}
\DoxyCodeLine{2920  \textcolor{keyword}{public}:}
\DoxyCodeLine{2921   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1EachMatcher}{EachMatcher}}(M m) : inner\_matcher\_(m) \{\}}
\DoxyCodeLine{2922 }
\DoxyCodeLine{2923   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{2924   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<Container>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2925     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1EachMatcherImpl}{EachMatcherImpl<Container>}}(inner\_matcher\_));}
\DoxyCodeLine{2926   \}}
\DoxyCodeLine{2927 }
\DoxyCodeLine{2928  \textcolor{keyword}{private}:}
\DoxyCodeLine{2929   \textcolor{keyword}{const} M inner\_matcher\_;}
\DoxyCodeLine{2930 }
\DoxyCodeLine{2931   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1EachMatcher}{EachMatcher}});}
\DoxyCodeLine{2932 \};}
\DoxyCodeLine{2933 }
\DoxyCodeLine{2934 \textcolor{comment}{// Implements Key(inner\_matcher) for the given argument pair type.}}
\DoxyCodeLine{2935 \textcolor{comment}{// Key(inner\_matcher) matches an std::pair whose 'first' field matches}}
\DoxyCodeLine{2936 \textcolor{comment}{// inner\_matcher.  For example, Contains(Key(Ge(5))) can be used to match an}}
\DoxyCodeLine{2937 \textcolor{comment}{// std::map that contains at least one element whose key is >= 5.}}
\DoxyCodeLine{2938 \textcolor{keyword}{template} <\textcolor{keyword}{typename} PairType>}
\DoxyCodeLine{2939 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1KeyMatcherImpl}{KeyMatcherImpl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<PairType> \{}
\DoxyCodeLine{2940  \textcolor{keyword}{public}:}
\DoxyCodeLine{2941   \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(PairType) RawPairType;}
\DoxyCodeLine{2942   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RawPairType::first\_type KeyType;}
\DoxyCodeLine{2943 }
\DoxyCodeLine{2944   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{2945   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1KeyMatcherImpl}{KeyMatcherImpl}}(InnerMatcher inner\_matcher)}
\DoxyCodeLine{2946       : inner\_matcher\_(}
\DoxyCodeLine{2947           testing::SafeMatcherCast<const KeyType\&>(inner\_matcher)) \{}
\DoxyCodeLine{2948   \}}
\DoxyCodeLine{2949 }
\DoxyCodeLine{2950   \textcolor{comment}{// Returns true iff 'key\_value.first' (the key) matches the inner matcher.}}
\DoxyCodeLine{2951   \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(PairType key\_value,}
\DoxyCodeLine{2952                                \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2953     \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} inner\_listener;}
\DoxyCodeLine{2954     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} match = inner\_matcher\_.MatchAndExplain(key\_value.first,}
\DoxyCodeLine{2955                                                       \&inner\_listener);}
\DoxyCodeLine{2956     \textcolor{keyword}{const} internal::string explanation = inner\_listener.str();}
\DoxyCodeLine{2957     \textcolor{keywordflow}{if} (explanation != \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{2958       *listener << \textcolor{stringliteral}{"{}whose first field is a value "{}} << explanation;}
\DoxyCodeLine{2959     \}}
\DoxyCodeLine{2960     \textcolor{keywordflow}{return} match;}
\DoxyCodeLine{2961   \}}
\DoxyCodeLine{2962 }
\DoxyCodeLine{2963   \textcolor{comment}{// Describes what this matcher does.}}
\DoxyCodeLine{2964   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2965     *os << \textcolor{stringliteral}{"{}has a key that "{}};}
\DoxyCodeLine{2966     inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2967   \}}
\DoxyCodeLine{2968 }
\DoxyCodeLine{2969   \textcolor{comment}{// Describes what the negation of this matcher does.}}
\DoxyCodeLine{2970   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2971     *os << \textcolor{stringliteral}{"{}doesn't have a key that "{}};}
\DoxyCodeLine{2972     inner\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{2973   \}}
\DoxyCodeLine{2974 }
\DoxyCodeLine{2975  \textcolor{keyword}{private}:}
\DoxyCodeLine{2976   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<const KeyType\&>}} inner\_matcher\_;}
\DoxyCodeLine{2977 }
\DoxyCodeLine{2978   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1KeyMatcherImpl}{KeyMatcherImpl}});}
\DoxyCodeLine{2979 \};}
\DoxyCodeLine{2980 }
\DoxyCodeLine{2981 \textcolor{comment}{// Implements polymorphic Key(matcher\_for\_key).}}
\DoxyCodeLine{2982 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{2983 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1KeyMatcher}{KeyMatcher}} \{}
\DoxyCodeLine{2984  \textcolor{keyword}{public}:}
\DoxyCodeLine{2985   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1KeyMatcher}{KeyMatcher}}(M m) : matcher\_for\_key\_(m) \{\}}
\DoxyCodeLine{2986 }
\DoxyCodeLine{2987   \textcolor{keyword}{template} <\textcolor{keyword}{typename} PairType>}
\DoxyCodeLine{2988   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<PairType>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2989     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1KeyMatcherImpl}{KeyMatcherImpl<PairType>}}(matcher\_for\_key\_));}
\DoxyCodeLine{2990   \}}
\DoxyCodeLine{2991 }
\DoxyCodeLine{2992  \textcolor{keyword}{private}:}
\DoxyCodeLine{2993   \textcolor{keyword}{const} M matcher\_for\_key\_;}
\DoxyCodeLine{2994 }
\DoxyCodeLine{2995   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1KeyMatcher}{KeyMatcher}});}
\DoxyCodeLine{2996 \};}
\DoxyCodeLine{2997 }
\DoxyCodeLine{2998 \textcolor{comment}{// Implements Pair(first\_matcher, second\_matcher) for the given argument pair}}
\DoxyCodeLine{2999 \textcolor{comment}{// type with its two matchers. See Pair() function below.}}
\DoxyCodeLine{3000 \textcolor{keyword}{template} <\textcolor{keyword}{typename} PairType>}
\DoxyCodeLine{3001 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1PairMatcherImpl}{PairMatcherImpl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<PairType> \{}
\DoxyCodeLine{3002  \textcolor{keyword}{public}:}
\DoxyCodeLine{3003   \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(PairType) RawPairType;}
\DoxyCodeLine{3004   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RawPairType::first\_type FirstType;}
\DoxyCodeLine{3005   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RawPairType::second\_type SecondType;}
\DoxyCodeLine{3006 }
\DoxyCodeLine{3007   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FirstMatcher, \textcolor{keyword}{typename} SecondMatcher>}
\DoxyCodeLine{3008   \mbox{\hyperlink{classtesting_1_1internal_1_1PairMatcherImpl}{PairMatcherImpl}}(FirstMatcher first\_matcher, SecondMatcher second\_matcher)}
\DoxyCodeLine{3009       : first\_matcher\_(}
\DoxyCodeLine{3010             testing::SafeMatcherCast<const FirstType\&>(first\_matcher)),}
\DoxyCodeLine{3011         second\_matcher\_(}
\DoxyCodeLine{3012             testing::SafeMatcherCast<const SecondType\&>(second\_matcher)) \{}
\DoxyCodeLine{3013   \}}
\DoxyCodeLine{3014 }
\DoxyCodeLine{3015   \textcolor{comment}{// Describes what this matcher does.}}
\DoxyCodeLine{3016   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3017     *os << \textcolor{stringliteral}{"{}has a first field that "{}};}
\DoxyCodeLine{3018     first\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{3019     *os << \textcolor{stringliteral}{"{}, and has a second field that "{}};}
\DoxyCodeLine{3020     second\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{3021   \}}
\DoxyCodeLine{3022 }
\DoxyCodeLine{3023   \textcolor{comment}{// Describes what the negation of this matcher does.}}
\DoxyCodeLine{3024   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3025     *os << \textcolor{stringliteral}{"{}has a first field that "{}};}
\DoxyCodeLine{3026     first\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{3027     *os << \textcolor{stringliteral}{"{}, or has a second field that "{}};}
\DoxyCodeLine{3028     second\_matcher\_.DescribeNegationTo(os);}
\DoxyCodeLine{3029   \}}
\DoxyCodeLine{3030 }
\DoxyCodeLine{3031   \textcolor{comment}{// Returns true iff 'a\_pair.first' matches first\_matcher and 'a\_pair.second'}}
\DoxyCodeLine{3032   \textcolor{comment}{// matches second\_matcher.}}
\DoxyCodeLine{3033   \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(PairType a\_pair,}
\DoxyCodeLine{3034                                \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3035     \textcolor{keywordflow}{if} (!listener-\/>IsInterested()) \{}
\DoxyCodeLine{3036       \textcolor{comment}{// If the listener is not interested, we don't need to construct the}}
\DoxyCodeLine{3037       \textcolor{comment}{// explanation.}}
\DoxyCodeLine{3038       \textcolor{keywordflow}{return} first\_matcher\_.Matches(a\_pair.first) \&\&}
\DoxyCodeLine{3039              second\_matcher\_.Matches(a\_pair.second);}
\DoxyCodeLine{3040     \}}
\DoxyCodeLine{3041     \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} first\_inner\_listener;}
\DoxyCodeLine{3042     \textcolor{keywordflow}{if} (!first\_matcher\_.MatchAndExplain(a\_pair.first,}
\DoxyCodeLine{3043                                         \&first\_inner\_listener)) \{}
\DoxyCodeLine{3044       *listener << \textcolor{stringliteral}{"{}whose first field does not match"{}};}
\DoxyCodeLine{3045       PrintIfNotEmpty(first\_inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{3046       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3047     \}}
\DoxyCodeLine{3048     \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} second\_inner\_listener;}
\DoxyCodeLine{3049     \textcolor{keywordflow}{if} (!second\_matcher\_.MatchAndExplain(a\_pair.second,}
\DoxyCodeLine{3050                                          \&second\_inner\_listener)) \{}
\DoxyCodeLine{3051       *listener << \textcolor{stringliteral}{"{}whose second field does not match"{}};}
\DoxyCodeLine{3052       PrintIfNotEmpty(second\_inner\_listener.str(), listener-\/>stream());}
\DoxyCodeLine{3053       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3054     \}}
\DoxyCodeLine{3055     ExplainSuccess(first\_inner\_listener.str(), second\_inner\_listener.str(),}
\DoxyCodeLine{3056                    listener);}
\DoxyCodeLine{3057     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3058   \}}
\DoxyCodeLine{3059 }
\DoxyCodeLine{3060  \textcolor{keyword}{private}:}
\DoxyCodeLine{3061   \textcolor{keywordtype}{void} ExplainSuccess(\textcolor{keyword}{const} internal::string\& first\_explanation,}
\DoxyCodeLine{3062                       \textcolor{keyword}{const} internal::string\& second\_explanation,}
\DoxyCodeLine{3063                       \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3064     *listener << \textcolor{stringliteral}{"{}whose both fields match"{}};}
\DoxyCodeLine{3065     \textcolor{keywordflow}{if} (first\_explanation != \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{3066       *listener << \textcolor{stringliteral}{"{}, where the first field is a value "{}} << first\_explanation;}
\DoxyCodeLine{3067     \}}
\DoxyCodeLine{3068     \textcolor{keywordflow}{if} (second\_explanation != \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{3069       *listener << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{3070       \textcolor{keywordflow}{if} (first\_explanation != \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{3071         *listener << \textcolor{stringliteral}{"{}and "{}};}
\DoxyCodeLine{3072       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3073         *listener << \textcolor{stringliteral}{"{}where "{}};}
\DoxyCodeLine{3074       \}}
\DoxyCodeLine{3075       *listener << \textcolor{stringliteral}{"{}the second field is a value "{}} << second\_explanation;}
\DoxyCodeLine{3076     \}}
\DoxyCodeLine{3077   \}}
\DoxyCodeLine{3078 }
\DoxyCodeLine{3079   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<const FirstType\&>}} first\_matcher\_;}
\DoxyCodeLine{3080   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<const SecondType\&>}} second\_matcher\_;}
\DoxyCodeLine{3081 }
\DoxyCodeLine{3082   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1PairMatcherImpl}{PairMatcherImpl}});}
\DoxyCodeLine{3083 \};}
\DoxyCodeLine{3084 }
\DoxyCodeLine{3085 \textcolor{comment}{// Implements polymorphic Pair(first\_matcher, second\_matcher).}}
\DoxyCodeLine{3086 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FirstMatcher, \textcolor{keyword}{typename} SecondMatcher>}
\DoxyCodeLine{3087 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1PairMatcher}{PairMatcher}} \{}
\DoxyCodeLine{3088  \textcolor{keyword}{public}:}
\DoxyCodeLine{3089   \mbox{\hyperlink{classtesting_1_1internal_1_1PairMatcher}{PairMatcher}}(FirstMatcher first\_matcher, SecondMatcher second\_matcher)}
\DoxyCodeLine{3090       : first\_matcher\_(first\_matcher), second\_matcher\_(second\_matcher) \{\}}
\DoxyCodeLine{3091 }
\DoxyCodeLine{3092   \textcolor{keyword}{template} <\textcolor{keyword}{typename} PairType>}
\DoxyCodeLine{3093   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<PairType>}} ()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3094     \textcolor{keywordflow}{return} MakeMatcher(}
\DoxyCodeLine{3095         \textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1PairMatcherImpl}{PairMatcherImpl<PairType>}}(}
\DoxyCodeLine{3096             first\_matcher\_, second\_matcher\_));}
\DoxyCodeLine{3097   \}}
\DoxyCodeLine{3098 }
\DoxyCodeLine{3099  \textcolor{keyword}{private}:}
\DoxyCodeLine{3100   \textcolor{keyword}{const} FirstMatcher first\_matcher\_;}
\DoxyCodeLine{3101   \textcolor{keyword}{const} SecondMatcher second\_matcher\_;}
\DoxyCodeLine{3102 }
\DoxyCodeLine{3103   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1PairMatcher}{PairMatcher}});}
\DoxyCodeLine{3104 \};}
\DoxyCodeLine{3105 }
\DoxyCodeLine{3106 \textcolor{comment}{// Implements ElementsAre() and ElementsAreArray().}}
\DoxyCodeLine{3107 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3108 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ElementsAreMatcherImpl}{ElementsAreMatcherImpl}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<Container> \{}
\DoxyCodeLine{3109  \textcolor{keyword}{public}:}
\DoxyCodeLine{3110   \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container) RawContainer;}
\DoxyCodeLine{3111   \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{internal::StlContainerView<RawContainer>}} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{View}};}
\DoxyCodeLine{3112   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::type StlContainer;}
\DoxyCodeLine{3113   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::const\_reference StlContainerReference;}
\DoxyCodeLine{3114   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} StlContainer::value\_type Element;}
\DoxyCodeLine{3115 }
\DoxyCodeLine{3116   \textcolor{comment}{// Constructs the matcher from a sequence of element values or}}
\DoxyCodeLine{3117   \textcolor{comment}{// element matchers.}}
\DoxyCodeLine{3118   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIter>}
\DoxyCodeLine{3119   \mbox{\hyperlink{classtesting_1_1internal_1_1ElementsAreMatcherImpl}{ElementsAreMatcherImpl}}(InputIter first, InputIter last) \{}
\DoxyCodeLine{3120     \textcolor{keywordflow}{while} (first != last) \{}
\DoxyCodeLine{3121       matchers\_.push\_back(MatcherCast<const Element\&>(*first++));}
\DoxyCodeLine{3122     \}}
\DoxyCodeLine{3123   \}}
\DoxyCodeLine{3124 }
\DoxyCodeLine{3125   \textcolor{comment}{// Describes what this matcher does.}}
\DoxyCodeLine{3126   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3127     \textcolor{keywordflow}{if} (count() == 0) \{}
\DoxyCodeLine{3128       *os << \textcolor{stringliteral}{"{}is empty"{}};}
\DoxyCodeLine{3129     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (count() == 1) \{}
\DoxyCodeLine{3130       *os << \textcolor{stringliteral}{"{}has 1 element that "{}};}
\DoxyCodeLine{3131       matchers\_[0].DescribeTo(os);}
\DoxyCodeLine{3132     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3133       *os << \textcolor{stringliteral}{"{}has "{}} << Elements(count()) << \textcolor{stringliteral}{"{} where\(\backslash\)n"{}};}
\DoxyCodeLine{3134       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i != count(); ++i) \{}
\DoxyCodeLine{3135         *os << \textcolor{stringliteral}{"{}element \#"{}} << i << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{3136         matchers\_[i].DescribeTo(os);}
\DoxyCodeLine{3137         \textcolor{keywordflow}{if} (i + 1 < count()) \{}
\DoxyCodeLine{3138           *os << \textcolor{stringliteral}{"{},\(\backslash\)n"{}};}
\DoxyCodeLine{3139         \}}
\DoxyCodeLine{3140       \}}
\DoxyCodeLine{3141     \}}
\DoxyCodeLine{3142   \}}
\DoxyCodeLine{3143 }
\DoxyCodeLine{3144   \textcolor{comment}{// Describes what the negation of this matcher does.}}
\DoxyCodeLine{3145   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3146     \textcolor{keywordflow}{if} (count() == 0) \{}
\DoxyCodeLine{3147       *os << \textcolor{stringliteral}{"{}isn't empty"{}};}
\DoxyCodeLine{3148       \textcolor{keywordflow}{return};}
\DoxyCodeLine{3149     \}}
\DoxyCodeLine{3150 }
\DoxyCodeLine{3151     *os << \textcolor{stringliteral}{"{}doesn't have "{}} << Elements(count()) << \textcolor{stringliteral}{"{}, or\(\backslash\)n"{}};}
\DoxyCodeLine{3152     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i != count(); ++i) \{}
\DoxyCodeLine{3153       *os << \textcolor{stringliteral}{"{}element \#"{}} << i << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{3154       matchers\_[i].DescribeNegationTo(os);}
\DoxyCodeLine{3155       \textcolor{keywordflow}{if} (i + 1 < count()) \{}
\DoxyCodeLine{3156         *os << \textcolor{stringliteral}{"{}, or\(\backslash\)n"{}};}
\DoxyCodeLine{3157       \}}
\DoxyCodeLine{3158     \}}
\DoxyCodeLine{3159   \}}
\DoxyCodeLine{3160 }
\DoxyCodeLine{3161   \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{3162                                \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3163     \textcolor{comment}{// To work with stream-\/like "{}containers"{}, we must only walk}}
\DoxyCodeLine{3164     \textcolor{comment}{// through the elements in one pass.}}
\DoxyCodeLine{3165 }
\DoxyCodeLine{3166     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} listener\_interested = listener-\/>IsInterested();}
\DoxyCodeLine{3167 }
\DoxyCodeLine{3168     \textcolor{comment}{// explanations[i] is the explanation of the element at index i.}}
\DoxyCodeLine{3169     ::std::vector<internal::string> explanations(count());}
\DoxyCodeLine{3170     StlContainerReference stl\_container = View::ConstReference(container);}
\DoxyCodeLine{3171     \textcolor{keyword}{typename} StlContainer::const\_iterator it = stl\_container.begin();}
\DoxyCodeLine{3172     \textcolor{keywordtype}{size\_t} exam\_pos = 0;}
\DoxyCodeLine{3173     \textcolor{keywordtype}{bool} mismatch\_found = \textcolor{keyword}{false};  \textcolor{comment}{// Have we found a mismatched element yet?}}
\DoxyCodeLine{3174 }
\DoxyCodeLine{3175     \textcolor{comment}{// Go through the elements and matchers in pairs, until we reach}}
\DoxyCodeLine{3176     \textcolor{comment}{// the end of either the elements or the matchers, or until we find a}}
\DoxyCodeLine{3177     \textcolor{comment}{// mismatch.}}
\DoxyCodeLine{3178     \textcolor{keywordflow}{for} (; it != stl\_container.end() \&\& exam\_pos != count(); ++it, ++exam\_pos) \{}
\DoxyCodeLine{3179       \textcolor{keywordtype}{bool} match;  \textcolor{comment}{// Does the current element match the current matcher?}}
\DoxyCodeLine{3180       \textcolor{keywordflow}{if} (listener\_interested) \{}
\DoxyCodeLine{3181         \mbox{\hyperlink{classtesting_1_1StringMatchResultListener}{StringMatchResultListener}} s;}
\DoxyCodeLine{3182         match = matchers\_[exam\_pos].MatchAndExplain(*it, \&s);}
\DoxyCodeLine{3183         explanations[exam\_pos] = s.str();}
\DoxyCodeLine{3184       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3185         match = matchers\_[exam\_pos].Matches(*it);}
\DoxyCodeLine{3186       \}}
\DoxyCodeLine{3187 }
\DoxyCodeLine{3188       \textcolor{keywordflow}{if} (!match) \{}
\DoxyCodeLine{3189         mismatch\_found = \textcolor{keyword}{true};}
\DoxyCodeLine{3190         \textcolor{keywordflow}{break};}
\DoxyCodeLine{3191       \}}
\DoxyCodeLine{3192     \}}
\DoxyCodeLine{3193     \textcolor{comment}{// If mismatch\_found is true, 'exam\_pos' is the index of the mismatch.}}
\DoxyCodeLine{3194 }
\DoxyCodeLine{3195     \textcolor{comment}{// Find how many elements the actual container has.  We avoid}}
\DoxyCodeLine{3196     \textcolor{comment}{// calling size() s.t. this code works for stream-\/like "{}containers"{}}}
\DoxyCodeLine{3197     \textcolor{comment}{// that don't define size().}}
\DoxyCodeLine{3198     \textcolor{keywordtype}{size\_t} actual\_count = exam\_pos;}
\DoxyCodeLine{3199     \textcolor{keywordflow}{for} (; it != stl\_container.end(); ++it) \{}
\DoxyCodeLine{3200       ++actual\_count;}
\DoxyCodeLine{3201     \}}
\DoxyCodeLine{3202 }
\DoxyCodeLine{3203     \textcolor{keywordflow}{if} (actual\_count != count()) \{}
\DoxyCodeLine{3204       \textcolor{comment}{// The element count doesn't match.  If the container is empty,}}
\DoxyCodeLine{3205       \textcolor{comment}{// there's no need to explain anything as Google Mock already}}
\DoxyCodeLine{3206       \textcolor{comment}{// prints the empty container.  Otherwise we just need to show}}
\DoxyCodeLine{3207       \textcolor{comment}{// how many elements there actually are.}}
\DoxyCodeLine{3208       \textcolor{keywordflow}{if} (listener\_interested \&\& (actual\_count != 0)) \{}
\DoxyCodeLine{3209         *listener << \textcolor{stringliteral}{"{}which has "{}} << Elements(actual\_count);}
\DoxyCodeLine{3210       \}}
\DoxyCodeLine{3211       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3212     \}}
\DoxyCodeLine{3213 }
\DoxyCodeLine{3214     \textcolor{keywordflow}{if} (mismatch\_found) \{}
\DoxyCodeLine{3215       \textcolor{comment}{// The element count matches, but the exam\_pos-\/th element doesn't match.}}
\DoxyCodeLine{3216       \textcolor{keywordflow}{if} (listener\_interested) \{}
\DoxyCodeLine{3217         *listener << \textcolor{stringliteral}{"{}whose element \#"{}} << exam\_pos << \textcolor{stringliteral}{"{} doesn't match"{}};}
\DoxyCodeLine{3218         PrintIfNotEmpty(explanations[exam\_pos], listener-\/>stream());}
\DoxyCodeLine{3219       \}}
\DoxyCodeLine{3220       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3221     \}}
\DoxyCodeLine{3222 }
\DoxyCodeLine{3223     \textcolor{comment}{// Every element matches its expectation.  We need to explain why}}
\DoxyCodeLine{3224     \textcolor{comment}{// (the obvious ones can be skipped).}}
\DoxyCodeLine{3225     \textcolor{keywordflow}{if} (listener\_interested) \{}
\DoxyCodeLine{3226       \textcolor{keywordtype}{bool} reason\_printed = \textcolor{keyword}{false};}
\DoxyCodeLine{3227       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i != count(); ++i) \{}
\DoxyCodeLine{3228         \textcolor{keyword}{const} internal::string\& s = explanations[i];}
\DoxyCodeLine{3229         \textcolor{keywordflow}{if} (!s.empty()) \{}
\DoxyCodeLine{3230           \textcolor{keywordflow}{if} (reason\_printed) \{}
\DoxyCodeLine{3231             *listener << \textcolor{stringliteral}{"{},\(\backslash\)nand "{}};}
\DoxyCodeLine{3232           \}}
\DoxyCodeLine{3233           *listener << \textcolor{stringliteral}{"{}whose element \#"{}} << i << \textcolor{stringliteral}{"{} matches, "{}} << s;}
\DoxyCodeLine{3234           reason\_printed = \textcolor{keyword}{true};}
\DoxyCodeLine{3235         \}}
\DoxyCodeLine{3236       \}}
\DoxyCodeLine{3237     \}}
\DoxyCodeLine{3238     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3239   \}}
\DoxyCodeLine{3240 }
\DoxyCodeLine{3241  \textcolor{keyword}{private}:}
\DoxyCodeLine{3242   \textcolor{keyword}{static} \mbox{\hyperlink{classtesting_1_1Message}{Message}} Elements(\textcolor{keywordtype}{size\_t} count) \{}
\DoxyCodeLine{3243     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Message}{Message}}() << count << (count == 1 ? \textcolor{stringliteral}{"{} element"{}} : \textcolor{stringliteral}{"{} elements"{}});}
\DoxyCodeLine{3244   \}}
\DoxyCodeLine{3245 }
\DoxyCodeLine{3246   \textcolor{keywordtype}{size\_t} count()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} matchers\_.size(); \}}
\DoxyCodeLine{3247 }
\DoxyCodeLine{3248   ::std::vector<Matcher<const Element\&> > matchers\_;}
\DoxyCodeLine{3249 }
\DoxyCodeLine{3250   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1ElementsAreMatcherImpl}{ElementsAreMatcherImpl}});}
\DoxyCodeLine{3251 \};}
\DoxyCodeLine{3252 }
\DoxyCodeLine{3253 \textcolor{comment}{// Connectivity matrix of (elements X matchers), in element-\/major order.}}
\DoxyCodeLine{3254 \textcolor{comment}{// Initially, there are no edges.}}
\DoxyCodeLine{3255 \textcolor{comment}{// Use NextGraph() to iterate over all possible edge configurations.}}
\DoxyCodeLine{3256 \textcolor{comment}{// Use Randomize() to generate a random edge configuration.}}
\DoxyCodeLine{3257 \textcolor{keyword}{class }GTEST\_API\_ \mbox{\hyperlink{classtesting_1_1internal_1_1MatchMatrix}{MatchMatrix}} \{}
\DoxyCodeLine{3258  \textcolor{keyword}{public}:}
\DoxyCodeLine{3259   \mbox{\hyperlink{classtesting_1_1internal_1_1MatchMatrix}{MatchMatrix}}(\textcolor{keywordtype}{size\_t} num\_elements, \textcolor{keywordtype}{size\_t} num\_matchers)}
\DoxyCodeLine{3260       : num\_elements\_(num\_elements),}
\DoxyCodeLine{3261         num\_matchers\_(num\_matchers),}
\DoxyCodeLine{3262         matched\_(num\_elements\_* num\_matchers\_, 0) \{}
\DoxyCodeLine{3263   \}}
\DoxyCodeLine{3264 }
\DoxyCodeLine{3265   \textcolor{keywordtype}{size\_t} LhsSize()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} num\_elements\_; \}}
\DoxyCodeLine{3266   \textcolor{keywordtype}{size\_t} RhsSize()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} num\_matchers\_; \}}
\DoxyCodeLine{3267   \textcolor{keywordtype}{bool} HasEdge(\textcolor{keywordtype}{size\_t} ilhs, \textcolor{keywordtype}{size\_t} irhs)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3268     \textcolor{keywordflow}{return} matched\_[SpaceIndex(ilhs, irhs)] == 1;}
\DoxyCodeLine{3269   \}}
\DoxyCodeLine{3270   \textcolor{keywordtype}{void} SetEdge(\textcolor{keywordtype}{size\_t} ilhs, \textcolor{keywordtype}{size\_t} irhs, \textcolor{keywordtype}{bool} b) \{}
\DoxyCodeLine{3271     matched\_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;}
\DoxyCodeLine{3272   \}}
\DoxyCodeLine{3273 }
\DoxyCodeLine{3274   \textcolor{comment}{// Treating the connectivity matrix as a (LhsSize()*RhsSize())-\/bit number,}}
\DoxyCodeLine{3275   \textcolor{comment}{// adds 1 to that number; returns false if incrementing the graph left it}}
\DoxyCodeLine{3276   \textcolor{comment}{// empty.}}
\DoxyCodeLine{3277   \textcolor{keywordtype}{bool} NextGraph();}
\DoxyCodeLine{3278 }
\DoxyCodeLine{3279   \textcolor{keywordtype}{void} Randomize();}
\DoxyCodeLine{3280 }
\DoxyCodeLine{3281   \textcolor{keywordtype}{string} DebugString() \textcolor{keyword}{const};}
\DoxyCodeLine{3282 }
\DoxyCodeLine{3283  \textcolor{keyword}{private}:}
\DoxyCodeLine{3284   \textcolor{keywordtype}{size\_t} SpaceIndex(\textcolor{keywordtype}{size\_t} ilhs, \textcolor{keywordtype}{size\_t} irhs)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3285     \textcolor{keywordflow}{return} ilhs * num\_matchers\_ + irhs;}
\DoxyCodeLine{3286   \}}
\DoxyCodeLine{3287 }
\DoxyCodeLine{3288   \textcolor{keywordtype}{size\_t} num\_elements\_;}
\DoxyCodeLine{3289   \textcolor{keywordtype}{size\_t} num\_matchers\_;}
\DoxyCodeLine{3290 }
\DoxyCodeLine{3291   \textcolor{comment}{// Each element is a char interpreted as bool. They are stored as a}}
\DoxyCodeLine{3292   \textcolor{comment}{// flattened array in lhs-\/major order, use 'SpaceIndex()' to translate}}
\DoxyCodeLine{3293   \textcolor{comment}{// a (ilhs, irhs) matrix coordinate into an offset.}}
\DoxyCodeLine{3294   ::std::vector<char> matched\_;}
\DoxyCodeLine{3295 \};}
\DoxyCodeLine{3296 }
\DoxyCodeLine{3297 typedef ::std::pair<size\_t, size\_t> ElementMatcherPair;}
\DoxyCodeLine{3298 typedef ::std::vector<ElementMatcherPair> ElementMatcherPairs;}
\DoxyCodeLine{3299 }
\DoxyCodeLine{3300 \textcolor{comment}{// Returns a maximum bipartite matching for the specified graph 'g'.}}
\DoxyCodeLine{3301 \textcolor{comment}{// The matching is represented as a vector of \{element, matcher\} pairs.}}
\DoxyCodeLine{3302 GTEST\_API\_ ElementMatcherPairs}
\DoxyCodeLine{3303 FindMaxBipartiteMatching(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1MatchMatrix}{MatchMatrix}}\& g);}
\DoxyCodeLine{3304 }
\DoxyCodeLine{3305 GTEST\_API\_ \textcolor{keywordtype}{bool} FindPairing(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1MatchMatrix}{MatchMatrix}}\& matrix,}
\DoxyCodeLine{3306                             \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener);}
\DoxyCodeLine{3307 }
\DoxyCodeLine{3308 \textcolor{comment}{// Untyped base class for implementing UnorderedElementsAre.  By}}
\DoxyCodeLine{3309 \textcolor{comment}{// putting logic that's not specific to the element type here, we}}
\DoxyCodeLine{3310 \textcolor{comment}{// reduce binary bloat and increase compilation speed.}}
\DoxyCodeLine{3311 \textcolor{keyword}{class }GTEST\_API\_ \mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreMatcherImplBase}{UnorderedElementsAreMatcherImplBase}} \{}
\DoxyCodeLine{3312  \textcolor{keyword}{protected}:}
\DoxyCodeLine{3313   \textcolor{comment}{// A vector of matcher describers, one for each element matcher.}}
\DoxyCodeLine{3314   \textcolor{comment}{// Does not own the describers (and thus can be used only when the}}
\DoxyCodeLine{3315   \textcolor{comment}{// element matchers are alive).}}
\DoxyCodeLine{3316   typedef ::std::vector<const MatcherDescriberInterface*> MatcherDescriberVec;}
\DoxyCodeLine{3317 }
\DoxyCodeLine{3318   \textcolor{comment}{// Describes this UnorderedElementsAre matcher.}}
\DoxyCodeLine{3319   \textcolor{keywordtype}{void} DescribeToImpl(::std::ostream* os) \textcolor{keyword}{const};}
\DoxyCodeLine{3320 }
\DoxyCodeLine{3321   \textcolor{comment}{// Describes the negation of this UnorderedElementsAre matcher.}}
\DoxyCodeLine{3322   \textcolor{keywordtype}{void} DescribeNegationToImpl(::std::ostream* os) \textcolor{keyword}{const};}
\DoxyCodeLine{3323 }
\DoxyCodeLine{3324   \textcolor{keywordtype}{bool} VerifyAllElementsAndMatchersAreMatched(}
\DoxyCodeLine{3325       const ::std::vector<string>\& element\_printouts,}
\DoxyCodeLine{3326       \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1MatchMatrix}{MatchMatrix}}\& matrix,}
\DoxyCodeLine{3327       \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener) \textcolor{keyword}{const};}
\DoxyCodeLine{3328 }
\DoxyCodeLine{3329   MatcherDescriberVec\& matcher\_describers() \{}
\DoxyCodeLine{3330     \textcolor{keywordflow}{return} matcher\_describers\_;}
\DoxyCodeLine{3331   \}}
\DoxyCodeLine{3332 }
\DoxyCodeLine{3333   \textcolor{keyword}{static} \mbox{\hyperlink{classtesting_1_1Message}{Message}} Elements(\textcolor{keywordtype}{size\_t} n) \{}
\DoxyCodeLine{3334     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Message}{Message}}() << n << \textcolor{stringliteral}{"{} element"{}} << (n == 1 ? \textcolor{stringliteral}{"{}"{}} : \textcolor{stringliteral}{"{}s"{}});}
\DoxyCodeLine{3335   \}}
\DoxyCodeLine{3336 }
\DoxyCodeLine{3337  \textcolor{keyword}{private}:}
\DoxyCodeLine{3338   MatcherDescriberVec matcher\_describers\_;}
\DoxyCodeLine{3339 }
\DoxyCodeLine{3340   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreMatcherImplBase}{UnorderedElementsAreMatcherImplBase}});}
\DoxyCodeLine{3341 \};}
\DoxyCodeLine{3342 }
\DoxyCodeLine{3343 \textcolor{comment}{// Implements unordered ElementsAre and unordered ElementsAreArray.}}
\DoxyCodeLine{3344 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3345 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreMatcherImpl}{UnorderedElementsAreMatcherImpl}}}
\DoxyCodeLine{3346     : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<Container>,}
\DoxyCodeLine{3347       \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreMatcherImplBase}{UnorderedElementsAreMatcherImplBase}} \{}
\DoxyCodeLine{3348  \textcolor{keyword}{public}:}
\DoxyCodeLine{3349   \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container) RawContainer;}
\DoxyCodeLine{3350   \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{internal::StlContainerView<RawContainer>}} \mbox{\hyperlink{classtesting_1_1internal_1_1StlContainerView}{View}};}
\DoxyCodeLine{3351   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::type StlContainer;}
\DoxyCodeLine{3352   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::const\_reference StlContainerReference;}
\DoxyCodeLine{3353   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} StlContainer::const\_iterator StlContainerConstIterator;}
\DoxyCodeLine{3354   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} StlContainer::value\_type Element;}
\DoxyCodeLine{3355 }
\DoxyCodeLine{3356   \textcolor{comment}{// Constructs the matcher from a sequence of element values or}}
\DoxyCodeLine{3357   \textcolor{comment}{// element matchers.}}
\DoxyCodeLine{3358   \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIter>}
\DoxyCodeLine{3359   \mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreMatcherImpl}{UnorderedElementsAreMatcherImpl}}(InputIter first, InputIter last) \{}
\DoxyCodeLine{3360     \textcolor{keywordflow}{for} (; first != last; ++first) \{}
\DoxyCodeLine{3361       matchers\_.push\_back(MatcherCast<const Element\&>(*first));}
\DoxyCodeLine{3362       matcher\_describers().push\_back(matchers\_.back().GetDescriber());}
\DoxyCodeLine{3363     \}}
\DoxyCodeLine{3364   \}}
\DoxyCodeLine{3365 }
\DoxyCodeLine{3366   \textcolor{comment}{// Describes what this matcher does.}}
\DoxyCodeLine{3367   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3368     \textcolor{keywordflow}{return} UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);}
\DoxyCodeLine{3369   \}}
\DoxyCodeLine{3370 }
\DoxyCodeLine{3371   \textcolor{comment}{// Describes what the negation of this matcher does.}}
\DoxyCodeLine{3372   \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeNegationTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3373     \textcolor{keywordflow}{return} UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);}
\DoxyCodeLine{3374   \}}
\DoxyCodeLine{3375 }
\DoxyCodeLine{3376   \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(Container container,}
\DoxyCodeLine{3377                                \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3378     StlContainerReference stl\_container = View::ConstReference(container);}
\DoxyCodeLine{3379     ::std::vector<string> element\_printouts;}
\DoxyCodeLine{3380     \mbox{\hyperlink{classtesting_1_1internal_1_1MatchMatrix}{MatchMatrix}} matrix = AnalyzeElements(stl\_container.begin(),}
\DoxyCodeLine{3381                                          stl\_container.end(),}
\DoxyCodeLine{3382                                          \&element\_printouts,}
\DoxyCodeLine{3383                                          listener);}
\DoxyCodeLine{3384 }
\DoxyCodeLine{3385     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} actual\_count = matrix.LhsSize();}
\DoxyCodeLine{3386     \textcolor{keywordflow}{if} (actual\_count == 0 \&\& matchers\_.empty()) \{}
\DoxyCodeLine{3387       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3388     \}}
\DoxyCodeLine{3389     \textcolor{keywordflow}{if} (actual\_count != matchers\_.size()) \{}
\DoxyCodeLine{3390       \textcolor{comment}{// The element count doesn't match.  If the container is empty,}}
\DoxyCodeLine{3391       \textcolor{comment}{// there's no need to explain anything as Google Mock already}}
\DoxyCodeLine{3392       \textcolor{comment}{// prints the empty container. Otherwise we just need to show}}
\DoxyCodeLine{3393       \textcolor{comment}{// how many elements there actually are.}}
\DoxyCodeLine{3394       \textcolor{keywordflow}{if} (actual\_count != 0 \&\& listener-\/>IsInterested()) \{}
\DoxyCodeLine{3395         *listener << \textcolor{stringliteral}{"{}which has "{}} << Elements(actual\_count);}
\DoxyCodeLine{3396       \}}
\DoxyCodeLine{3397       \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3398     \}}
\DoxyCodeLine{3399 }
\DoxyCodeLine{3400     \textcolor{keywordflow}{return} VerifyAllElementsAndMatchersAreMatched(element\_printouts,}
\DoxyCodeLine{3401                                                   matrix, listener) \&\&}
\DoxyCodeLine{3402            FindPairing(matrix, listener);}
\DoxyCodeLine{3403   \}}
\DoxyCodeLine{3404 }
\DoxyCodeLine{3405  \textcolor{keyword}{private}:}
\DoxyCodeLine{3406   typedef ::std::vector<Matcher<const Element\&> > MatcherVec;}
\DoxyCodeLine{3407 }
\DoxyCodeLine{3408   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ElementIter>}
\DoxyCodeLine{3409   \mbox{\hyperlink{classtesting_1_1internal_1_1MatchMatrix}{MatchMatrix}} AnalyzeElements(ElementIter elem\_first, ElementIter elem\_last,}
\DoxyCodeLine{3410                               ::std::vector<string>* element\_printouts,}
\DoxyCodeLine{3411                               \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3412     element\_printouts-\/>clear();}
\DoxyCodeLine{3413     ::std::vector<char> did\_match;}
\DoxyCodeLine{3414     \textcolor{keywordtype}{size\_t} num\_elements = 0;}
\DoxyCodeLine{3415     \textcolor{keywordflow}{for} (; elem\_first != elem\_last; ++num\_elements, ++elem\_first) \{}
\DoxyCodeLine{3416       \textcolor{keywordflow}{if} (listener-\/>IsInterested()) \{}
\DoxyCodeLine{3417         element\_printouts-\/>push\_back(PrintToString(*elem\_first));}
\DoxyCodeLine{3418       \}}
\DoxyCodeLine{3419       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} irhs = 0; irhs != matchers\_.size(); ++irhs) \{}
\DoxyCodeLine{3420         did\_match.push\_back(Matches(matchers\_[irhs])(*elem\_first));}
\DoxyCodeLine{3421       \}}
\DoxyCodeLine{3422     \}}
\DoxyCodeLine{3423 }
\DoxyCodeLine{3424     \mbox{\hyperlink{classtesting_1_1internal_1_1MatchMatrix}{MatchMatrix}} matrix(num\_elements, matchers\_.size());}
\DoxyCodeLine{3425     ::std::vector<char>::const\_iterator did\_match\_iter = did\_match.begin();}
\DoxyCodeLine{3426     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} ilhs = 0; ilhs != num\_elements; ++ilhs) \{}
\DoxyCodeLine{3427       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} irhs = 0; irhs != matchers\_.size(); ++irhs) \{}
\DoxyCodeLine{3428         matrix.SetEdge(ilhs, irhs, *did\_match\_iter++ != 0);}
\DoxyCodeLine{3429       \}}
\DoxyCodeLine{3430     \}}
\DoxyCodeLine{3431     \textcolor{keywordflow}{return} matrix;}
\DoxyCodeLine{3432   \}}
\DoxyCodeLine{3433 }
\DoxyCodeLine{3434   MatcherVec matchers\_;}
\DoxyCodeLine{3435 }
\DoxyCodeLine{3436   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreMatcherImpl}{UnorderedElementsAreMatcherImpl}});}
\DoxyCodeLine{3437 \};}
\DoxyCodeLine{3438 }
\DoxyCodeLine{3439 \textcolor{comment}{// Functor for use in TransformTuple.}}
\DoxyCodeLine{3440 \textcolor{comment}{// Performs MatcherCast<Target> on an input argument of any type.}}
\DoxyCodeLine{3441 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Target>}
\DoxyCodeLine{3442 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1CastAndAppendTransform}{CastAndAppendTransform}} \{}
\DoxyCodeLine{3443   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Arg>}
\DoxyCodeLine{3444   \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<Target>}} operator()(\textcolor{keyword}{const} Arg\& a)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3445     \textcolor{keywordflow}{return} MatcherCast<Target>(a);}
\DoxyCodeLine{3446   \}}
\DoxyCodeLine{3447 \};}
\DoxyCodeLine{3448 }
\DoxyCodeLine{3449 \textcolor{comment}{// Implements UnorderedElementsAre.}}
\DoxyCodeLine{3450 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple>}
\DoxyCodeLine{3451 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreMatcher}{UnorderedElementsAreMatcher}} \{}
\DoxyCodeLine{3452  \textcolor{keyword}{public}:}
\DoxyCodeLine{3453   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreMatcher}{UnorderedElementsAreMatcher}}(\textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1MatcherTuple}{MatcherTuple}}\& args)}
\DoxyCodeLine{3454       : matchers\_(args) \{\}}
\DoxyCodeLine{3455 }
\DoxyCodeLine{3456   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3457   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<Container>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3458     \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container) RawContainer;}
\DoxyCodeLine{3459     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::StlContainerView<RawContainer>::type View;}
\DoxyCodeLine{3460     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::value\_type Element;}
\DoxyCodeLine{3461     typedef ::std::vector<Matcher<const Element\&> > MatcherVec;}
\DoxyCodeLine{3462     MatcherVec matchers;}
\DoxyCodeLine{3463     matchers.reserve(::testing::tuple\_size<MatcherTuple>::value);}
\DoxyCodeLine{3464     TransformTupleValues(\mbox{\hyperlink{structtesting_1_1internal_1_1CastAndAppendTransform}{CastAndAppendTransform<const Element\&>}}(), matchers\_,}
\DoxyCodeLine{3465                          ::std::back\_inserter(matchers));}
\DoxyCodeLine{3466     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreMatcherImpl}{UnorderedElementsAreMatcherImpl<Container>}}(}
\DoxyCodeLine{3467                            matchers.begin(), matchers.end()));}
\DoxyCodeLine{3468   \}}
\DoxyCodeLine{3469 }
\DoxyCodeLine{3470  \textcolor{keyword}{private}:}
\DoxyCodeLine{3471   \textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1MatcherTuple}{MatcherTuple}} matchers\_;}
\DoxyCodeLine{3472   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreMatcher}{UnorderedElementsAreMatcher}});}
\DoxyCodeLine{3473 \};}
\DoxyCodeLine{3474 }
\DoxyCodeLine{3475 \textcolor{comment}{// Implements ElementsAre.}}
\DoxyCodeLine{3476 \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatcherTuple>}
\DoxyCodeLine{3477 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ElementsAreMatcher}{ElementsAreMatcher}} \{}
\DoxyCodeLine{3478  \textcolor{keyword}{public}:}
\DoxyCodeLine{3479   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ElementsAreMatcher}{ElementsAreMatcher}}(\textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1MatcherTuple}{MatcherTuple}}\& args) : matchers\_(args) \{\}}
\DoxyCodeLine{3480 }
\DoxyCodeLine{3481   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3482   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<Container>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3483     \textcolor{keyword}{typedef} GTEST\_REMOVE\_REFERENCE\_AND\_CONST\_(Container) RawContainer;}
\DoxyCodeLine{3484     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::StlContainerView<RawContainer>::type View;}
\DoxyCodeLine{3485     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} View::value\_type Element;}
\DoxyCodeLine{3486     typedef ::std::vector<Matcher<const Element\&> > MatcherVec;}
\DoxyCodeLine{3487     MatcherVec matchers;}
\DoxyCodeLine{3488     matchers.reserve(::testing::tuple\_size<MatcherTuple>::value);}
\DoxyCodeLine{3489     TransformTupleValues(\mbox{\hyperlink{structtesting_1_1internal_1_1CastAndAppendTransform}{CastAndAppendTransform<const Element\&>}}(), matchers\_,}
\DoxyCodeLine{3490                          ::std::back\_inserter(matchers));}
\DoxyCodeLine{3491     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1ElementsAreMatcherImpl}{ElementsAreMatcherImpl<Container>}}(}
\DoxyCodeLine{3492                            matchers.begin(), matchers.end()));}
\DoxyCodeLine{3493   \}}
\DoxyCodeLine{3494 }
\DoxyCodeLine{3495  \textcolor{keyword}{private}:}
\DoxyCodeLine{3496   \textcolor{keyword}{const} \mbox{\hyperlink{structtesting_1_1internal_1_1MatcherTuple}{MatcherTuple}} matchers\_;}
\DoxyCodeLine{3497   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1ElementsAreMatcher}{ElementsAreMatcher}});}
\DoxyCodeLine{3498 \};}
\DoxyCodeLine{3499 }
\DoxyCodeLine{3500 \textcolor{comment}{// Implements UnorderedElementsAreArray().}}
\DoxyCodeLine{3501 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3502 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreArrayMatcher}{UnorderedElementsAreArrayMatcher}} \{}
\DoxyCodeLine{3503  \textcolor{keyword}{public}:}
\DoxyCodeLine{3504   \mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreArrayMatcher}{UnorderedElementsAreArrayMatcher}}() \{\}}
\DoxyCodeLine{3505 }
\DoxyCodeLine{3506   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{3507   \mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreArrayMatcher}{UnorderedElementsAreArrayMatcher}}(Iter first, Iter last)}
\DoxyCodeLine{3508       : matchers\_(first, last) \{\}}
\DoxyCodeLine{3509 }
\DoxyCodeLine{3510   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3511   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<Container>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3512     \textcolor{keywordflow}{return} MakeMatcher(}
\DoxyCodeLine{3513         \textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreMatcherImpl}{UnorderedElementsAreMatcherImpl<Container>}}(matchers\_.begin(),}
\DoxyCodeLine{3514                                                        matchers\_.end()));}
\DoxyCodeLine{3515   \}}
\DoxyCodeLine{3516 }
\DoxyCodeLine{3517  \textcolor{keyword}{private}:}
\DoxyCodeLine{3518   ::std::vector<T> matchers\_;}
\DoxyCodeLine{3519 }
\DoxyCodeLine{3520   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1UnorderedElementsAreArrayMatcher}{UnorderedElementsAreArrayMatcher}});}
\DoxyCodeLine{3521 \};}
\DoxyCodeLine{3522 }
\DoxyCodeLine{3523 \textcolor{comment}{// Implements ElementsAreArray().}}
\DoxyCodeLine{3524 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3525 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ElementsAreArrayMatcher}{ElementsAreArrayMatcher}} \{}
\DoxyCodeLine{3526  \textcolor{keyword}{public}:}
\DoxyCodeLine{3527   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{3528   \mbox{\hyperlink{classtesting_1_1internal_1_1ElementsAreArrayMatcher}{ElementsAreArrayMatcher}}(Iter first, Iter last) : matchers\_(first, last) \{\}}
\DoxyCodeLine{3529 }
\DoxyCodeLine{3530   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3531   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<Container>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3532     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} \mbox{\hyperlink{classtesting_1_1internal_1_1ElementsAreMatcherImpl}{ElementsAreMatcherImpl<Container>}}(}
\DoxyCodeLine{3533         matchers\_.begin(), matchers\_.end()));}
\DoxyCodeLine{3534   \}}
\DoxyCodeLine{3535 }
\DoxyCodeLine{3536  \textcolor{keyword}{private}:}
\DoxyCodeLine{3537   const ::std::vector<T> matchers\_;}
\DoxyCodeLine{3538 }
\DoxyCodeLine{3539   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1ElementsAreArrayMatcher}{ElementsAreArrayMatcher}});}
\DoxyCodeLine{3540 \};}
\DoxyCodeLine{3541 }
\DoxyCodeLine{3542 \textcolor{comment}{// Given a 2-\/tuple matcher tm of type Tuple2Matcher and a value second}}
\DoxyCodeLine{3543 \textcolor{comment}{// of type Second, BoundSecondMatcher<Tuple2Matcher, Second>(tm,}}
\DoxyCodeLine{3544 \textcolor{comment}{// second) is a polymorphic matcher that matches a value x iff tm}}
\DoxyCodeLine{3545 \textcolor{comment}{// matches tuple (x, second).  Useful for implementing}}
\DoxyCodeLine{3546 \textcolor{comment}{// UnorderedPointwise() in terms of UnorderedElementsAreArray().}}
\DoxyCodeLine{3547 \textcolor{comment}{//}}
\DoxyCodeLine{3548 \textcolor{comment}{// BoundSecondMatcher is copyable and assignable, as we need to put}}
\DoxyCodeLine{3549 \textcolor{comment}{// instances of this class in a vector when implementing}}
\DoxyCodeLine{3550 \textcolor{comment}{// UnorderedPointwise().}}
\DoxyCodeLine{3551 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple2Matcher, \textcolor{keyword}{typename} Second>}
\DoxyCodeLine{3552 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1BoundSecondMatcher}{BoundSecondMatcher}} \{}
\DoxyCodeLine{3553  \textcolor{keyword}{public}:}
\DoxyCodeLine{3554   \mbox{\hyperlink{classtesting_1_1internal_1_1BoundSecondMatcher}{BoundSecondMatcher}}(\textcolor{keyword}{const} Tuple2Matcher\& tm, \textcolor{keyword}{const} Second\& second)}
\DoxyCodeLine{3555       : tuple2\_matcher\_(tm), second\_value\_(second) \{\}}
\DoxyCodeLine{3556 }
\DoxyCodeLine{3557   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3558   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<T>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3559     \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} Impl<T>(tuple2\_matcher\_, second\_value\_));}
\DoxyCodeLine{3560   \}}
\DoxyCodeLine{3561 }
\DoxyCodeLine{3562   \textcolor{comment}{// We have to define this for UnorderedPointwise() to compile in}}
\DoxyCodeLine{3563   \textcolor{comment}{// C++98 mode, as it puts BoundSecondMatcher instances in a vector,}}
\DoxyCodeLine{3564   \textcolor{comment}{// which requires the elements to be assignable in C++98.  The}}
\DoxyCodeLine{3565   \textcolor{comment}{// compiler cannot generate the operator= for us, as Tuple2Matcher}}
\DoxyCodeLine{3566   \textcolor{comment}{// and Second may not be assignable.}}
\DoxyCodeLine{3567   \textcolor{comment}{//}}
\DoxyCodeLine{3568   \textcolor{comment}{// However, this should never be called, so the implementation just}}
\DoxyCodeLine{3569   \textcolor{comment}{// need to assert.}}
\DoxyCodeLine{3570   \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1BoundSecondMatcher}{BoundSecondMatcher}}\& \textcolor{comment}{/*rhs*/}) \{}
\DoxyCodeLine{3571     GTEST\_LOG\_(FATAL) << \textcolor{stringliteral}{"{}BoundSecondMatcher should never be assigned."{}};}
\DoxyCodeLine{3572   \}}
\DoxyCodeLine{3573 }
\DoxyCodeLine{3574  \textcolor{keyword}{private}:}
\DoxyCodeLine{3575   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3576   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1MatcherInterface}{MatcherInterface}}<T> \{}
\DoxyCodeLine{3577    \textcolor{keyword}{public}:}
\DoxyCodeLine{3578     typedef ::testing::tuple<T, Second> ArgTuple;}
\DoxyCodeLine{3579 }
\DoxyCodeLine{3580     Impl(\textcolor{keyword}{const} Tuple2Matcher\& tm, \textcolor{keyword}{const} Second\& second)}
\DoxyCodeLine{3581         : mono\_tuple2\_matcher\_(SafeMatcherCast<const ArgTuple\&>(tm)),}
\DoxyCodeLine{3582           second\_value\_(second) \{\}}
\DoxyCodeLine{3583 }
\DoxyCodeLine{3584     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} DescribeTo(::std::ostream* os)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3585       *os << \textcolor{stringliteral}{"{}and "{}};}
\DoxyCodeLine{3586       UniversalPrint(second\_value\_, os);}
\DoxyCodeLine{3587       *os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{3588       mono\_tuple2\_matcher\_.DescribeTo(os);}
\DoxyCodeLine{3589     \}}
\DoxyCodeLine{3590 }
\DoxyCodeLine{3591     \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} MatchAndExplain(T x, \mbox{\hyperlink{classtesting_1_1MatchResultListener}{MatchResultListener}}* listener)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3592       \textcolor{keywordflow}{return} mono\_tuple2\_matcher\_.MatchAndExplain(ArgTuple(x, second\_value\_),}
\DoxyCodeLine{3593                                                   listener);}
\DoxyCodeLine{3594     \}}
\DoxyCodeLine{3595 }
\DoxyCodeLine{3596    \textcolor{keyword}{private}:}
\DoxyCodeLine{3597     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Matcher}{Matcher<const ArgTuple\&>}} mono\_tuple2\_matcher\_;}
\DoxyCodeLine{3598     \textcolor{keyword}{const} Second second\_value\_;}
\DoxyCodeLine{3599 }
\DoxyCodeLine{3600     GTEST\_DISALLOW\_ASSIGN\_(Impl);}
\DoxyCodeLine{3601   \};}
\DoxyCodeLine{3602 }
\DoxyCodeLine{3603   \textcolor{keyword}{const} Tuple2Matcher tuple2\_matcher\_;}
\DoxyCodeLine{3604   \textcolor{keyword}{const} Second second\_value\_;}
\DoxyCodeLine{3605 \};}
\DoxyCodeLine{3606 }
\DoxyCodeLine{3607 \textcolor{comment}{// Given a 2-\/tuple matcher tm and a value second,}}
\DoxyCodeLine{3608 \textcolor{comment}{// MatcherBindSecond(tm, second) returns a matcher that matches a}}
\DoxyCodeLine{3609 \textcolor{comment}{// value x iff tm matches tuple (x, second).  Useful for implementing}}
\DoxyCodeLine{3610 \textcolor{comment}{// UnorderedPointwise() in terms of UnorderedElementsAreArray().}}
\DoxyCodeLine{3611 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple2Matcher, \textcolor{keyword}{typename} Second>}
\DoxyCodeLine{3612 \mbox{\hyperlink{classtesting_1_1internal_1_1BoundSecondMatcher}{BoundSecondMatcher<Tuple2Matcher, Second>}} MatcherBindSecond(}
\DoxyCodeLine{3613     \textcolor{keyword}{const} Tuple2Matcher\& tm, \textcolor{keyword}{const} Second\& second) \{}
\DoxyCodeLine{3614   \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1BoundSecondMatcher}{BoundSecondMatcher<Tuple2Matcher, Second>}}(tm, second);}
\DoxyCodeLine{3615 \}}
\DoxyCodeLine{3616 }
\DoxyCodeLine{3617 \textcolor{comment}{// Returns the description for a matcher defined using the MATCHER*()}}
\DoxyCodeLine{3618 \textcolor{comment}{// macro where the user-\/supplied description string is "{}"{}, if}}
\DoxyCodeLine{3619 \textcolor{comment}{// 'negation' is false; otherwise returns the description of the}}
\DoxyCodeLine{3620 \textcolor{comment}{// negation of the matcher.  'param\_values' contains a list of strings}}
\DoxyCodeLine{3621 \textcolor{comment}{// that are the print-\/out of the matcher's parameters.}}
\DoxyCodeLine{3622 GTEST\_API\_ \textcolor{keywordtype}{string} FormatMatcherDescription(\textcolor{keywordtype}{bool} negation,}
\DoxyCodeLine{3623                                            \textcolor{keyword}{const} \textcolor{keywordtype}{char}* matcher\_name,}
\DoxyCodeLine{3624                                            \textcolor{keyword}{const} Strings\& param\_values);}
\DoxyCodeLine{3625 }
\DoxyCodeLine{3626 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{3627 }
\DoxyCodeLine{3628 \textcolor{comment}{// ElementsAreArray(first, last)}}
\DoxyCodeLine{3629 \textcolor{comment}{// ElementsAreArray(pointer, count)}}
\DoxyCodeLine{3630 \textcolor{comment}{// ElementsAreArray(array)}}
\DoxyCodeLine{3631 \textcolor{comment}{// ElementsAreArray(container)}}
\DoxyCodeLine{3632 \textcolor{comment}{// ElementsAreArray(\{ e1, e2, ..., en \})}}
\DoxyCodeLine{3633 \textcolor{comment}{//}}
\DoxyCodeLine{3634 \textcolor{comment}{// The ElementsAreArray() functions are like ElementsAre(...), except}}
\DoxyCodeLine{3635 \textcolor{comment}{// that they are given a homogeneous sequence rather than taking each}}
\DoxyCodeLine{3636 \textcolor{comment}{// element as a function argument. The sequence can be specified as an}}
\DoxyCodeLine{3637 \textcolor{comment}{// array, a pointer and count, a vector, an initializer list, or an}}
\DoxyCodeLine{3638 \textcolor{comment}{// STL iterator range. In each of these cases, the underlying sequence}}
\DoxyCodeLine{3639 \textcolor{comment}{// can be either a sequence of values or a sequence of matchers.}}
\DoxyCodeLine{3640 \textcolor{comment}{//}}
\DoxyCodeLine{3641 \textcolor{comment}{// All forms of ElementsAreArray() make a copy of the input matcher sequence.}}
\DoxyCodeLine{3642 }
\DoxyCodeLine{3643 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{3644 \textcolor{keyword}{inline} internal::ElementsAreArrayMatcher<}
\DoxyCodeLine{3645     typename ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{3646 ElementsAreArray(Iter first, Iter last) \{}
\DoxyCodeLine{3647   \textcolor{keyword}{typedef} typename ::std::iterator\_traits<Iter>::value\_type T;}
\DoxyCodeLine{3648   \textcolor{keywordflow}{return} internal::ElementsAreArrayMatcher<T>(first, last);}
\DoxyCodeLine{3649 \}}
\DoxyCodeLine{3650 }
\DoxyCodeLine{3651 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3652 \textcolor{keyword}{inline} internal::ElementsAreArrayMatcher<T> ElementsAreArray(}
\DoxyCodeLine{3653     \textcolor{keyword}{const} T* pointer, \textcolor{keywordtype}{size\_t} count) \{}
\DoxyCodeLine{3654   \textcolor{keywordflow}{return} ElementsAreArray(pointer, pointer + count);}
\DoxyCodeLine{3655 \}}
\DoxyCodeLine{3656 }
\DoxyCodeLine{3657 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{3658 \textcolor{keyword}{inline} internal::ElementsAreArrayMatcher<T> ElementsAreArray(}
\DoxyCodeLine{3659     \textcolor{keyword}{const} T (\&array)[N]) \{}
\DoxyCodeLine{3660   \textcolor{keywordflow}{return} ElementsAreArray(array, N);}
\DoxyCodeLine{3661 \}}
\DoxyCodeLine{3662 }
\DoxyCodeLine{3663 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3664 \textcolor{keyword}{inline} internal::ElementsAreArrayMatcher<typename Container::value\_type>}
\DoxyCodeLine{3665 ElementsAreArray(\textcolor{keyword}{const} Container\& container) \{}
\DoxyCodeLine{3666   \textcolor{keywordflow}{return} ElementsAreArray(container.begin(), container.end());}
\DoxyCodeLine{3667 \}}
\DoxyCodeLine{3668 }
\DoxyCodeLine{3669 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_INITIALIZER\_LIST\_}}
\DoxyCodeLine{3670 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3671 \textcolor{keyword}{inline} internal::ElementsAreArrayMatcher<T>}
\DoxyCodeLine{3672 ElementsAreArray(::std::initializer\_list<T> xs) \{}
\DoxyCodeLine{3673   \textcolor{keywordflow}{return} ElementsAreArray(xs.begin(), xs.end());}
\DoxyCodeLine{3674 \}}
\DoxyCodeLine{3675 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3676 }
\DoxyCodeLine{3677 \textcolor{comment}{// UnorderedElementsAreArray(first, last)}}
\DoxyCodeLine{3678 \textcolor{comment}{// UnorderedElementsAreArray(pointer, count)}}
\DoxyCodeLine{3679 \textcolor{comment}{// UnorderedElementsAreArray(array)}}
\DoxyCodeLine{3680 \textcolor{comment}{// UnorderedElementsAreArray(container)}}
\DoxyCodeLine{3681 \textcolor{comment}{// UnorderedElementsAreArray(\{ e1, e2, ..., en \})}}
\DoxyCodeLine{3682 \textcolor{comment}{//}}
\DoxyCodeLine{3683 \textcolor{comment}{// The UnorderedElementsAreArray() functions are like}}
\DoxyCodeLine{3684 \textcolor{comment}{// ElementsAreArray(...), but allow matching the elements in any order.}}
\DoxyCodeLine{3685 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iter>}
\DoxyCodeLine{3686 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{3687     typename ::std::iterator\_traits<Iter>::value\_type>}
\DoxyCodeLine{3688 UnorderedElementsAreArray(Iter first, Iter last) \{}
\DoxyCodeLine{3689   \textcolor{keyword}{typedef} typename ::std::iterator\_traits<Iter>::value\_type T;}
\DoxyCodeLine{3690   \textcolor{keywordflow}{return} internal::UnorderedElementsAreArrayMatcher<T>(first, last);}
\DoxyCodeLine{3691 \}}
\DoxyCodeLine{3692 }
\DoxyCodeLine{3693 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3694 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<T>}
\DoxyCodeLine{3695 UnorderedElementsAreArray(\textcolor{keyword}{const} T* pointer, \textcolor{keywordtype}{size\_t} count) \{}
\DoxyCodeLine{3696   \textcolor{keywordflow}{return} UnorderedElementsAreArray(pointer, pointer + count);}
\DoxyCodeLine{3697 \}}
\DoxyCodeLine{3698 }
\DoxyCodeLine{3699 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{3700 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<T>}
\DoxyCodeLine{3701 UnorderedElementsAreArray(\textcolor{keyword}{const} T (\&array)[N]) \{}
\DoxyCodeLine{3702   \textcolor{keywordflow}{return} UnorderedElementsAreArray(array, N);}
\DoxyCodeLine{3703 \}}
\DoxyCodeLine{3704 }
\DoxyCodeLine{3705 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{3706 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{3707     \textcolor{keyword}{typename} Container::value\_type>}
\DoxyCodeLine{3708 UnorderedElementsAreArray(\textcolor{keyword}{const} Container\& container) \{}
\DoxyCodeLine{3709   \textcolor{keywordflow}{return} UnorderedElementsAreArray(container.begin(), container.end());}
\DoxyCodeLine{3710 \}}
\DoxyCodeLine{3711 }
\DoxyCodeLine{3712 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_INITIALIZER\_LIST\_}}
\DoxyCodeLine{3713 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3714 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<T>}
\DoxyCodeLine{3715 UnorderedElementsAreArray(::std::initializer\_list<T> xs) \{}
\DoxyCodeLine{3716   \textcolor{keywordflow}{return} UnorderedElementsAreArray(xs.begin(), xs.end());}
\DoxyCodeLine{3717 \}}
\DoxyCodeLine{3718 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3719 }
\DoxyCodeLine{3720 \textcolor{comment}{// \_ is a matcher that matches anything of any type.}}
\DoxyCodeLine{3721 \textcolor{comment}{//}}
\DoxyCodeLine{3722 \textcolor{comment}{// This definition is fine as:}}
\DoxyCodeLine{3723 \textcolor{comment}{//}}
\DoxyCodeLine{3724 \textcolor{comment}{//   1. The C++ standard permits using the name \_ in a namespace that}}
\DoxyCodeLine{3725 \textcolor{comment}{//      is not the global namespace or ::std.}}
\DoxyCodeLine{3726 \textcolor{comment}{//   2. The AnythingMatcher class has no data member or constructor,}}
\DoxyCodeLine{3727 \textcolor{comment}{//      so it's OK to create global variables of this type.}}
\DoxyCodeLine{3728 \textcolor{comment}{//   3. c-\/style has approved of using \_ in this case.}}
\DoxyCodeLine{3729 \textcolor{keyword}{const} internal::AnythingMatcher \_ = \{\};}
\DoxyCodeLine{3730 \textcolor{comment}{// Creates a matcher that matches any value of the given type T.}}
\DoxyCodeLine{3731 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3732 \textcolor{keyword}{inline} Matcher<T> A() \{ \textcolor{keywordflow}{return} MakeMatcher(\textcolor{keyword}{new} internal::AnyMatcherImpl<T>()); \}}
\DoxyCodeLine{3733 }
\DoxyCodeLine{3734 \textcolor{comment}{// Creates a matcher that matches any value of the given type T.}}
\DoxyCodeLine{3735 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3736 \textcolor{keyword}{inline} Matcher<T> An() \{ \textcolor{keywordflow}{return} A<T>(); \}}
\DoxyCodeLine{3737 }
\DoxyCodeLine{3738 \textcolor{comment}{// Creates a polymorphic matcher that matches anything equal to x.}}
\DoxyCodeLine{3739 \textcolor{comment}{// Note: if the parameter of Eq() were declared as const T\&, Eq("{}foo"{})}}
\DoxyCodeLine{3740 \textcolor{comment}{// wouldn't compile.}}
\DoxyCodeLine{3741 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3742 \textcolor{keyword}{inline} internal::EqMatcher<T> Eq(T x) \{ \textcolor{keywordflow}{return} internal::EqMatcher<T>(x); \}}
\DoxyCodeLine{3743 }
\DoxyCodeLine{3744 \textcolor{comment}{// Constructs a Matcher<T> from a 'value' of type T.  The constructed}}
\DoxyCodeLine{3745 \textcolor{comment}{// matcher matches any value that's equal to 'value'.}}
\DoxyCodeLine{3746 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3747 Matcher<T>::Matcher(T value) \{ *\textcolor{keyword}{this} = Eq(value); \}}
\DoxyCodeLine{3748 }
\DoxyCodeLine{3749 \textcolor{comment}{// Creates a monomorphic matcher that matches anything with type Lhs}}
\DoxyCodeLine{3750 \textcolor{comment}{// and equal to rhs.  A user may need to use this instead of Eq(...)}}
\DoxyCodeLine{3751 \textcolor{comment}{// in order to resolve an overloading ambiguity.}}
\DoxyCodeLine{3752 \textcolor{comment}{//}}
\DoxyCodeLine{3753 \textcolor{comment}{// TypedEq<T>(x) is just a convenient short-\/hand for Matcher<T>(Eq(x))}}
\DoxyCodeLine{3754 \textcolor{comment}{// or Matcher<T>(x), but more readable than the latter.}}
\DoxyCodeLine{3755 \textcolor{comment}{//}}
\DoxyCodeLine{3756 \textcolor{comment}{// We could define similar monomorphic matchers for other comparison}}
\DoxyCodeLine{3757 \textcolor{comment}{// operations (e.g. TypedLt, TypedGe, and etc), but decided not to do}}
\DoxyCodeLine{3758 \textcolor{comment}{// it yet as those are used much less than Eq() in practice.  A user}}
\DoxyCodeLine{3759 \textcolor{comment}{// can always write Matcher<T>(Lt(5)) to be explicit about the type,}}
\DoxyCodeLine{3760 \textcolor{comment}{// for example.}}
\DoxyCodeLine{3761 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{3762 \textcolor{keyword}{inline} Matcher<Lhs> TypedEq(\textcolor{keyword}{const} Rhs\& rhs) \{ \textcolor{keywordflow}{return} Eq(rhs); \}}
\DoxyCodeLine{3763 }
\DoxyCodeLine{3764 \textcolor{comment}{// Creates a polymorphic matcher that matches anything >= x.}}
\DoxyCodeLine{3765 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{3766 \textcolor{keyword}{inline} internal::GeMatcher<Rhs> Ge(Rhs x) \{}
\DoxyCodeLine{3767   \textcolor{keywordflow}{return} internal::GeMatcher<Rhs>(x);}
\DoxyCodeLine{3768 \}}
\DoxyCodeLine{3769 }
\DoxyCodeLine{3770 \textcolor{comment}{// Creates a polymorphic matcher that matches anything > x.}}
\DoxyCodeLine{3771 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{3772 \textcolor{keyword}{inline} internal::GtMatcher<Rhs> Gt(Rhs x) \{}
\DoxyCodeLine{3773   \textcolor{keywordflow}{return} internal::GtMatcher<Rhs>(x);}
\DoxyCodeLine{3774 \}}
\DoxyCodeLine{3775 }
\DoxyCodeLine{3776 \textcolor{comment}{// Creates a polymorphic matcher that matches anything <= x.}}
\DoxyCodeLine{3777 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{3778 \textcolor{keyword}{inline} internal::LeMatcher<Rhs> Le(Rhs x) \{}
\DoxyCodeLine{3779   \textcolor{keywordflow}{return} internal::LeMatcher<Rhs>(x);}
\DoxyCodeLine{3780 \}}
\DoxyCodeLine{3781 }
\DoxyCodeLine{3782 \textcolor{comment}{// Creates a polymorphic matcher that matches anything < x.}}
\DoxyCodeLine{3783 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{3784 \textcolor{keyword}{inline} internal::LtMatcher<Rhs> Lt(Rhs x) \{}
\DoxyCodeLine{3785   \textcolor{keywordflow}{return} internal::LtMatcher<Rhs>(x);}
\DoxyCodeLine{3786 \}}
\DoxyCodeLine{3787 }
\DoxyCodeLine{3788 \textcolor{comment}{// Creates a polymorphic matcher that matches anything != x.}}
\DoxyCodeLine{3789 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{3790 \textcolor{keyword}{inline} internal::NeMatcher<Rhs> Ne(Rhs x) \{}
\DoxyCodeLine{3791   \textcolor{keywordflow}{return} internal::NeMatcher<Rhs>(x);}
\DoxyCodeLine{3792 \}}
\DoxyCodeLine{3793 }
\DoxyCodeLine{3794 \textcolor{comment}{// Creates a polymorphic matcher that matches any NULL pointer.}}
\DoxyCodeLine{3795 \textcolor{keyword}{inline} PolymorphicMatcher<internal::IsNullMatcher > IsNull() \{}
\DoxyCodeLine{3796   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::IsNullMatcher());}
\DoxyCodeLine{3797 \}}
\DoxyCodeLine{3798 }
\DoxyCodeLine{3799 \textcolor{comment}{// Creates a polymorphic matcher that matches any non-\/NULL pointer.}}
\DoxyCodeLine{3800 \textcolor{comment}{// This is convenient as Not(NULL) doesn't compile (the compiler}}
\DoxyCodeLine{3801 \textcolor{comment}{// thinks that that expression is comparing a pointer with an integer).}}
\DoxyCodeLine{3802 \textcolor{keyword}{inline} PolymorphicMatcher<internal::NotNullMatcher > NotNull() \{}
\DoxyCodeLine{3803   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::NotNullMatcher());}
\DoxyCodeLine{3804 \}}
\DoxyCodeLine{3805 }
\DoxyCodeLine{3806 \textcolor{comment}{// Creates a polymorphic matcher that matches any argument that}}
\DoxyCodeLine{3807 \textcolor{comment}{// references variable x.}}
\DoxyCodeLine{3808 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3809 \textcolor{keyword}{inline} internal::RefMatcher<T\&> Ref(T\& x) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{3810   \textcolor{keywordflow}{return} internal::RefMatcher<T\&>(x);}
\DoxyCodeLine{3811 \}}
\DoxyCodeLine{3812 }
\DoxyCodeLine{3813 \textcolor{comment}{// Creates a matcher that matches any double argument approximately}}
\DoxyCodeLine{3814 \textcolor{comment}{// equal to rhs, where two NANs are considered unequal.}}
\DoxyCodeLine{3815 \textcolor{keyword}{inline} internal::FloatingEqMatcher<double> DoubleEq(\textcolor{keywordtype}{double} rhs) \{}
\DoxyCodeLine{3816   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<double>(rhs, \textcolor{keyword}{false});}
\DoxyCodeLine{3817 \}}
\DoxyCodeLine{3818 }
\DoxyCodeLine{3819 \textcolor{comment}{// Creates a matcher that matches any double argument approximately}}
\DoxyCodeLine{3820 \textcolor{comment}{// equal to rhs, including NaN values when rhs is NaN.}}
\DoxyCodeLine{3821 \textcolor{keyword}{inline} internal::FloatingEqMatcher<double> NanSensitiveDoubleEq(\textcolor{keywordtype}{double} rhs) \{}
\DoxyCodeLine{3822   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<double>(rhs, \textcolor{keyword}{true});}
\DoxyCodeLine{3823 \}}
\DoxyCodeLine{3824 }
\DoxyCodeLine{3825 \textcolor{comment}{// Creates a matcher that matches any double argument approximately equal to}}
\DoxyCodeLine{3826 \textcolor{comment}{// rhs, up to the specified max absolute error bound, where two NANs are}}
\DoxyCodeLine{3827 \textcolor{comment}{// considered unequal.  The max absolute error bound must be non-\/negative.}}
\DoxyCodeLine{3828 \textcolor{keyword}{inline} internal::FloatingEqMatcher<double> DoubleNear(}
\DoxyCodeLine{3829     \textcolor{keywordtype}{double} rhs, \textcolor{keywordtype}{double} max\_abs\_error) \{}
\DoxyCodeLine{3830   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<double>(rhs, \textcolor{keyword}{false}, max\_abs\_error);}
\DoxyCodeLine{3831 \}}
\DoxyCodeLine{3832 }
\DoxyCodeLine{3833 \textcolor{comment}{// Creates a matcher that matches any double argument approximately equal to}}
\DoxyCodeLine{3834 \textcolor{comment}{// rhs, up to the specified max absolute error bound, including NaN values when}}
\DoxyCodeLine{3835 \textcolor{comment}{// rhs is NaN.  The max absolute error bound must be non-\/negative.}}
\DoxyCodeLine{3836 \textcolor{keyword}{inline} internal::FloatingEqMatcher<double> NanSensitiveDoubleNear(}
\DoxyCodeLine{3837     \textcolor{keywordtype}{double} rhs, \textcolor{keywordtype}{double} max\_abs\_error) \{}
\DoxyCodeLine{3838   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<double>(rhs, \textcolor{keyword}{true}, max\_abs\_error);}
\DoxyCodeLine{3839 \}}
\DoxyCodeLine{3840 }
\DoxyCodeLine{3841 \textcolor{comment}{// Creates a matcher that matches any float argument approximately}}
\DoxyCodeLine{3842 \textcolor{comment}{// equal to rhs, where two NANs are considered unequal.}}
\DoxyCodeLine{3843 \textcolor{keyword}{inline} internal::FloatingEqMatcher<float> FloatEq(\textcolor{keywordtype}{float} rhs) \{}
\DoxyCodeLine{3844   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<float>(rhs, \textcolor{keyword}{false});}
\DoxyCodeLine{3845 \}}
\DoxyCodeLine{3846 }
\DoxyCodeLine{3847 \textcolor{comment}{// Creates a matcher that matches any float argument approximately}}
\DoxyCodeLine{3848 \textcolor{comment}{// equal to rhs, including NaN values when rhs is NaN.}}
\DoxyCodeLine{3849 \textcolor{keyword}{inline} internal::FloatingEqMatcher<float> NanSensitiveFloatEq(\textcolor{keywordtype}{float} rhs) \{}
\DoxyCodeLine{3850   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<float>(rhs, \textcolor{keyword}{true});}
\DoxyCodeLine{3851 \}}
\DoxyCodeLine{3852 }
\DoxyCodeLine{3853 \textcolor{comment}{// Creates a matcher that matches any float argument approximately equal to}}
\DoxyCodeLine{3854 \textcolor{comment}{// rhs, up to the specified max absolute error bound, where two NANs are}}
\DoxyCodeLine{3855 \textcolor{comment}{// considered unequal.  The max absolute error bound must be non-\/negative.}}
\DoxyCodeLine{3856 \textcolor{keyword}{inline} internal::FloatingEqMatcher<float> FloatNear(}
\DoxyCodeLine{3857     \textcolor{keywordtype}{float} rhs, \textcolor{keywordtype}{float} max\_abs\_error) \{}
\DoxyCodeLine{3858   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<float>(rhs, \textcolor{keyword}{false}, max\_abs\_error);}
\DoxyCodeLine{3859 \}}
\DoxyCodeLine{3860 }
\DoxyCodeLine{3861 \textcolor{comment}{// Creates a matcher that matches any float argument approximately equal to}}
\DoxyCodeLine{3862 \textcolor{comment}{// rhs, up to the specified max absolute error bound, including NaN values when}}
\DoxyCodeLine{3863 \textcolor{comment}{// rhs is NaN.  The max absolute error bound must be non-\/negative.}}
\DoxyCodeLine{3864 \textcolor{keyword}{inline} internal::FloatingEqMatcher<float> NanSensitiveFloatNear(}
\DoxyCodeLine{3865     \textcolor{keywordtype}{float} rhs, \textcolor{keywordtype}{float} max\_abs\_error) \{}
\DoxyCodeLine{3866   \textcolor{keywordflow}{return} internal::FloatingEqMatcher<float>(rhs, \textcolor{keyword}{true}, max\_abs\_error);}
\DoxyCodeLine{3867 \}}
\DoxyCodeLine{3868 }
\DoxyCodeLine{3869 \textcolor{comment}{// Creates a matcher that matches a pointer (raw or smart) that points}}
\DoxyCodeLine{3870 \textcolor{comment}{// to a value that matches inner\_matcher.}}
\DoxyCodeLine{3871 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{3872 \textcolor{keyword}{inline} internal::PointeeMatcher<InnerMatcher> Pointee(}
\DoxyCodeLine{3873     \textcolor{keyword}{const} InnerMatcher\& inner\_matcher) \{}
\DoxyCodeLine{3874   \textcolor{keywordflow}{return} internal::PointeeMatcher<InnerMatcher>(inner\_matcher);}
\DoxyCodeLine{3875 \}}
\DoxyCodeLine{3876 }
\DoxyCodeLine{3877 \textcolor{comment}{// Creates a matcher that matches a pointer or reference that matches}}
\DoxyCodeLine{3878 \textcolor{comment}{// inner\_matcher when dynamic\_cast<To> is applied.}}
\DoxyCodeLine{3879 \textcolor{comment}{// The result of dynamic\_cast<To> is forwarded to the inner matcher.}}
\DoxyCodeLine{3880 \textcolor{comment}{// If To is a pointer and the cast fails, the inner matcher will receive NULL.}}
\DoxyCodeLine{3881 \textcolor{comment}{// If To is a reference and the cast fails, this matcher returns false}}
\DoxyCodeLine{3882 \textcolor{comment}{// immediately.}}
\DoxyCodeLine{3883 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To>}
\DoxyCodeLine{3884 \textcolor{keyword}{inline} PolymorphicMatcher<internal::WhenDynamicCastToMatcher<To> >}
\DoxyCodeLine{3885 WhenDynamicCastTo(\textcolor{keyword}{const} Matcher<To>\& inner\_matcher) \{}
\DoxyCodeLine{3886   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{3887       internal::WhenDynamicCastToMatcher<To>(inner\_matcher));}
\DoxyCodeLine{3888 \}}
\DoxyCodeLine{3889 }
\DoxyCodeLine{3890 \textcolor{comment}{// Creates a matcher that matches an object whose given field matches}}
\DoxyCodeLine{3891 \textcolor{comment}{// 'matcher'.  For example,}}
\DoxyCodeLine{3892 \textcolor{comment}{//   Field(\&Foo::number, Ge(5))}}
\DoxyCodeLine{3893 \textcolor{comment}{// matches a Foo object x iff x.number >= 5.}}
\DoxyCodeLine{3894 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Class, \textcolor{keyword}{typename} FieldType, \textcolor{keyword}{typename} FieldMatcher>}
\DoxyCodeLine{3895 \textcolor{keyword}{inline} PolymorphicMatcher<}
\DoxyCodeLine{3896   internal::FieldMatcher<Class, FieldType> > Field(}
\DoxyCodeLine{3897     FieldType Class::*field, \textcolor{keyword}{const} FieldMatcher\& matcher) \{}
\DoxyCodeLine{3898   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{3899       internal::FieldMatcher<Class, FieldType>(}
\DoxyCodeLine{3900           field, MatcherCast<const FieldType\&>(matcher)));}
\DoxyCodeLine{3901   \textcolor{comment}{// The call to MatcherCast() is required for supporting inner}}
\DoxyCodeLine{3902   \textcolor{comment}{// matchers of compatible types.  For example, it allows}}
\DoxyCodeLine{3903   \textcolor{comment}{//   Field(\&Foo::bar, m)}}
\DoxyCodeLine{3904   \textcolor{comment}{// to compile where bar is an int32 and m is a matcher for int64.}}
\DoxyCodeLine{3905 \}}
\DoxyCodeLine{3906 }
\DoxyCodeLine{3907 \textcolor{comment}{// Creates a matcher that matches an object whose given property}}
\DoxyCodeLine{3908 \textcolor{comment}{// matches 'matcher'.  For example,}}
\DoxyCodeLine{3909 \textcolor{comment}{//   Property(\&Foo::str, StartsWith("{}hi"{}))}}
\DoxyCodeLine{3910 \textcolor{comment}{// matches a Foo object x iff x.str() starts with "{}hi"{}.}}
\DoxyCodeLine{3911 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Class, \textcolor{keyword}{typename} PropertyType, \textcolor{keyword}{typename} PropertyMatcher>}
\DoxyCodeLine{3912 \textcolor{keyword}{inline} PolymorphicMatcher<}
\DoxyCodeLine{3913   internal::PropertyMatcher<Class, PropertyType> > Property(}
\DoxyCodeLine{3914     PropertyType (Class::*property)() \textcolor{keyword}{const}, \textcolor{keyword}{const} PropertyMatcher\& matcher) \{}
\DoxyCodeLine{3915   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{3916       internal::PropertyMatcher<Class, PropertyType>(}
\DoxyCodeLine{3917           property,}
\DoxyCodeLine{3918           MatcherCast<GTEST\_REFERENCE\_TO\_CONST\_(PropertyType)>(matcher)));}
\DoxyCodeLine{3919   \textcolor{comment}{// The call to MatcherCast() is required for supporting inner}}
\DoxyCodeLine{3920   \textcolor{comment}{// matchers of compatible types.  For example, it allows}}
\DoxyCodeLine{3921   \textcolor{comment}{//   Property(\&Foo::bar, m)}}
\DoxyCodeLine{3922   \textcolor{comment}{// to compile where bar() returns an int32 and m is a matcher for int64.}}
\DoxyCodeLine{3923 \}}
\DoxyCodeLine{3924 }
\DoxyCodeLine{3925 \textcolor{comment}{// Creates a matcher that matches an object iff the result of applying}}
\DoxyCodeLine{3926 \textcolor{comment}{// a callable to x matches 'matcher'.}}
\DoxyCodeLine{3927 \textcolor{comment}{// For example,}}
\DoxyCodeLine{3928 \textcolor{comment}{//   ResultOf(f, StartsWith("{}hi"{}))}}
\DoxyCodeLine{3929 \textcolor{comment}{// matches a Foo object x iff f(x) starts with "{}hi"{}.}}
\DoxyCodeLine{3930 \textcolor{comment}{// callable parameter can be a function, function pointer, or a functor.}}
\DoxyCodeLine{3931 \textcolor{comment}{// Callable has to satisfy the following conditions:}}
\DoxyCodeLine{3932 \textcolor{comment}{//   * It is required to keep no state affecting the results of}}
\DoxyCodeLine{3933 \textcolor{comment}{//     the calls on it and make no assumptions about how many calls}}
\DoxyCodeLine{3934 \textcolor{comment}{//     will be made. Any state it keeps must be protected from the}}
\DoxyCodeLine{3935 \textcolor{comment}{//     concurrent access.}}
\DoxyCodeLine{3936 \textcolor{comment}{//   * If it is a function object, it has to define type result\_type.}}
\DoxyCodeLine{3937 \textcolor{comment}{//     We recommend deriving your functor classes from std::unary\_function.}}
\DoxyCodeLine{3938 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable, \textcolor{keyword}{typename} ResultOfMatcher>}
\DoxyCodeLine{3939 internal::ResultOfMatcher<Callable> ResultOf(}
\DoxyCodeLine{3940     Callable callable, \textcolor{keyword}{const} ResultOfMatcher\& matcher) \{}
\DoxyCodeLine{3941   \textcolor{keywordflow}{return} internal::ResultOfMatcher<Callable>(}
\DoxyCodeLine{3942           callable,}
\DoxyCodeLine{3943           MatcherCast<\textcolor{keyword}{typename} internal::CallableTraits<Callable>::ResultType>(}
\DoxyCodeLine{3944               matcher));}
\DoxyCodeLine{3945   \textcolor{comment}{// The call to MatcherCast() is required for supporting inner}}
\DoxyCodeLine{3946   \textcolor{comment}{// matchers of compatible types.  For example, it allows}}
\DoxyCodeLine{3947   \textcolor{comment}{//   ResultOf(Function, m)}}
\DoxyCodeLine{3948   \textcolor{comment}{// to compile where Function() returns an int32 and m is a matcher for int64.}}
\DoxyCodeLine{3949 \}}
\DoxyCodeLine{3950 }
\DoxyCodeLine{3951 \textcolor{comment}{// String matchers.}}
\DoxyCodeLine{3952 }
\DoxyCodeLine{3953 \textcolor{comment}{// Matches a string equal to str.}}
\DoxyCodeLine{3954 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >}
\DoxyCodeLine{3955     StrEq(\textcolor{keyword}{const} internal::string\& str) \{}
\DoxyCodeLine{3956   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(}
\DoxyCodeLine{3957       str, \textcolor{keyword}{true}, \textcolor{keyword}{true}));}
\DoxyCodeLine{3958 \}}
\DoxyCodeLine{3959 }
\DoxyCodeLine{3960 \textcolor{comment}{// Matches a string not equal to str.}}
\DoxyCodeLine{3961 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >}
\DoxyCodeLine{3962     StrNe(\textcolor{keyword}{const} internal::string\& str) \{}
\DoxyCodeLine{3963   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(}
\DoxyCodeLine{3964       str, \textcolor{keyword}{false}, \textcolor{keyword}{true}));}
\DoxyCodeLine{3965 \}}
\DoxyCodeLine{3966 }
\DoxyCodeLine{3967 \textcolor{comment}{// Matches a string equal to str, ignoring case.}}
\DoxyCodeLine{3968 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >}
\DoxyCodeLine{3969     StrCaseEq(\textcolor{keyword}{const} internal::string\& str) \{}
\DoxyCodeLine{3970   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(}
\DoxyCodeLine{3971       str, \textcolor{keyword}{true}, \textcolor{keyword}{false}));}
\DoxyCodeLine{3972 \}}
\DoxyCodeLine{3973 }
\DoxyCodeLine{3974 \textcolor{comment}{// Matches a string not equal to str, ignoring case.}}
\DoxyCodeLine{3975 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >}
\DoxyCodeLine{3976     StrCaseNe(\textcolor{keyword}{const} internal::string\& str) \{}
\DoxyCodeLine{3977   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(}
\DoxyCodeLine{3978       str, \textcolor{keyword}{false}, \textcolor{keyword}{false}));}
\DoxyCodeLine{3979 \}}
\DoxyCodeLine{3980 }
\DoxyCodeLine{3981 \textcolor{comment}{// Creates a matcher that matches any string, std::string, or C string}}
\DoxyCodeLine{3982 \textcolor{comment}{// that contains the given substring.}}
\DoxyCodeLine{3983 \textcolor{keyword}{inline} PolymorphicMatcher<internal::HasSubstrMatcher<internal::string> >}
\DoxyCodeLine{3984     HasSubstr(\textcolor{keyword}{const} internal::string\& substring) \{}
\DoxyCodeLine{3985   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::string>(}
\DoxyCodeLine{3986       substring));}
\DoxyCodeLine{3987 \}}
\DoxyCodeLine{3988 }
\DoxyCodeLine{3989 \textcolor{comment}{// Matches a string that starts with 'prefix' (case-\/sensitive).}}
\DoxyCodeLine{3990 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StartsWithMatcher<internal::string> >}
\DoxyCodeLine{3991     StartsWith(\textcolor{keyword}{const} internal::string\& prefix) \{}
\DoxyCodeLine{3992   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::StartsWithMatcher<internal::string>(}
\DoxyCodeLine{3993       prefix));}
\DoxyCodeLine{3994 \}}
\DoxyCodeLine{3995 }
\DoxyCodeLine{3996 \textcolor{comment}{// Matches a string that ends with 'suffix' (case-\/sensitive).}}
\DoxyCodeLine{3997 \textcolor{keyword}{inline} PolymorphicMatcher<internal::EndsWithMatcher<internal::string> >}
\DoxyCodeLine{3998     EndsWith(\textcolor{keyword}{const} internal::string\& suffix) \{}
\DoxyCodeLine{3999   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::EndsWithMatcher<internal::string>(}
\DoxyCodeLine{4000       suffix));}
\DoxyCodeLine{4001 \}}
\DoxyCodeLine{4002 }
\DoxyCodeLine{4003 \textcolor{comment}{// Matches a string that fully matches regular expression 'regex'.}}
\DoxyCodeLine{4004 \textcolor{comment}{// The matcher takes ownership of 'regex'.}}
\DoxyCodeLine{4005 \textcolor{keyword}{inline} PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(}
\DoxyCodeLine{4006     \textcolor{keyword}{const} internal::RE* regex) \{}
\DoxyCodeLine{4007   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, \textcolor{keyword}{true}));}
\DoxyCodeLine{4008 \}}
\DoxyCodeLine{4009 \textcolor{keyword}{inline} PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(}
\DoxyCodeLine{4010     \textcolor{keyword}{const} internal::string\& regex) \{}
\DoxyCodeLine{4011   \textcolor{keywordflow}{return} MatchesRegex(\textcolor{keyword}{new} internal::RE(regex));}
\DoxyCodeLine{4012 \}}
\DoxyCodeLine{4013 }
\DoxyCodeLine{4014 \textcolor{comment}{// Matches a string that contains regular expression 'regex'.}}
\DoxyCodeLine{4015 \textcolor{comment}{// The matcher takes ownership of 'regex'.}}
\DoxyCodeLine{4016 \textcolor{keyword}{inline} PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(}
\DoxyCodeLine{4017     \textcolor{keyword}{const} internal::RE* regex) \{}
\DoxyCodeLine{4018   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, \textcolor{keyword}{false}));}
\DoxyCodeLine{4019 \}}
\DoxyCodeLine{4020 \textcolor{keyword}{inline} PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(}
\DoxyCodeLine{4021     \textcolor{keyword}{const} internal::string\& regex) \{}
\DoxyCodeLine{4022   \textcolor{keywordflow}{return} ContainsRegex(\textcolor{keyword}{new} internal::RE(regex));}
\DoxyCodeLine{4023 \}}
\DoxyCodeLine{4024 }
\DoxyCodeLine{4025 \textcolor{preprocessor}{\#if GTEST\_HAS\_GLOBAL\_WSTRING || GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{4026 \textcolor{comment}{// Wide string matchers.}}
\DoxyCodeLine{4027 }
\DoxyCodeLine{4028 \textcolor{comment}{// Matches a string equal to str.}}
\DoxyCodeLine{4029 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >}
\DoxyCodeLine{4030     StrEq(\textcolor{keyword}{const} internal::wstring\& str) \{}
\DoxyCodeLine{4031   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(}
\DoxyCodeLine{4032       str, \textcolor{keyword}{true}, \textcolor{keyword}{true}));}
\DoxyCodeLine{4033 \}}
\DoxyCodeLine{4034 }
\DoxyCodeLine{4035 \textcolor{comment}{// Matches a string not equal to str.}}
\DoxyCodeLine{4036 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >}
\DoxyCodeLine{4037     StrNe(\textcolor{keyword}{const} internal::wstring\& str) \{}
\DoxyCodeLine{4038   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(}
\DoxyCodeLine{4039       str, \textcolor{keyword}{false}, \textcolor{keyword}{true}));}
\DoxyCodeLine{4040 \}}
\DoxyCodeLine{4041 }
\DoxyCodeLine{4042 \textcolor{comment}{// Matches a string equal to str, ignoring case.}}
\DoxyCodeLine{4043 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >}
\DoxyCodeLine{4044     StrCaseEq(\textcolor{keyword}{const} internal::wstring\& str) \{}
\DoxyCodeLine{4045   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(}
\DoxyCodeLine{4046       str, \textcolor{keyword}{true}, \textcolor{keyword}{false}));}
\DoxyCodeLine{4047 \}}
\DoxyCodeLine{4048 }
\DoxyCodeLine{4049 \textcolor{comment}{// Matches a string not equal to str, ignoring case.}}
\DoxyCodeLine{4050 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >}
\DoxyCodeLine{4051     StrCaseNe(\textcolor{keyword}{const} internal::wstring\& str) \{}
\DoxyCodeLine{4052   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(}
\DoxyCodeLine{4053       str, \textcolor{keyword}{false}, \textcolor{keyword}{false}));}
\DoxyCodeLine{4054 \}}
\DoxyCodeLine{4055 }
\DoxyCodeLine{4056 \textcolor{comment}{// Creates a matcher that matches any wstring, std::wstring, or C wide string}}
\DoxyCodeLine{4057 \textcolor{comment}{// that contains the given substring.}}
\DoxyCodeLine{4058 \textcolor{keyword}{inline} PolymorphicMatcher<internal::HasSubstrMatcher<internal::wstring> >}
\DoxyCodeLine{4059     HasSubstr(\textcolor{keyword}{const} internal::wstring\& substring) \{}
\DoxyCodeLine{4060   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::wstring>(}
\DoxyCodeLine{4061       substring));}
\DoxyCodeLine{4062 \}}
\DoxyCodeLine{4063 }
\DoxyCodeLine{4064 \textcolor{comment}{// Matches a string that starts with 'prefix' (case-\/sensitive).}}
\DoxyCodeLine{4065 \textcolor{keyword}{inline} PolymorphicMatcher<internal::StartsWithMatcher<internal::wstring> >}
\DoxyCodeLine{4066     StartsWith(\textcolor{keyword}{const} internal::wstring\& prefix) \{}
\DoxyCodeLine{4067   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::StartsWithMatcher<internal::wstring>(}
\DoxyCodeLine{4068       prefix));}
\DoxyCodeLine{4069 \}}
\DoxyCodeLine{4070 }
\DoxyCodeLine{4071 \textcolor{comment}{// Matches a string that ends with 'suffix' (case-\/sensitive).}}
\DoxyCodeLine{4072 \textcolor{keyword}{inline} PolymorphicMatcher<internal::EndsWithMatcher<internal::wstring> >}
\DoxyCodeLine{4073     EndsWith(\textcolor{keyword}{const} internal::wstring\& suffix) \{}
\DoxyCodeLine{4074   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::EndsWithMatcher<internal::wstring>(}
\DoxyCodeLine{4075       suffix));}
\DoxyCodeLine{4076 \}}
\DoxyCodeLine{4077 }
\DoxyCodeLine{4078 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_GLOBAL\_WSTRING || GTEST\_HAS\_STD\_WSTRING}}
\DoxyCodeLine{4079 }
\DoxyCodeLine{4080 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where the}}
\DoxyCodeLine{4081 \textcolor{comment}{// first field == the second field.}}
\DoxyCodeLine{4082 \textcolor{keyword}{inline} internal::Eq2Matcher Eq() \{ \textcolor{keywordflow}{return} internal::Eq2Matcher(); \}}
\DoxyCodeLine{4083 }
\DoxyCodeLine{4084 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where the}}
\DoxyCodeLine{4085 \textcolor{comment}{// first field >= the second field.}}
\DoxyCodeLine{4086 \textcolor{keyword}{inline} internal::Ge2Matcher Ge() \{ \textcolor{keywordflow}{return} internal::Ge2Matcher(); \}}
\DoxyCodeLine{4087 }
\DoxyCodeLine{4088 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where the}}
\DoxyCodeLine{4089 \textcolor{comment}{// first field > the second field.}}
\DoxyCodeLine{4090 \textcolor{keyword}{inline} internal::Gt2Matcher Gt() \{ \textcolor{keywordflow}{return} internal::Gt2Matcher(); \}}
\DoxyCodeLine{4091 }
\DoxyCodeLine{4092 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where the}}
\DoxyCodeLine{4093 \textcolor{comment}{// first field <= the second field.}}
\DoxyCodeLine{4094 \textcolor{keyword}{inline} internal::Le2Matcher Le() \{ \textcolor{keywordflow}{return} internal::Le2Matcher(); \}}
\DoxyCodeLine{4095 }
\DoxyCodeLine{4096 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where the}}
\DoxyCodeLine{4097 \textcolor{comment}{// first field < the second field.}}
\DoxyCodeLine{4098 \textcolor{keyword}{inline} internal::Lt2Matcher Lt() \{ \textcolor{keywordflow}{return} internal::Lt2Matcher(); \}}
\DoxyCodeLine{4099 }
\DoxyCodeLine{4100 \textcolor{comment}{// Creates a polymorphic matcher that matches a 2-\/tuple where the}}
\DoxyCodeLine{4101 \textcolor{comment}{// first field != the second field.}}
\DoxyCodeLine{4102 \textcolor{keyword}{inline} internal::Ne2Matcher Ne() \{ \textcolor{keywordflow}{return} internal::Ne2Matcher(); \}}
\DoxyCodeLine{4103 }
\DoxyCodeLine{4104 \textcolor{comment}{// Creates a matcher that matches any value of type T that m doesn't}}
\DoxyCodeLine{4105 \textcolor{comment}{// match.}}
\DoxyCodeLine{4106 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{4107 \textcolor{keyword}{inline} internal::NotMatcher<InnerMatcher> Not(InnerMatcher m) \{}
\DoxyCodeLine{4108   \textcolor{keywordflow}{return} internal::NotMatcher<InnerMatcher>(m);}
\DoxyCodeLine{4109 \}}
\DoxyCodeLine{4110 }
\DoxyCodeLine{4111 \textcolor{comment}{// Returns a matcher that matches anything that satisfies the given}}
\DoxyCodeLine{4112 \textcolor{comment}{// predicate.  The predicate can be any unary function or functor}}
\DoxyCodeLine{4113 \textcolor{comment}{// whose return type can be implicitly converted to bool.}}
\DoxyCodeLine{4114 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Predicate>}
\DoxyCodeLine{4115 \textcolor{keyword}{inline} PolymorphicMatcher<internal::TrulyMatcher<Predicate> >}
\DoxyCodeLine{4116 Truly(Predicate pred) \{}
\DoxyCodeLine{4117   \textcolor{keywordflow}{return} MakePolymorphicMatcher(internal::TrulyMatcher<Predicate>(pred));}
\DoxyCodeLine{4118 \}}
\DoxyCodeLine{4119 }
\DoxyCodeLine{4120 \textcolor{comment}{// Returns a matcher that matches the container size. The container must}}
\DoxyCodeLine{4121 \textcolor{comment}{// support both size() and size\_type which all STL-\/like containers provide.}}
\DoxyCodeLine{4122 \textcolor{comment}{// Note that the parameter 'size' can be a value of type size\_type as well as}}
\DoxyCodeLine{4123 \textcolor{comment}{// matcher. For instance:}}
\DoxyCodeLine{4124 \textcolor{comment}{//   EXPECT\_THAT(container, SizeIs(2));     // Checks container has 2 elements.}}
\DoxyCodeLine{4125 \textcolor{comment}{//   EXPECT\_THAT(container, SizeIs(Le(2));  // Checks container has at most 2.}}
\DoxyCodeLine{4126 \textcolor{keyword}{template} <\textcolor{keyword}{typename} SizeMatcher>}
\DoxyCodeLine{4127 \textcolor{keyword}{inline} internal::SizeIsMatcher<SizeMatcher>}
\DoxyCodeLine{4128 SizeIs(\textcolor{keyword}{const} SizeMatcher\& size\_matcher) \{}
\DoxyCodeLine{4129   \textcolor{keywordflow}{return} internal::SizeIsMatcher<SizeMatcher>(size\_matcher);}
\DoxyCodeLine{4130 \}}
\DoxyCodeLine{4131 }
\DoxyCodeLine{4132 \textcolor{comment}{// Returns a matcher that matches the distance between the container's begin()}}
\DoxyCodeLine{4133 \textcolor{comment}{// iterator and its end() iterator, i.e. the size of the container. This matcher}}
\DoxyCodeLine{4134 \textcolor{comment}{// can be used instead of SizeIs with containers such as std::forward\_list which}}
\DoxyCodeLine{4135 \textcolor{comment}{// do not implement size(). The container must provide const\_iterator (with}}
\DoxyCodeLine{4136 \textcolor{comment}{// valid iterator\_traits), begin() and end().}}
\DoxyCodeLine{4137 \textcolor{keyword}{template} <\textcolor{keyword}{typename} DistanceMatcher>}
\DoxyCodeLine{4138 \textcolor{keyword}{inline} internal::BeginEndDistanceIsMatcher<DistanceMatcher>}
\DoxyCodeLine{4139 BeginEndDistanceIs(\textcolor{keyword}{const} DistanceMatcher\& distance\_matcher) \{}
\DoxyCodeLine{4140   \textcolor{keywordflow}{return} internal::BeginEndDistanceIsMatcher<DistanceMatcher>(distance\_matcher);}
\DoxyCodeLine{4141 \}}
\DoxyCodeLine{4142 }
\DoxyCodeLine{4143 \textcolor{comment}{// Returns a matcher that matches an equal container.}}
\DoxyCodeLine{4144 \textcolor{comment}{// This matcher behaves like Eq(), but in the event of mismatch lists the}}
\DoxyCodeLine{4145 \textcolor{comment}{// values that are included in one container but not the other. (Duplicate}}
\DoxyCodeLine{4146 \textcolor{comment}{// values and order differences are not explained.)}}
\DoxyCodeLine{4147 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{4148 \textcolor{keyword}{inline} PolymorphicMatcher<internal::ContainerEqMatcher<  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{4149                             GTEST\_REMOVE\_CONST\_(Container)> >}
\DoxyCodeLine{4150     ContainerEq(\textcolor{keyword}{const} Container\& rhs) \{}
\DoxyCodeLine{4151   \textcolor{comment}{// This following line is for working around a bug in MSVC 8.0,}}
\DoxyCodeLine{4152   \textcolor{comment}{// which causes Container to be a const type sometimes.}}
\DoxyCodeLine{4153   \textcolor{keyword}{typedef} GTEST\_REMOVE\_CONST\_(Container) RawContainer;}
\DoxyCodeLine{4154   \textcolor{keywordflow}{return} MakePolymorphicMatcher(}
\DoxyCodeLine{4155       internal::ContainerEqMatcher<RawContainer>(rhs));}
\DoxyCodeLine{4156 \}}
\DoxyCodeLine{4157 }
\DoxyCodeLine{4158 \textcolor{comment}{// Returns a matcher that matches a container that, when sorted using}}
\DoxyCodeLine{4159 \textcolor{comment}{// the given comparator, matches container\_matcher.}}
\DoxyCodeLine{4160 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Comparator, \textcolor{keyword}{typename} ContainerMatcher>}
\DoxyCodeLine{4161 \textcolor{keyword}{inline} internal::WhenSortedByMatcher<Comparator, ContainerMatcher>}
\DoxyCodeLine{4162 WhenSortedBy(\textcolor{keyword}{const} Comparator\& comparator,}
\DoxyCodeLine{4163              \textcolor{keyword}{const} ContainerMatcher\& container\_matcher) \{}
\DoxyCodeLine{4164   \textcolor{keywordflow}{return} internal::WhenSortedByMatcher<Comparator, ContainerMatcher>(}
\DoxyCodeLine{4165       comparator, container\_matcher);}
\DoxyCodeLine{4166 \}}
\DoxyCodeLine{4167 }
\DoxyCodeLine{4168 \textcolor{comment}{// Returns a matcher that matches a container that, when sorted using}}
\DoxyCodeLine{4169 \textcolor{comment}{// the < operator, matches container\_matcher.}}
\DoxyCodeLine{4170 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ContainerMatcher>}
\DoxyCodeLine{4171 \textcolor{keyword}{inline} internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>}
\DoxyCodeLine{4172 WhenSorted(\textcolor{keyword}{const} ContainerMatcher\& container\_matcher) \{}
\DoxyCodeLine{4173   \textcolor{keywordflow}{return}}
\DoxyCodeLine{4174       internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>(}
\DoxyCodeLine{4175           internal::LessComparator(), container\_matcher);}
\DoxyCodeLine{4176 \}}
\DoxyCodeLine{4177 }
\DoxyCodeLine{4178 \textcolor{comment}{// Matches an STL-\/style container or a native array that contains the}}
\DoxyCodeLine{4179 \textcolor{comment}{// same number of elements as in rhs, where its i-\/th element and rhs's}}
\DoxyCodeLine{4180 \textcolor{comment}{// i-\/th element (as a pair) satisfy the given pair matcher, for all i.}}
\DoxyCodeLine{4181 \textcolor{comment}{// TupleMatcher must be able to be safely cast to Matcher<tuple<const}}
\DoxyCodeLine{4182 \textcolor{comment}{// T1\&, const T2\&> >, where T1 and T2 are the types of elements in the}}
\DoxyCodeLine{4183 \textcolor{comment}{// LHS container and the RHS container respectively.}}
\DoxyCodeLine{4184 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TupleMatcher, \textcolor{keyword}{typename} Container>}
\DoxyCodeLine{4185 \textcolor{keyword}{inline} internal::PointwiseMatcher<TupleMatcher,}
\DoxyCodeLine{4186                                   GTEST\_REMOVE\_CONST\_(Container)>}
\DoxyCodeLine{4187 Pointwise(\textcolor{keyword}{const} TupleMatcher\& tuple\_matcher, \textcolor{keyword}{const} Container\& rhs) \{}
\DoxyCodeLine{4188   \textcolor{comment}{// This following line is for working around a bug in MSVC 8.0,}}
\DoxyCodeLine{4189   \textcolor{comment}{// which causes Container to be a const type sometimes (e.g. when}}
\DoxyCodeLine{4190   \textcolor{comment}{// rhs is a const int[])..}}
\DoxyCodeLine{4191   \textcolor{keyword}{typedef} GTEST\_REMOVE\_CONST\_(Container) RawContainer;}
\DoxyCodeLine{4192   \textcolor{keywordflow}{return} internal::PointwiseMatcher<TupleMatcher, RawContainer>(}
\DoxyCodeLine{4193       tuple\_matcher, rhs);}
\DoxyCodeLine{4194 \}}
\DoxyCodeLine{4195 }
\DoxyCodeLine{4196 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_INITIALIZER\_LIST\_}}
\DoxyCodeLine{4197 }
\DoxyCodeLine{4198 \textcolor{comment}{// Supports the Pointwise(m, \{a, b, c\}) syntax.}}
\DoxyCodeLine{4199 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TupleMatcher, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4200 \textcolor{keyword}{inline} internal::PointwiseMatcher<TupleMatcher, std::vector<T> > Pointwise(}
\DoxyCodeLine{4201     \textcolor{keyword}{const} TupleMatcher\& tuple\_matcher, std::initializer\_list<T> rhs) \{}
\DoxyCodeLine{4202   \textcolor{keywordflow}{return} Pointwise(tuple\_matcher, std::vector<T>(rhs));}
\DoxyCodeLine{4203 \}}
\DoxyCodeLine{4204 }
\DoxyCodeLine{4205 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_STD\_INITIALIZER\_LIST\_}}
\DoxyCodeLine{4206 }
\DoxyCodeLine{4207 \textcolor{comment}{// UnorderedPointwise(pair\_matcher, rhs) matches an STL-\/style}}
\DoxyCodeLine{4208 \textcolor{comment}{// container or a native array that contains the same number of}}
\DoxyCodeLine{4209 \textcolor{comment}{// elements as in rhs, where in some permutation of the container, its}}
\DoxyCodeLine{4210 \textcolor{comment}{// i-\/th element and rhs's i-\/th element (as a pair) satisfy the given}}
\DoxyCodeLine{4211 \textcolor{comment}{// pair matcher, for all i.  Tuple2Matcher must be able to be safely}}
\DoxyCodeLine{4212 \textcolor{comment}{// cast to Matcher<tuple<const T1\&, const T2\&> >, where T1 and T2 are}}
\DoxyCodeLine{4213 \textcolor{comment}{// the types of elements in the LHS container and the RHS container}}
\DoxyCodeLine{4214 \textcolor{comment}{// respectively.}}
\DoxyCodeLine{4215 \textcolor{comment}{//}}
\DoxyCodeLine{4216 \textcolor{comment}{// This is like Pointwise(pair\_matcher, rhs), except that the element}}
\DoxyCodeLine{4217 \textcolor{comment}{// order doesn't matter.}}
\DoxyCodeLine{4218 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple2Matcher, \textcolor{keyword}{typename} RhsContainer>}
\DoxyCodeLine{4219 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{4220     \textcolor{keyword}{typename} internal::BoundSecondMatcher<}
\DoxyCodeLine{4221         Tuple2Matcher, \textcolor{keyword}{typename} internal::StlContainerView<GTEST\_REMOVE\_CONST\_(}
\DoxyCodeLine{4222                            RhsContainer)>::type::value\_type> >}
\DoxyCodeLine{4223 UnorderedPointwise(\textcolor{keyword}{const} Tuple2Matcher\& tuple2\_matcher,}
\DoxyCodeLine{4224                    \textcolor{keyword}{const} RhsContainer\& rhs\_container) \{}
\DoxyCodeLine{4225   \textcolor{comment}{// This following line is for working around a bug in MSVC 8.0,}}
\DoxyCodeLine{4226   \textcolor{comment}{// which causes RhsContainer to be a const type sometimes (e.g. when}}
\DoxyCodeLine{4227   \textcolor{comment}{// rhs\_container is a const int[]).}}
\DoxyCodeLine{4228   \textcolor{keyword}{typedef} GTEST\_REMOVE\_CONST\_(RhsContainer) RawRhsContainer;}
\DoxyCodeLine{4229 }
\DoxyCodeLine{4230   \textcolor{comment}{// RhsView allows the same code to handle RhsContainer being a}}
\DoxyCodeLine{4231   \textcolor{comment}{// STL-\/style container and it being a native C-\/style array.}}
\DoxyCodeLine{4232   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::StlContainerView<RawRhsContainer> RhsView;}
\DoxyCodeLine{4233   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsView::type RhsStlContainer;}
\DoxyCodeLine{4234   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} RhsStlContainer::value\_type Second;}
\DoxyCodeLine{4235   \textcolor{keyword}{const} RhsStlContainer\& rhs\_stl\_container =}
\DoxyCodeLine{4236       RhsView::ConstReference(rhs\_container);}
\DoxyCodeLine{4237 }
\DoxyCodeLine{4238   \textcolor{comment}{// Create a matcher for each element in rhs\_container.}}
\DoxyCodeLine{4239   ::std::vector<internal::BoundSecondMatcher<Tuple2Matcher, Second> > matchers;}
\DoxyCodeLine{4240   \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} RhsStlContainer::const\_iterator it = rhs\_stl\_container.begin();}
\DoxyCodeLine{4241        it != rhs\_stl\_container.end(); ++it) \{}
\DoxyCodeLine{4242     matchers.push\_back(}
\DoxyCodeLine{4243         internal::MatcherBindSecond(tuple2\_matcher, *it));}
\DoxyCodeLine{4244   \}}
\DoxyCodeLine{4245 }
\DoxyCodeLine{4246   \textcolor{comment}{// Delegate the work to UnorderedElementsAreArray().}}
\DoxyCodeLine{4247   \textcolor{keywordflow}{return} UnorderedElementsAreArray(matchers);}
\DoxyCodeLine{4248 \}}
\DoxyCodeLine{4249 }
\DoxyCodeLine{4250 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_INITIALIZER\_LIST\_}}
\DoxyCodeLine{4251 }
\DoxyCodeLine{4252 \textcolor{comment}{// Supports the UnorderedPointwise(m, \{a, b, c\}) syntax.}}
\DoxyCodeLine{4253 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple2Matcher, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{4254 \textcolor{keyword}{inline} internal::UnorderedElementsAreArrayMatcher<}
\DoxyCodeLine{4255     \textcolor{keyword}{typename} internal::BoundSecondMatcher<Tuple2Matcher, T> >}
\DoxyCodeLine{4256 UnorderedPointwise(\textcolor{keyword}{const} Tuple2Matcher\& tuple2\_matcher,}
\DoxyCodeLine{4257                    std::initializer\_list<T> rhs) \{}
\DoxyCodeLine{4258   \textcolor{keywordflow}{return} UnorderedPointwise(tuple2\_matcher, std::vector<T>(rhs));}
\DoxyCodeLine{4259 \}}
\DoxyCodeLine{4260 }
\DoxyCodeLine{4261 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_STD\_INITIALIZER\_LIST\_}}
\DoxyCodeLine{4262 }
\DoxyCodeLine{4263 \textcolor{comment}{// Matches an STL-\/style container or a native array that contains at}}
\DoxyCodeLine{4264 \textcolor{comment}{// least one element matching the given value or matcher.}}
\DoxyCodeLine{4265 \textcolor{comment}{//}}
\DoxyCodeLine{4266 \textcolor{comment}{// Examples:}}
\DoxyCodeLine{4267 \textcolor{comment}{//   ::std::set<int> page\_ids;}}
\DoxyCodeLine{4268 \textcolor{comment}{//   page\_ids.insert(3);}}
\DoxyCodeLine{4269 \textcolor{comment}{//   page\_ids.insert(1);}}
\DoxyCodeLine{4270 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Contains(1));}}
\DoxyCodeLine{4271 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Contains(Gt(2)));}}
\DoxyCodeLine{4272 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Not(Contains(4)));}}
\DoxyCodeLine{4273 \textcolor{comment}{//}}
\DoxyCodeLine{4274 \textcolor{comment}{//   ::std::map<int, size\_t> page\_lengths;}}
\DoxyCodeLine{4275 \textcolor{comment}{//   page\_lengths[1] = 100;}}
\DoxyCodeLine{4276 \textcolor{comment}{//   EXPECT\_THAT(page\_lengths,}}
\DoxyCodeLine{4277 \textcolor{comment}{//               Contains(::std::pair<const int, size\_t>(1, 100)));}}
\DoxyCodeLine{4278 \textcolor{comment}{//}}
\DoxyCodeLine{4279 \textcolor{comment}{//   const char* user\_ids[] = \{ "{}joe"{}, "{}mike"{}, "{}tom"{} \};}}
\DoxyCodeLine{4280 \textcolor{comment}{//   EXPECT\_THAT(user\_ids, Contains(Eq(::std::string("{}tom"{}))));}}
\DoxyCodeLine{4281 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{4282 \textcolor{keyword}{inline} internal::ContainsMatcher<M> Contains(M matcher) \{}
\DoxyCodeLine{4283   \textcolor{keywordflow}{return} internal::ContainsMatcher<M>(matcher);}
\DoxyCodeLine{4284 \}}
\DoxyCodeLine{4285 }
\DoxyCodeLine{4286 \textcolor{comment}{// Matches an STL-\/style container or a native array that contains only}}
\DoxyCodeLine{4287 \textcolor{comment}{// elements matching the given value or matcher.}}
\DoxyCodeLine{4288 \textcolor{comment}{//}}
\DoxyCodeLine{4289 \textcolor{comment}{// Each(m) is semantically equivalent to Not(Contains(Not(m))). Only}}
\DoxyCodeLine{4290 \textcolor{comment}{// the messages are different.}}
\DoxyCodeLine{4291 \textcolor{comment}{//}}
\DoxyCodeLine{4292 \textcolor{comment}{// Examples:}}
\DoxyCodeLine{4293 \textcolor{comment}{//   ::std::set<int> page\_ids;}}
\DoxyCodeLine{4294 \textcolor{comment}{//   // Each(m) matches an empty container, regardless of what m is.}}
\DoxyCodeLine{4295 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Each(Eq(1)));}}
\DoxyCodeLine{4296 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Each(Eq(77)));}}
\DoxyCodeLine{4297 \textcolor{comment}{//}}
\DoxyCodeLine{4298 \textcolor{comment}{//   page\_ids.insert(3);}}
\DoxyCodeLine{4299 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Each(Gt(0)));}}
\DoxyCodeLine{4300 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Not(Each(Gt(4))));}}
\DoxyCodeLine{4301 \textcolor{comment}{//   page\_ids.insert(1);}}
\DoxyCodeLine{4302 \textcolor{comment}{//   EXPECT\_THAT(page\_ids, Not(Each(Lt(2))));}}
\DoxyCodeLine{4303 \textcolor{comment}{//}}
\DoxyCodeLine{4304 \textcolor{comment}{//   ::std::map<int, size\_t> page\_lengths;}}
\DoxyCodeLine{4305 \textcolor{comment}{//   page\_lengths[1] = 100;}}
\DoxyCodeLine{4306 \textcolor{comment}{//   page\_lengths[2] = 200;}}
\DoxyCodeLine{4307 \textcolor{comment}{//   page\_lengths[3] = 300;}}
\DoxyCodeLine{4308 \textcolor{comment}{//   EXPECT\_THAT(page\_lengths, Not(Each(Pair(1, 100))));}}
\DoxyCodeLine{4309 \textcolor{comment}{//   EXPECT\_THAT(page\_lengths, Each(Key(Le(3))));}}
\DoxyCodeLine{4310 \textcolor{comment}{//}}
\DoxyCodeLine{4311 \textcolor{comment}{//   const char* user\_ids[] = \{ "{}joe"{}, "{}mike"{}, "{}tom"{} \};}}
\DoxyCodeLine{4312 \textcolor{comment}{//   EXPECT\_THAT(user\_ids, Not(Each(Eq(::std::string("{}tom"{})))));}}
\DoxyCodeLine{4313 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{4314 \textcolor{keyword}{inline} internal::EachMatcher<M> Each(M matcher) \{}
\DoxyCodeLine{4315   \textcolor{keywordflow}{return} internal::EachMatcher<M>(matcher);}
\DoxyCodeLine{4316 \}}
\DoxyCodeLine{4317 }
\DoxyCodeLine{4318 \textcolor{comment}{// Key(inner\_matcher) matches an std::pair whose 'first' field matches}}
\DoxyCodeLine{4319 \textcolor{comment}{// inner\_matcher.  For example, Contains(Key(Ge(5))) can be used to match an}}
\DoxyCodeLine{4320 \textcolor{comment}{// std::map that contains at least one element whose key is >= 5.}}
\DoxyCodeLine{4321 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{4322 \textcolor{keyword}{inline} internal::KeyMatcher<M> Key(M inner\_matcher) \{}
\DoxyCodeLine{4323   \textcolor{keywordflow}{return} internal::KeyMatcher<M>(inner\_matcher);}
\DoxyCodeLine{4324 \}}
\DoxyCodeLine{4325 }
\DoxyCodeLine{4326 \textcolor{comment}{// Pair(first\_matcher, second\_matcher) matches a std::pair whose 'first' field}}
\DoxyCodeLine{4327 \textcolor{comment}{// matches first\_matcher and whose 'second' field matches second\_matcher.  For}}
\DoxyCodeLine{4328 \textcolor{comment}{// example, EXPECT\_THAT(map\_type, ElementsAre(Pair(Ge(5), "{}foo"{}))) can be used}}
\DoxyCodeLine{4329 \textcolor{comment}{// to match a std::map<int, string> that contains exactly one element whose key}}
\DoxyCodeLine{4330 \textcolor{comment}{// is >= 5 and whose value equals "{}foo"{}.}}
\DoxyCodeLine{4331 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FirstMatcher, \textcolor{keyword}{typename} SecondMatcher>}
\DoxyCodeLine{4332 \textcolor{keyword}{inline} internal::PairMatcher<FirstMatcher, SecondMatcher>}
\DoxyCodeLine{4333 Pair(FirstMatcher first\_matcher, SecondMatcher second\_matcher) \{}
\DoxyCodeLine{4334   \textcolor{keywordflow}{return} internal::PairMatcher<FirstMatcher, SecondMatcher>(}
\DoxyCodeLine{4335       first\_matcher, second\_matcher);}
\DoxyCodeLine{4336 \}}
\DoxyCodeLine{4337 }
\DoxyCodeLine{4338 \textcolor{comment}{// Returns a predicate that is satisfied by anything that matches the}}
\DoxyCodeLine{4339 \textcolor{comment}{// given matcher.}}
\DoxyCodeLine{4340 \textcolor{keyword}{template} <\textcolor{keyword}{typename} M>}
\DoxyCodeLine{4341 \textcolor{keyword}{inline} internal::MatcherAsPredicate<M> Matches(M matcher) \{}
\DoxyCodeLine{4342   \textcolor{keywordflow}{return} internal::MatcherAsPredicate<M>(matcher);}
\DoxyCodeLine{4343 \}}
\DoxyCodeLine{4344 }
\DoxyCodeLine{4345 \textcolor{comment}{// Returns true iff the value matches the matcher.}}
\DoxyCodeLine{4346 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{4347 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} Value(\textcolor{keyword}{const} T\& value, M matcher) \{}
\DoxyCodeLine{4348   \textcolor{keywordflow}{return} testing::Matches(matcher)(value);}
\DoxyCodeLine{4349 \}}
\DoxyCodeLine{4350 }
\DoxyCodeLine{4351 \textcolor{comment}{// Matches the value against the given matcher and explains the match}}
\DoxyCodeLine{4352 \textcolor{comment}{// result to listener.}}
\DoxyCodeLine{4353 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} M>}
\DoxyCodeLine{4354 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} ExplainMatchResult(}
\DoxyCodeLine{4355     M matcher, \textcolor{keyword}{const} T\& value, MatchResultListener* listener) \{}
\DoxyCodeLine{4356   \textcolor{keywordflow}{return} SafeMatcherCast<const T\&>(matcher).MatchAndExplain(value, listener);}
\DoxyCodeLine{4357 \}}
\DoxyCodeLine{4358 }
\DoxyCodeLine{4359 \textcolor{preprocessor}{\#if GTEST\_LANG\_CXX11}}
\DoxyCodeLine{4360 \textcolor{comment}{// Define variadic matcher versions. They are overloaded in}}
\DoxyCodeLine{4361 \textcolor{comment}{// gmock-\/generated-\/matchers.h for the cases supported by pre C++11 compilers.}}
\DoxyCodeLine{4362 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{4363 \textcolor{keyword}{inline} internal::AllOfMatcher<Args...> AllOf(\textcolor{keyword}{const} Args\&... matchers) \{}
\DoxyCodeLine{4364   \textcolor{keywordflow}{return} internal::AllOfMatcher<Args...>(matchers...);}
\DoxyCodeLine{4365 \}}
\DoxyCodeLine{4366 }
\DoxyCodeLine{4367 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{4368 \textcolor{keyword}{inline} internal::AnyOfMatcher<Args...> AnyOf(\textcolor{keyword}{const} Args\&... matchers) \{}
\DoxyCodeLine{4369   \textcolor{keywordflow}{return} internal::AnyOfMatcher<Args...>(matchers...);}
\DoxyCodeLine{4370 \}}
\DoxyCodeLine{4371 }
\DoxyCodeLine{4372 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_LANG\_CXX11}}
\DoxyCodeLine{4373 }
\DoxyCodeLine{4374 \textcolor{comment}{// AllArgs(m) is a synonym of m.  This is useful in}}
\DoxyCodeLine{4375 \textcolor{comment}{//}}
\DoxyCodeLine{4376 \textcolor{comment}{//   EXPECT\_CALL(foo, Bar(\_, \_)).With(AllArgs(Eq()));}}
\DoxyCodeLine{4377 \textcolor{comment}{//}}
\DoxyCodeLine{4378 \textcolor{comment}{// which is easier to read than}}
\DoxyCodeLine{4379 \textcolor{comment}{//}}
\DoxyCodeLine{4380 \textcolor{comment}{//   EXPECT\_CALL(foo, Bar(\_, \_)).With(Eq());}}
\DoxyCodeLine{4381 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InnerMatcher>}
\DoxyCodeLine{4382 \textcolor{keyword}{inline} InnerMatcher AllArgs(\textcolor{keyword}{const} InnerMatcher\& matcher) \{ \textcolor{keywordflow}{return} matcher; \}}
\DoxyCodeLine{4383 }
\DoxyCodeLine{4384 \textcolor{comment}{// These macros allow using matchers to check values in Google Test}}
\DoxyCodeLine{4385 \textcolor{comment}{// tests.  ASSERT\_THAT(value, matcher) and EXPECT\_THAT(value, matcher)}}
\DoxyCodeLine{4386 \textcolor{comment}{// succeed iff the value matches the matcher.  If the assertion fails,}}
\DoxyCodeLine{4387 \textcolor{comment}{// the value and the description of the matcher will be printed.}}
\DoxyCodeLine{4388 \textcolor{preprocessor}{\#define ASSERT\_THAT(value, matcher) ASSERT\_PRED\_FORMAT1(\(\backslash\)}}
\DoxyCodeLine{4389 \textcolor{preprocessor}{    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)}}
\DoxyCodeLine{4390 \textcolor{preprocessor}{\#define EXPECT\_THAT(value, matcher) EXPECT\_PRED\_FORMAT1(\(\backslash\)}}
\DoxyCodeLine{4391 \textcolor{preprocessor}{    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)}}
\DoxyCodeLine{4392 }
\DoxyCodeLine{4393 \}  \textcolor{comment}{// namespace testing}}
\DoxyCodeLine{4394 }
\DoxyCodeLine{4395 \textcolor{comment}{// Include any custom callback matchers added by the local installation.}}
\DoxyCodeLine{4396 \textcolor{comment}{// We must include this header at the end to make sure it can use the}}
\DoxyCodeLine{4397 \textcolor{comment}{// declarations from this file.}}
\DoxyCodeLine{4398 \textcolor{preprocessor}{\#include "{}gmock/internal/custom/gmock-\/matchers.h"{}}}
\DoxyCodeLine{4399 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GMOCK\_INCLUDE\_GMOCK\_GMOCK\_MATCHERS\_H\_}}

\end{DoxyCode}
