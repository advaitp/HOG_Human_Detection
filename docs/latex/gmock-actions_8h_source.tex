\hypertarget{gmock-actions_8h_source}{}\doxysection{gmock-\/actions.h}
\label{gmock-actions_8h_source}\index{vendor/googletest/googlemock/include/gmock/gmock-\/actions.h@{vendor/googletest/googlemock/include/gmock/gmock-\/actions.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Copyright 2007, Google Inc.}}
\DoxyCodeLine{2 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Redistribution and use in source and binary forms, with or without}}
\DoxyCodeLine{5 \textcolor{comment}{// modification, are permitted provided that the following conditions are}}
\DoxyCodeLine{6 \textcolor{comment}{// met:}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{//     * Redistributions of source code must retain the above copyright}}
\DoxyCodeLine{9 \textcolor{comment}{// notice, this list of conditions and the following disclaimer.}}
\DoxyCodeLine{10 \textcolor{comment}{//     * Redistributions in binary form must reproduce the above}}
\DoxyCodeLine{11 \textcolor{comment}{// copyright notice, this list of conditions and the following disclaimer}}
\DoxyCodeLine{12 \textcolor{comment}{// in the documentation and/or other materials provided with the}}
\DoxyCodeLine{13 \textcolor{comment}{// distribution.}}
\DoxyCodeLine{14 \textcolor{comment}{//     * Neither the name of Google Inc. nor the names of its}}
\DoxyCodeLine{15 \textcolor{comment}{// contributors may be used to endorse or promote products derived from}}
\DoxyCodeLine{16 \textcolor{comment}{// this software without specific prior written permission.}}
\DoxyCodeLine{17 \textcolor{comment}{//}}
\DoxyCodeLine{18 \textcolor{comment}{// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS}}
\DoxyCodeLine{19 \textcolor{comment}{// "{}AS IS"{} AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT}}
\DoxyCodeLine{20 \textcolor{comment}{// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR}}
\DoxyCodeLine{21 \textcolor{comment}{// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT}}
\DoxyCodeLine{22 \textcolor{comment}{// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,}}
\DoxyCodeLine{23 \textcolor{comment}{// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT}}
\DoxyCodeLine{24 \textcolor{comment}{// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,}}
\DoxyCodeLine{25 \textcolor{comment}{// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY}}
\DoxyCodeLine{26 \textcolor{comment}{// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}}
\DoxyCodeLine{27 \textcolor{comment}{// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}}
\DoxyCodeLine{28 \textcolor{comment}{// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}}
\DoxyCodeLine{29 \textcolor{comment}{//}}
\DoxyCodeLine{30 \textcolor{comment}{// Author: wan@google.com (Zhanyong Wan)}}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{comment}{// Google Mock -\/ a framework for writing C++ mock classes.}}
\DoxyCodeLine{33 \textcolor{comment}{//}}
\DoxyCodeLine{34 \textcolor{comment}{// This file implements some commonly used actions.}}
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{preprocessor}{\#ifndef GMOCK\_INCLUDE\_GMOCK\_GMOCK\_ACTIONS\_H\_}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#define GMOCK\_INCLUDE\_GMOCK\_GMOCK\_ACTIONS\_H\_}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{preprocessor}{\#ifndef \_WIN32\_WCE}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\# include <errno.h>}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{42 }
\DoxyCodeLine{43 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{44 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{45 }
\DoxyCodeLine{46 \textcolor{preprocessor}{\#include "{}gmock/internal/gmock-\/internal-\/utils.h"{}}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#include "{}gmock/internal/gmock-\/port.h"{}}}
\DoxyCodeLine{48 }
\DoxyCodeLine{49 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_TYPE\_TRAITS\_  }\textcolor{comment}{// Defined by gtest-\/port.h via gmock-\/port.h.}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{51 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{keyword}{namespace }testing \{}
\DoxyCodeLine{54 }
\DoxyCodeLine{55 \textcolor{comment}{// To implement an action Foo, define:}}
\DoxyCodeLine{56 \textcolor{comment}{//   1. a class FooAction that implements the ActionInterface interface, and}}
\DoxyCodeLine{57 \textcolor{comment}{//   2. a factory function that creates an Action object from a}}
\DoxyCodeLine{58 \textcolor{comment}{//      const FooAction*.}}
\DoxyCodeLine{59 \textcolor{comment}{//}}
\DoxyCodeLine{60 \textcolor{comment}{// The two-\/level delegation design follows that of Matcher, providing}}
\DoxyCodeLine{61 \textcolor{comment}{// consistency for extension developers.  It also eases ownership}}
\DoxyCodeLine{62 \textcolor{comment}{// management as Action objects can now be copied like plain values.}}
\DoxyCodeLine{63 }
\DoxyCodeLine{64 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{65 }
\DoxyCodeLine{66 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F1, \textcolor{keyword}{typename} F2>}
\DoxyCodeLine{67 \textcolor{keyword}{class }ActionAdaptor;}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 \textcolor{comment}{// BuiltInDefaultValueGetter<T, true>::Get() returns a}}
\DoxyCodeLine{70 \textcolor{comment}{// default-\/constructed T value.  BuiltInDefaultValueGetter<T,}}
\DoxyCodeLine{71 \textcolor{comment}{// false>::Get() crashes with an error.}}
\DoxyCodeLine{72 \textcolor{comment}{//}}
\DoxyCodeLine{73 \textcolor{comment}{// This primary template is used when kDefaultConstructible is true.}}
\DoxyCodeLine{74 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} kDefaultConstructible>}
\DoxyCodeLine{75 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1BuiltInDefaultValueGetter}{BuiltInDefaultValueGetter}} \{}
\DoxyCodeLine{76   \textcolor{keyword}{static} T Get() \{ \textcolor{keywordflow}{return} T(); \}}
\DoxyCodeLine{77 \};}
\DoxyCodeLine{78 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{79 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1BuiltInDefaultValueGetter}{BuiltInDefaultValueGetter}}<T, false> \{}
\DoxyCodeLine{80   \textcolor{keyword}{static} T Get() \{}
\DoxyCodeLine{81     Assert(\textcolor{keyword}{false}, \_\_FILE\_\_, \_\_LINE\_\_,}
\DoxyCodeLine{82            \textcolor{stringliteral}{"{}Default action undefined for the function return type."{}});}
\DoxyCodeLine{83     \textcolor{keywordflow}{return} internal::Invalid<T>();}
\DoxyCodeLine{84     \textcolor{comment}{// The above statement will never be reached, but is required in}}
\DoxyCodeLine{85     \textcolor{comment}{// order for this function to compile.}}
\DoxyCodeLine{86   \}}
\DoxyCodeLine{87 \};}
\DoxyCodeLine{88 }
\DoxyCodeLine{89 \textcolor{comment}{// BuiltInDefaultValue<T>::Get() returns the "{}built-\/in"{} default value}}
\DoxyCodeLine{90 \textcolor{comment}{// for type T, which is NULL when T is a raw pointer type, 0 when T is}}
\DoxyCodeLine{91 \textcolor{comment}{// a numeric type, false when T is bool, or "{}"{} when T is string or}}
\DoxyCodeLine{92 \textcolor{comment}{// std::string.  In addition, in C++11 and above, it turns a}}
\DoxyCodeLine{93 \textcolor{comment}{// default-\/constructed T value if T is default constructible.  For any}}
\DoxyCodeLine{94 \textcolor{comment}{// other type T, the built-\/in default T value is undefined, and the}}
\DoxyCodeLine{95 \textcolor{comment}{// function will abort the process.}}
\DoxyCodeLine{96 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{97 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{BuiltInDefaultValue}} \{}
\DoxyCodeLine{98  \textcolor{keyword}{public}:}
\DoxyCodeLine{99 \textcolor{preprocessor}{\#if GTEST\_HAS\_STD\_TYPE\_TRAITS\_}}
\DoxyCodeLine{100   \textcolor{comment}{// This function returns true iff type T has a built-\/in default value.}}
\DoxyCodeLine{101   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{}
\DoxyCodeLine{102     return ::std::is\_default\_constructible<T>::value;}
\DoxyCodeLine{103   \}}
\DoxyCodeLine{104 }
\DoxyCodeLine{105   \textcolor{keyword}{static} T Get() \{}
\DoxyCodeLine{106     \textcolor{keywordflow}{return} \mbox{\hyperlink{structtesting_1_1internal_1_1BuiltInDefaultValueGetter}{BuiltInDefaultValueGetter}}<}
\DoxyCodeLine{107         T, ::std::is\_default\_constructible<T>::value>::Get();}
\DoxyCodeLine{108   \}}
\DoxyCodeLine{109 }
\DoxyCodeLine{110 \textcolor{preprocessor}{\#else  }\textcolor{comment}{// GTEST\_HAS\_STD\_TYPE\_TRAITS\_}}
\DoxyCodeLine{111   \textcolor{comment}{// This function returns true iff type T has a built-\/in default value.}}
\DoxyCodeLine{112   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{}
\DoxyCodeLine{113     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{114   \}}
\DoxyCodeLine{115 }
\DoxyCodeLine{116   \textcolor{keyword}{static} T Get() \{}
\DoxyCodeLine{117     \textcolor{keywordflow}{return} \mbox{\hyperlink{structtesting_1_1internal_1_1BuiltInDefaultValueGetter}{BuiltInDefaultValueGetter<T, false>::Get}}();}
\DoxyCodeLine{118   \}}
\DoxyCodeLine{119 }
\DoxyCodeLine{120 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_STD\_TYPE\_TRAITS\_}}
\DoxyCodeLine{121 \};}
\DoxyCodeLine{122 }
\DoxyCodeLine{123 \textcolor{comment}{// This partial specialization says that we use the same built-\/in}}
\DoxyCodeLine{124 \textcolor{comment}{// default value for T and const T.}}
\DoxyCodeLine{125 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{126 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{BuiltInDefaultValue}}<const T> \{}
\DoxyCodeLine{127  \textcolor{keyword}{public}:}
\DoxyCodeLine{128   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{BuiltInDefaultValue<T>::Exists}}(); \}}
\DoxyCodeLine{129   \textcolor{keyword}{static} T Get() \{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{BuiltInDefaultValue<T>::Get}}(); \}}
\DoxyCodeLine{130 \};}
\DoxyCodeLine{131 }
\DoxyCodeLine{132 \textcolor{comment}{// This partial specialization defines the default values for pointer}}
\DoxyCodeLine{133 \textcolor{comment}{// types.}}
\DoxyCodeLine{134 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{135 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{BuiltInDefaultValue}}<T*> \{}
\DoxyCodeLine{136  \textcolor{keyword}{public}:}
\DoxyCodeLine{137   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{138   \textcolor{keyword}{static} T* Get() \{ \textcolor{keywordflow}{return} NULL; \}}
\DoxyCodeLine{139 \};}
\DoxyCodeLine{140 }
\DoxyCodeLine{141 \textcolor{comment}{// The following specializations define the default values for}}
\DoxyCodeLine{142 \textcolor{comment}{// specific types we care about.}}
\DoxyCodeLine{143 \textcolor{preprocessor}{\#define GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(type, value) \(\backslash\)}}
\DoxyCodeLine{144 \textcolor{preprocessor}{  template <> \(\backslash\)}}
\DoxyCodeLine{145 \textcolor{preprocessor}{  class BuiltInDefaultValue<type> \{ \(\backslash\)}}
\DoxyCodeLine{146 \textcolor{preprocessor}{   public: \(\backslash\)}}
\DoxyCodeLine{147 \textcolor{preprocessor}{    static bool Exists() \{ return true; \} \(\backslash\)}}
\DoxyCodeLine{148 \textcolor{preprocessor}{    static type Get() \{ return value; \} \(\backslash\)}}
\DoxyCodeLine{149 \textcolor{preprocessor}{  \}}}
\DoxyCodeLine{150 }
\DoxyCodeLine{151 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{void}, );  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{152 \textcolor{preprocessor}{\#if GTEST\_HAS\_GLOBAL\_STRING}}
\DoxyCodeLine{153 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(::\textcolor{keywordtype}{string}, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{154 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_HAS\_GLOBAL\_STRING}}
\DoxyCodeLine{155 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(::std::string, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{156 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{bool}, \textcolor{keyword}{false});}
\DoxyCodeLine{157 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}, \textcolor{charliteral}{'\(\backslash\)0'});}
\DoxyCodeLine{158 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}, \textcolor{charliteral}{'\(\backslash\)0'});}
\DoxyCodeLine{159 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{char}, \textcolor{charliteral}{'\(\backslash\)0'});}
\DoxyCodeLine{160 }
\DoxyCodeLine{161 \textcolor{comment}{// There's no need for a default action for signed wchar\_t, as that}}
\DoxyCodeLine{162 \textcolor{comment}{// type is the same as wchar\_t for gcc, and invalid for MSVC.}}
\DoxyCodeLine{163 \textcolor{comment}{//}}
\DoxyCodeLine{164 \textcolor{comment}{// There's also no need for a default action for unsigned wchar\_t, as}}
\DoxyCodeLine{165 \textcolor{comment}{// that type is the same as unsigned int for gcc, and invalid for}}
\DoxyCodeLine{166 \textcolor{comment}{// MSVC.}}
\DoxyCodeLine{167 \textcolor{preprocessor}{\#if GMOCK\_WCHAR\_T\_IS\_NATIVE\_}}
\DoxyCodeLine{168 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{wchar\_t}, 0U);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{169 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{170 }
\DoxyCodeLine{171 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}, 0U);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{172 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{short}, 0);     \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{173 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}, 0U);}
\DoxyCodeLine{174 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{int}, 0);}
\DoxyCodeLine{175 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}, 0UL);  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{176 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{long}, 0L);     \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{177 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(UInt64, 0);}
\DoxyCodeLine{178 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(Int64, 0);}
\DoxyCodeLine{179 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{float}, 0);}
\DoxyCodeLine{180 GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_(\textcolor{keywordtype}{double}, 0);}
\DoxyCodeLine{181 }
\DoxyCodeLine{182 \textcolor{preprocessor}{\#undef GMOCK\_DEFINE\_DEFAULT\_ACTION\_FOR\_RETURN\_TYPE\_}}
\DoxyCodeLine{183 }
\DoxyCodeLine{184 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{185 }
\DoxyCodeLine{186 \textcolor{comment}{// When an unexpected function call is encountered, Google Mock will}}
\DoxyCodeLine{187 \textcolor{comment}{// let it return a default value if the user has specified one for its}}
\DoxyCodeLine{188 \textcolor{comment}{// return type, or if the return type has a built-\/in default value;}}
\DoxyCodeLine{189 \textcolor{comment}{// otherwise Google Mock won't know what value to return and will have}}
\DoxyCodeLine{190 \textcolor{comment}{// to abort the process.}}
\DoxyCodeLine{191 \textcolor{comment}{//}}
\DoxyCodeLine{192 \textcolor{comment}{// The DefaultValue<T> class allows a user to specify the}}
\DoxyCodeLine{193 \textcolor{comment}{// default value for a type T that is both copyable and publicly}}
\DoxyCodeLine{194 \textcolor{comment}{// destructible (i.e. anything that can be used as a function return}}
\DoxyCodeLine{195 \textcolor{comment}{// type).  The usage is:}}
\DoxyCodeLine{196 \textcolor{comment}{//}}
\DoxyCodeLine{197 \textcolor{comment}{//   // Sets the default value for type T to be foo.}}
\DoxyCodeLine{198 \textcolor{comment}{//   DefaultValue<T>::Set(foo);}}
\DoxyCodeLine{199 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{200 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1DefaultValue}{DefaultValue}} \{}
\DoxyCodeLine{201  \textcolor{keyword}{public}:}
\DoxyCodeLine{202   \textcolor{comment}{// Sets the default value for type T; requires T to be}}
\DoxyCodeLine{203   \textcolor{comment}{// copy-\/constructable and have a public destructor.}}
\DoxyCodeLine{204   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Set(T x) \{}
\DoxyCodeLine{205     \textcolor{keyword}{delete} producer\_;}
\DoxyCodeLine{206     producer\_ = \textcolor{keyword}{new} FixedValueProducer(x);}
\DoxyCodeLine{207   \}}
\DoxyCodeLine{208 }
\DoxyCodeLine{209   \textcolor{comment}{// Provides a factory function to be called to generate the default value.}}
\DoxyCodeLine{210   \textcolor{comment}{// This method can be used even if T is only move-\/constructible, but it is not}}
\DoxyCodeLine{211   \textcolor{comment}{// limited to that case.}}
\DoxyCodeLine{212   \textcolor{keyword}{typedef} T (*FactoryFunction)();}
\DoxyCodeLine{213   \textcolor{keyword}{static} \textcolor{keywordtype}{void} SetFactory(FactoryFunction factory) \{}
\DoxyCodeLine{214     \textcolor{keyword}{delete} producer\_;}
\DoxyCodeLine{215     producer\_ = \textcolor{keyword}{new} FactoryValueProducer(factory);}
\DoxyCodeLine{216   \}}
\DoxyCodeLine{217 }
\DoxyCodeLine{218   \textcolor{comment}{// Unsets the default value for type T.}}
\DoxyCodeLine{219   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Clear() \{}
\DoxyCodeLine{220     \textcolor{keyword}{delete} producer\_;}
\DoxyCodeLine{221     producer\_ = NULL;}
\DoxyCodeLine{222   \}}
\DoxyCodeLine{223 }
\DoxyCodeLine{224   \textcolor{comment}{// Returns true iff the user has set the default value for type T.}}
\DoxyCodeLine{225   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} IsSet() \{ \textcolor{keywordflow}{return} producer\_ != NULL; \}}
\DoxyCodeLine{226 }
\DoxyCodeLine{227   \textcolor{comment}{// Returns true if T has a default return value set by the user or there}}
\DoxyCodeLine{228   \textcolor{comment}{// exists a built-\/in default value.}}
\DoxyCodeLine{229   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{}
\DoxyCodeLine{230     \textcolor{keywordflow}{return} IsSet() || \mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{internal::BuiltInDefaultValue<T>::Exists}}();}
\DoxyCodeLine{231   \}}
\DoxyCodeLine{232 }
\DoxyCodeLine{233   \textcolor{comment}{// Returns the default value for type T if the user has set one;}}
\DoxyCodeLine{234   \textcolor{comment}{// otherwise returns the built-\/in default value. Requires that Exists()}}
\DoxyCodeLine{235   \textcolor{comment}{// is true, which ensures that the return value is well-\/defined.}}
\DoxyCodeLine{236   \textcolor{keyword}{static} T Get() \{}
\DoxyCodeLine{237     \textcolor{keywordflow}{return} producer\_ == NULL ?}
\DoxyCodeLine{238         \mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{internal::BuiltInDefaultValue<T>::Get}}() : producer\_-\/>Produce();}
\DoxyCodeLine{239   \}}
\DoxyCodeLine{240 }
\DoxyCodeLine{241  \textcolor{keyword}{private}:}
\DoxyCodeLine{242   \textcolor{keyword}{class }ValueProducer \{}
\DoxyCodeLine{243    \textcolor{keyword}{public}:}
\DoxyCodeLine{244     \textcolor{keyword}{virtual} \string~ValueProducer() \{\}}
\DoxyCodeLine{245     \textcolor{keyword}{virtual} T Produce() = 0;}
\DoxyCodeLine{246   \};}
\DoxyCodeLine{247 }
\DoxyCodeLine{248   \textcolor{keyword}{class }FixedValueProducer : \textcolor{keyword}{public} ValueProducer \{}
\DoxyCodeLine{249    \textcolor{keyword}{public}:}
\DoxyCodeLine{250     \textcolor{keyword}{explicit} FixedValueProducer(T value) : value\_(value) \{\}}
\DoxyCodeLine{251     \textcolor{keyword}{virtual} T Produce() \{ \textcolor{keywordflow}{return} value\_; \}}
\DoxyCodeLine{252 }
\DoxyCodeLine{253    \textcolor{keyword}{private}:}
\DoxyCodeLine{254     \textcolor{keyword}{const} T value\_;}
\DoxyCodeLine{255     GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(FixedValueProducer);}
\DoxyCodeLine{256   \};}
\DoxyCodeLine{257 }
\DoxyCodeLine{258   \textcolor{keyword}{class }FactoryValueProducer : \textcolor{keyword}{public} ValueProducer \{}
\DoxyCodeLine{259    \textcolor{keyword}{public}:}
\DoxyCodeLine{260     \textcolor{keyword}{explicit} FactoryValueProducer(FactoryFunction factory)}
\DoxyCodeLine{261         : factory\_(factory) \{\}}
\DoxyCodeLine{262     \textcolor{keyword}{virtual} T Produce() \{ \textcolor{keywordflow}{return} factory\_(); \}}
\DoxyCodeLine{263 }
\DoxyCodeLine{264    \textcolor{keyword}{private}:}
\DoxyCodeLine{265     \textcolor{keyword}{const} FactoryFunction factory\_;}
\DoxyCodeLine{266     GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(FactoryValueProducer);}
\DoxyCodeLine{267   \};}
\DoxyCodeLine{268 }
\DoxyCodeLine{269   \textcolor{keyword}{static} ValueProducer* producer\_;}
\DoxyCodeLine{270 \};}
\DoxyCodeLine{271 }
\DoxyCodeLine{272 \textcolor{comment}{// This partial specialization allows a user to set default values for}}
\DoxyCodeLine{273 \textcolor{comment}{// reference types.}}
\DoxyCodeLine{274 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{275 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1DefaultValue}{DefaultValue}}<T\&> \{}
\DoxyCodeLine{276  \textcolor{keyword}{public}:}
\DoxyCodeLine{277   \textcolor{comment}{// Sets the default value for type T\&.}}
\DoxyCodeLine{278   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Set(T\& x) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{279     address\_ = \&x;}
\DoxyCodeLine{280   \}}
\DoxyCodeLine{281 }
\DoxyCodeLine{282   \textcolor{comment}{// Unsets the default value for type T\&.}}
\DoxyCodeLine{283   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Clear() \{}
\DoxyCodeLine{284     address\_ = NULL;}
\DoxyCodeLine{285   \}}
\DoxyCodeLine{286 }
\DoxyCodeLine{287   \textcolor{comment}{// Returns true iff the user has set the default value for type T\&.}}
\DoxyCodeLine{288   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} IsSet() \{ \textcolor{keywordflow}{return} address\_ != NULL; \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290   \textcolor{comment}{// Returns true if T has a default return value set by the user or there}}
\DoxyCodeLine{291   \textcolor{comment}{// exists a built-\/in default value.}}
\DoxyCodeLine{292   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{}
\DoxyCodeLine{293     \textcolor{keywordflow}{return} IsSet() || \mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{internal::BuiltInDefaultValue<T\&>::Exists}}();}
\DoxyCodeLine{294   \}}
\DoxyCodeLine{295 }
\DoxyCodeLine{296   \textcolor{comment}{// Returns the default value for type T\& if the user has set one;}}
\DoxyCodeLine{297   \textcolor{comment}{// otherwise returns the built-\/in default value if there is one;}}
\DoxyCodeLine{298   \textcolor{comment}{// otherwise aborts the process.}}
\DoxyCodeLine{299   \textcolor{keyword}{static} T\& Get() \{}
\DoxyCodeLine{300     \textcolor{keywordflow}{return} address\_ == NULL ?}
\DoxyCodeLine{301         \mbox{\hyperlink{classtesting_1_1internal_1_1BuiltInDefaultValue}{internal::BuiltInDefaultValue<T\&>::Get}}() : *address\_;}
\DoxyCodeLine{302   \}}
\DoxyCodeLine{303 }
\DoxyCodeLine{304  \textcolor{keyword}{private}:}
\DoxyCodeLine{305   \textcolor{keyword}{static} T* address\_;}
\DoxyCodeLine{306 \};}
\DoxyCodeLine{307 }
\DoxyCodeLine{308 \textcolor{comment}{// This specialization allows DefaultValue<void>::Get() to}}
\DoxyCodeLine{309 \textcolor{comment}{// compile.}}
\DoxyCodeLine{310 \textcolor{keyword}{template} <>}
\DoxyCodeLine{311 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1DefaultValue}{DefaultValue}}<void> \{}
\DoxyCodeLine{312  \textcolor{keyword}{public}:}
\DoxyCodeLine{313   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} Exists() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{314   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Get() \{\}}
\DoxyCodeLine{315 \};}
\DoxyCodeLine{316 }
\DoxyCodeLine{317 \textcolor{comment}{// Points to the user-\/set default value for type T.}}
\DoxyCodeLine{318 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{319 \textcolor{keyword}{typename} \mbox{\hyperlink{classtesting_1_1DefaultValue}{DefaultValue<T>::ValueProducer}}* \mbox{\hyperlink{classtesting_1_1DefaultValue}{DefaultValue<T>::producer\_}} = NULL;}
\DoxyCodeLine{320 }
\DoxyCodeLine{321 \textcolor{comment}{// Points to the user-\/set default value for type T\&.}}
\DoxyCodeLine{322 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{323 T* \mbox{\hyperlink{classtesting_1_1DefaultValue}{DefaultValue<T\&>::address\_}} = NULL;}
\DoxyCodeLine{324 }
\DoxyCodeLine{325 \textcolor{comment}{// Implement this interface to define an action for function type F.}}
\DoxyCodeLine{326 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{327 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}} \{}
\DoxyCodeLine{328  \textcolor{keyword}{public}:}
\DoxyCodeLine{329   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::Result}} Result;}
\DoxyCodeLine{330   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{331 }
\DoxyCodeLine{332   \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}() \{\}}
\DoxyCodeLine{333   \textcolor{keyword}{virtual} \mbox{\hyperlink{classtesting_1_1ActionInterface}{\string~ActionInterface}}() \{\}}
\DoxyCodeLine{334 }
\DoxyCodeLine{335   \textcolor{comment}{// Performs the action.  This method is not const, as in general an}}
\DoxyCodeLine{336   \textcolor{comment}{// action can have side effects and be stateful.  For example, a}}
\DoxyCodeLine{337   \textcolor{comment}{// get-\/the-\/next-\/element-\/from-\/the-\/collection action will need to}}
\DoxyCodeLine{338   \textcolor{comment}{// remember the current element.}}
\DoxyCodeLine{339   \textcolor{keyword}{virtual} Result Perform(\textcolor{keyword}{const} ArgumentTuple\& args) = 0;}
\DoxyCodeLine{340 }
\DoxyCodeLine{341  \textcolor{keyword}{private}:}
\DoxyCodeLine{342   GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}});}
\DoxyCodeLine{343 \};}
\DoxyCodeLine{344 }
\DoxyCodeLine{345 \textcolor{comment}{// An Action<F> is a copyable and IMMUTABLE (except by assignment)}}
\DoxyCodeLine{346 \textcolor{comment}{// object that represents an action to be taken when a mock function}}
\DoxyCodeLine{347 \textcolor{comment}{// of type F is called.  The implementation of Action<T> is just a}}
\DoxyCodeLine{348 \textcolor{comment}{// linked\_ptr to const ActionInterface<T>, so copying is fairly cheap.}}
\DoxyCodeLine{349 \textcolor{comment}{// Don't inherit from Action!}}
\DoxyCodeLine{350 \textcolor{comment}{//}}
\DoxyCodeLine{351 \textcolor{comment}{// You can view an object implementing ActionInterface<F> as a}}
\DoxyCodeLine{352 \textcolor{comment}{// concrete action (including its current state), and an Action<F>}}
\DoxyCodeLine{353 \textcolor{comment}{// object as a handle to it.}}
\DoxyCodeLine{354 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{355 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1Action}{Action}} \{}
\DoxyCodeLine{356  \textcolor{keyword}{public}:}
\DoxyCodeLine{357   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::Result}} Result;}
\DoxyCodeLine{358   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{359 }
\DoxyCodeLine{360   \textcolor{comment}{// Constructs a null Action.  Needed for storing Action objects in}}
\DoxyCodeLine{361   \textcolor{comment}{// STL containers.}}
\DoxyCodeLine{362   \mbox{\hyperlink{classtesting_1_1Action}{Action}}() : impl\_(NULL) \{\}}
\DoxyCodeLine{363 }
\DoxyCodeLine{364   \textcolor{comment}{// Constructs an Action from its implementation.  A NULL impl is}}
\DoxyCodeLine{365   \textcolor{comment}{// used to represent the "{}do-\/default"{} action.}}
\DoxyCodeLine{366   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1Action}{Action}}(\mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface<F>}}* impl) : impl\_(impl) \{\}}
\DoxyCodeLine{367 }
\DoxyCodeLine{368   \textcolor{comment}{// Copy constructor.}}
\DoxyCodeLine{369   \mbox{\hyperlink{classtesting_1_1Action}{Action}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Action}{Action}}\& action) : impl\_(action.impl\_) \{\}}
\DoxyCodeLine{370 }
\DoxyCodeLine{371   \textcolor{comment}{// This constructor allows us to turn an Action<Func> object into an}}
\DoxyCodeLine{372   \textcolor{comment}{// Action<F>, as long as F's arguments can be implicitly converted}}
\DoxyCodeLine{373   \textcolor{comment}{// to Func's and Func's return type can be implicitly converted to}}
\DoxyCodeLine{374   \textcolor{comment}{// F's.}}
\DoxyCodeLine{375   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Func>}
\DoxyCodeLine{376   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1Action}{Action}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Action}{Action<Func>}}\& action);}
\DoxyCodeLine{377 }
\DoxyCodeLine{378   \textcolor{comment}{// Returns true iff this is the DoDefault() action.}}
\DoxyCodeLine{379   \textcolor{keywordtype}{bool} IsDoDefault()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} impl\_.get() == NULL; \}}
\DoxyCodeLine{380 }
\DoxyCodeLine{381   \textcolor{comment}{// Performs the action.  Note that this method is const even though}}
\DoxyCodeLine{382   \textcolor{comment}{// the corresponding method in ActionInterface is not.  The reason}}
\DoxyCodeLine{383   \textcolor{comment}{// is that a const Action<F> means that it cannot be re-\/bound to}}
\DoxyCodeLine{384   \textcolor{comment}{// another concrete action, not that the concrete action it binds to}}
\DoxyCodeLine{385   \textcolor{comment}{// cannot change state.  (Think of the difference between a const}}
\DoxyCodeLine{386   \textcolor{comment}{// pointer and a pointer to const.)}}
\DoxyCodeLine{387   Result Perform(\textcolor{keyword}{const} ArgumentTuple\& args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{388     internal::Assert(}
\DoxyCodeLine{389         !IsDoDefault(), \_\_FILE\_\_, \_\_LINE\_\_,}
\DoxyCodeLine{390         \textcolor{stringliteral}{"{}You are using DoDefault() inside a composite action like "{}}}
\DoxyCodeLine{391         \textcolor{stringliteral}{"{}DoAll() or WithArgs().  This is not supported for technical "{}}}
\DoxyCodeLine{392         \textcolor{stringliteral}{"{}reasons.  Please instead spell out the default action, or "{}}}
\DoxyCodeLine{393         \textcolor{stringliteral}{"{}assign the default action to an Action variable and use "{}}}
\DoxyCodeLine{394         \textcolor{stringliteral}{"{}the variable in various places."{}});}
\DoxyCodeLine{395     \textcolor{keywordflow}{return} impl\_-\/>Perform(args);}
\DoxyCodeLine{396   \}}
\DoxyCodeLine{397 }
\DoxyCodeLine{398  \textcolor{keyword}{private}:}
\DoxyCodeLine{399   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F1, \textcolor{keyword}{typename} F2>}
\DoxyCodeLine{400   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ActionAdaptor}{internal::ActionAdaptor}};}
\DoxyCodeLine{401 }
\DoxyCodeLine{402   \mbox{\hyperlink{classtesting_1_1internal_1_1linked__ptr}{internal::linked\_ptr<ActionInterface<F>}} > impl\_;}
\DoxyCodeLine{403 \};}
\DoxyCodeLine{404 }
\DoxyCodeLine{405 \textcolor{comment}{// The PolymorphicAction class template makes it easy to implement a}}
\DoxyCodeLine{406 \textcolor{comment}{// polymorphic action (i.e. an action that can be used in mock}}
\DoxyCodeLine{407 \textcolor{comment}{// functions of than one type, e.g. Return()).}}
\DoxyCodeLine{408 \textcolor{comment}{//}}
\DoxyCodeLine{409 \textcolor{comment}{// To define a polymorphic action, a user first provides a COPYABLE}}
\DoxyCodeLine{410 \textcolor{comment}{// implementation class that has a Perform() method template:}}
\DoxyCodeLine{411 \textcolor{comment}{//}}
\DoxyCodeLine{412 \textcolor{comment}{//   class FooAction \{}}
\DoxyCodeLine{413 \textcolor{comment}{//    public:}}
\DoxyCodeLine{414 \textcolor{comment}{//     template <typename Result, typename ArgumentTuple>}}
\DoxyCodeLine{415 \textcolor{comment}{//     Result Perform(const ArgumentTuple\& args) const \{}}
\DoxyCodeLine{416 \textcolor{comment}{//       // Processes the arguments and returns a result, using}}
\DoxyCodeLine{417 \textcolor{comment}{//       // tr1::get<N>(args) to get the N-\/th (0-\/based) argument in the tuple.}}
\DoxyCodeLine{418 \textcolor{comment}{//     \}}}
\DoxyCodeLine{419 \textcolor{comment}{//     ...}}
\DoxyCodeLine{420 \textcolor{comment}{//   \};}}
\DoxyCodeLine{421 \textcolor{comment}{//}}
\DoxyCodeLine{422 \textcolor{comment}{// Then the user creates the polymorphic action using}}
\DoxyCodeLine{423 \textcolor{comment}{// MakePolymorphicAction(object) where object has type FooAction.  See}}
\DoxyCodeLine{424 \textcolor{comment}{// the definition of Return(void) and SetArgumentPointee<N>(value) for}}
\DoxyCodeLine{425 \textcolor{comment}{// complete examples.}}
\DoxyCodeLine{426 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Impl>}
\DoxyCodeLine{427 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1PolymorphicAction}{PolymorphicAction}} \{}
\DoxyCodeLine{428  \textcolor{keyword}{public}:}
\DoxyCodeLine{429   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1PolymorphicAction}{PolymorphicAction}}(\textcolor{keyword}{const} Impl\& impl) : impl\_(impl) \{\}}
\DoxyCodeLine{430 }
\DoxyCodeLine{431   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{432   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{433     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(\textcolor{keyword}{new} MonomorphicImpl<F>(impl\_));}
\DoxyCodeLine{434   \}}
\DoxyCodeLine{435 }
\DoxyCodeLine{436  \textcolor{keyword}{private}:}
\DoxyCodeLine{437   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{438   \textcolor{keyword}{class }MonomorphicImpl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}<F> \{}
\DoxyCodeLine{439    \textcolor{keyword}{public}:}
\DoxyCodeLine{440     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::Result}} Result;}
\DoxyCodeLine{441     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{442 }
\DoxyCodeLine{443     \textcolor{keyword}{explicit} MonomorphicImpl(\textcolor{keyword}{const} Impl\& impl) : impl\_(impl) \{\}}
\DoxyCodeLine{444 }
\DoxyCodeLine{445     \textcolor{keyword}{virtual} Result Perform(\textcolor{keyword}{const} ArgumentTuple\& args) \{}
\DoxyCodeLine{446       \textcolor{keywordflow}{return} impl\_.template Perform<Result>(args);}
\DoxyCodeLine{447     \}}
\DoxyCodeLine{448 }
\DoxyCodeLine{449    \textcolor{keyword}{private}:}
\DoxyCodeLine{450     Impl impl\_;}
\DoxyCodeLine{451 }
\DoxyCodeLine{452     GTEST\_DISALLOW\_ASSIGN\_(MonomorphicImpl);}
\DoxyCodeLine{453   \};}
\DoxyCodeLine{454 }
\DoxyCodeLine{455   Impl impl\_;}
\DoxyCodeLine{456 }
\DoxyCodeLine{457   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1PolymorphicAction}{PolymorphicAction}});}
\DoxyCodeLine{458 \};}
\DoxyCodeLine{459 }
\DoxyCodeLine{460 \textcolor{comment}{// Creates an Action from its implementation and returns it.  The}}
\DoxyCodeLine{461 \textcolor{comment}{// created Action object owns the implementation.}}
\DoxyCodeLine{462 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{463 \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}} MakeAction(\mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface<F>}}* impl) \{}
\DoxyCodeLine{464   \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(impl);}
\DoxyCodeLine{465 \}}
\DoxyCodeLine{466 }
\DoxyCodeLine{467 \textcolor{comment}{// Creates a polymorphic action from its implementation.  This is}}
\DoxyCodeLine{468 \textcolor{comment}{// easier to use than the PolymorphicAction<Impl> constructor as it}}
\DoxyCodeLine{469 \textcolor{comment}{// doesn't require you to explicitly write the template argument, e.g.}}
\DoxyCodeLine{470 \textcolor{comment}{//}}
\DoxyCodeLine{471 \textcolor{comment}{//   MakePolymorphicAction(foo);}}
\DoxyCodeLine{472 \textcolor{comment}{// vs}}
\DoxyCodeLine{473 \textcolor{comment}{//   PolymorphicAction<TypeOfFoo>(foo);}}
\DoxyCodeLine{474 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Impl>}
\DoxyCodeLine{475 \textcolor{keyword}{inline} PolymorphicAction<Impl> MakePolymorphicAction(\textcolor{keyword}{const} Impl\& impl) \{}
\DoxyCodeLine{476   \textcolor{keywordflow}{return} PolymorphicAction<Impl>(impl);}
\DoxyCodeLine{477 \}}
\DoxyCodeLine{478 }
\DoxyCodeLine{479 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{480 }
\DoxyCodeLine{481 \textcolor{comment}{// Allows an Action<F2> object to pose as an Action<F1>, as long as F2}}
\DoxyCodeLine{482 \textcolor{comment}{// and F1 are compatible.}}
\DoxyCodeLine{483 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F1, \textcolor{keyword}{typename} F2>}
\DoxyCodeLine{484 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ActionAdaptor}{ActionAdaptor}} : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}<F1> \{}
\DoxyCodeLine{485  \textcolor{keyword}{public}:}
\DoxyCodeLine{486   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F1>::Result}} Result;}
\DoxyCodeLine{487   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F1>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{488 }
\DoxyCodeLine{489   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ActionAdaptor}{ActionAdaptor}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Action}{Action<F2>}}\& from) : impl\_(from.impl\_) \{\}}
\DoxyCodeLine{490 }
\DoxyCodeLine{491   \textcolor{keyword}{virtual} Result Perform(\textcolor{keyword}{const} ArgumentTuple\& args) \{}
\DoxyCodeLine{492     \textcolor{keywordflow}{return} impl\_-\/>Perform(args);}
\DoxyCodeLine{493   \}}
\DoxyCodeLine{494 }
\DoxyCodeLine{495  \textcolor{keyword}{private}:}
\DoxyCodeLine{496   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1linked__ptr}{internal::linked\_ptr<ActionInterface<F2>}} > impl\_;}
\DoxyCodeLine{497 }
\DoxyCodeLine{498   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1ActionAdaptor}{ActionAdaptor}});}
\DoxyCodeLine{499 \};}
\DoxyCodeLine{500 }
\DoxyCodeLine{501 \textcolor{comment}{// Helper struct to specialize ReturnAction to execute a move instead of a copy}}
\DoxyCodeLine{502 \textcolor{comment}{// on return. Useful for move-\/only types, but could be used on any type.}}
\DoxyCodeLine{503 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{504 \textcolor{keyword}{struct }\mbox{\hyperlink{structtesting_1_1internal_1_1ByMoveWrapper}{ByMoveWrapper}} \{}
\DoxyCodeLine{505   \textcolor{keyword}{explicit} \mbox{\hyperlink{structtesting_1_1internal_1_1ByMoveWrapper}{ByMoveWrapper}}(T value) : payload(internal::move(value)) \{\}}
\DoxyCodeLine{506   T payload;}
\DoxyCodeLine{507 \};}
\DoxyCodeLine{508 }
\DoxyCodeLine{509 \textcolor{comment}{// Implements the polymorphic Return(x) action, which can be used in}}
\DoxyCodeLine{510 \textcolor{comment}{// any function that returns the type of x, regardless of the argument}}
\DoxyCodeLine{511 \textcolor{comment}{// types.}}
\DoxyCodeLine{512 \textcolor{comment}{//}}
\DoxyCodeLine{513 \textcolor{comment}{// Note: The value passed into Return must be converted into}}
\DoxyCodeLine{514 \textcolor{comment}{// Function<F>::Result when this action is cast to Action<F> rather than}}
\DoxyCodeLine{515 \textcolor{comment}{// when that action is performed. This is important in scenarios like}}
\DoxyCodeLine{516 \textcolor{comment}{//}}
\DoxyCodeLine{517 \textcolor{comment}{// MOCK\_METHOD1(Method, T(U));}}
\DoxyCodeLine{518 \textcolor{comment}{// ...}}
\DoxyCodeLine{519 \textcolor{comment}{// \{}}
\DoxyCodeLine{520 \textcolor{comment}{//   Foo foo;}}
\DoxyCodeLine{521 \textcolor{comment}{//   X x(\&foo);}}
\DoxyCodeLine{522 \textcolor{comment}{//   EXPECT\_CALL(mock, Method(\_)).WillOnce(Return(x));}}
\DoxyCodeLine{523 \textcolor{comment}{// \}}}
\DoxyCodeLine{524 \textcolor{comment}{//}}
\DoxyCodeLine{525 \textcolor{comment}{// In the example above the variable x holds reference to foo which leaves}}
\DoxyCodeLine{526 \textcolor{comment}{// scope and gets destroyed.  If copying X just copies a reference to foo,}}
\DoxyCodeLine{527 \textcolor{comment}{// that copy will be left with a hanging reference.  If conversion to T}}
\DoxyCodeLine{528 \textcolor{comment}{// makes a copy of foo, the above code is safe. To support that scenario, we}}
\DoxyCodeLine{529 \textcolor{comment}{// need to make sure that the type conversion happens inside the EXPECT\_CALL}}
\DoxyCodeLine{530 \textcolor{comment}{// statement, and conversion of the result of Return to Action<T(U)> is a}}
\DoxyCodeLine{531 \textcolor{comment}{// good place for that.}}
\DoxyCodeLine{532 \textcolor{comment}{//}}
\DoxyCodeLine{533 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R>}
\DoxyCodeLine{534 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnAction}{ReturnAction}} \{}
\DoxyCodeLine{535  \textcolor{keyword}{public}:}
\DoxyCodeLine{536   \textcolor{comment}{// Constructs a ReturnAction object from the value to be returned.}}
\DoxyCodeLine{537   \textcolor{comment}{// 'value' is passed by value instead of by const reference in order}}
\DoxyCodeLine{538   \textcolor{comment}{// to allow Return("{}string literal"{}) to compile.}}
\DoxyCodeLine{539   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ReturnAction}{ReturnAction}}(R value) : value\_(\textcolor{keyword}{new} R(internal::move(value))) \{\}}
\DoxyCodeLine{540 }
\DoxyCodeLine{541   \textcolor{comment}{// This template type conversion operator allows Return(x) to be}}
\DoxyCodeLine{542   \textcolor{comment}{// used in ANY function that returns x's type.}}
\DoxyCodeLine{543   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{544   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{545     \textcolor{comment}{// Assert statement belongs here because this is the best place to verify}}
\DoxyCodeLine{546     \textcolor{comment}{// conditions on F. It produces the clearest error messages}}
\DoxyCodeLine{547     \textcolor{comment}{// in most compilers.}}
\DoxyCodeLine{548     \textcolor{comment}{// Impl really belongs in this scope as a local class but can't}}
\DoxyCodeLine{549     \textcolor{comment}{// because MSVC produces duplicate symbols in different translation units}}
\DoxyCodeLine{550     \textcolor{comment}{// in this case. Until MS fixes that bug we put Impl into the class scope}}
\DoxyCodeLine{551     \textcolor{comment}{// and put the typedef both here (for use in assert statement) and}}
\DoxyCodeLine{552     \textcolor{comment}{// in the Impl class. But both definitions must be the same.}}
\DoxyCodeLine{553     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::Result}} Result;}
\DoxyCodeLine{554     GTEST\_COMPILE\_ASSERT\_(}
\DoxyCodeLine{555         !\mbox{\hyperlink{structtesting_1_1internal_1_1is__reference}{is\_reference<Result>::value}},}
\DoxyCodeLine{556         use\_ReturnRef\_instead\_of\_Return\_to\_return\_a\_reference);}
\DoxyCodeLine{557     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(\textcolor{keyword}{new} Impl<R, F>(value\_));}
\DoxyCodeLine{558   \}}
\DoxyCodeLine{559 }
\DoxyCodeLine{560  \textcolor{keyword}{private}:}
\DoxyCodeLine{561   \textcolor{comment}{// Implements the Return(x) action for a particular function type F.}}
\DoxyCodeLine{562   \textcolor{keyword}{template} <\textcolor{keyword}{typename} R\_, \textcolor{keyword}{typename} F>}
\DoxyCodeLine{563   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}<F> \{}
\DoxyCodeLine{564    \textcolor{keyword}{public}:}
\DoxyCodeLine{565     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::Result}} Result;}
\DoxyCodeLine{566     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{567 }
\DoxyCodeLine{568     \textcolor{comment}{// The implicit cast is necessary when Result has more than one}}
\DoxyCodeLine{569     \textcolor{comment}{// single-\/argument constructor (e.g. Result is std::vector<int>) and R}}
\DoxyCodeLine{570     \textcolor{comment}{// has a type conversion operator template.  In that case, value\_(value)}}
\DoxyCodeLine{571     \textcolor{comment}{// won't compile as the compiler doesn't known which constructor of}}
\DoxyCodeLine{572     \textcolor{comment}{// Result to call.  ImplicitCast\_ forces the compiler to convert R to}}
\DoxyCodeLine{573     \textcolor{comment}{// Result without considering explicit constructors, thus resolving the}}
\DoxyCodeLine{574     \textcolor{comment}{// ambiguity. value\_ is then initialized using its copy constructor.}}
\DoxyCodeLine{575     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1linked__ptr}{linked\_ptr<R>}}\& value)}
\DoxyCodeLine{576         : value\_before\_cast\_(*value),}
\DoxyCodeLine{577           value\_(ImplicitCast\_<Result>(value\_before\_cast\_)) \{\}}
\DoxyCodeLine{578 }
\DoxyCodeLine{579     \textcolor{keyword}{virtual} Result Perform(\textcolor{keyword}{const} ArgumentTuple\&) \{ \textcolor{keywordflow}{return} value\_; \}}
\DoxyCodeLine{580 }
\DoxyCodeLine{581    \textcolor{keyword}{private}:}
\DoxyCodeLine{582     GTEST\_COMPILE\_ASSERT\_(!\mbox{\hyperlink{structtesting_1_1internal_1_1is__reference}{is\_reference<Result>::value}},}
\DoxyCodeLine{583                           Result\_cannot\_be\_a\_reference\_type);}
\DoxyCodeLine{584     \textcolor{comment}{// We save the value before casting just in case it is being cast to a}}
\DoxyCodeLine{585     \textcolor{comment}{// wrapper type.}}
\DoxyCodeLine{586     R value\_before\_cast\_;}
\DoxyCodeLine{587     Result value\_;}
\DoxyCodeLine{588 }
\DoxyCodeLine{589     GTEST\_DISALLOW\_COPY\_AND\_ASSIGN\_(Impl);}
\DoxyCodeLine{590   \};}
\DoxyCodeLine{591 }
\DoxyCodeLine{592   \textcolor{comment}{// Partially specialize for ByMoveWrapper. This version of ReturnAction will}}
\DoxyCodeLine{593   \textcolor{comment}{// move its contents instead.}}
\DoxyCodeLine{594   \textcolor{keyword}{template} <\textcolor{keyword}{typename} R\_, \textcolor{keyword}{typename} F>}
\DoxyCodeLine{595   \textcolor{keyword}{class }Impl<\mbox{\hyperlink{structtesting_1_1internal_1_1ByMoveWrapper}{ByMoveWrapper}}<R\_>, F> : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}<F> \{}
\DoxyCodeLine{596    \textcolor{keyword}{public}:}
\DoxyCodeLine{597     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::Result}} Result;}
\DoxyCodeLine{598     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{599 }
\DoxyCodeLine{600     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1linked__ptr}{linked\_ptr<R>}}\& wrapper)}
\DoxyCodeLine{601         : performed\_(\textcolor{keyword}{false}), wrapper\_(wrapper) \{\}}
\DoxyCodeLine{602 }
\DoxyCodeLine{603     \textcolor{keyword}{virtual} Result Perform(\textcolor{keyword}{const} ArgumentTuple\&) \{}
\DoxyCodeLine{604       GTEST\_CHECK\_(!performed\_)}
\DoxyCodeLine{605           << \textcolor{stringliteral}{"{}A ByMove() action should only be performed once."{}};}
\DoxyCodeLine{606       performed\_ = \textcolor{keyword}{true};}
\DoxyCodeLine{607       \textcolor{keywordflow}{return} internal::move(wrapper\_-\/>payload);}
\DoxyCodeLine{608     \}}
\DoxyCodeLine{609 }
\DoxyCodeLine{610    \textcolor{keyword}{private}:}
\DoxyCodeLine{611     \textcolor{keywordtype}{bool} performed\_;}
\DoxyCodeLine{612     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1linked__ptr}{linked\_ptr<R>}} wrapper\_;}
\DoxyCodeLine{613 }
\DoxyCodeLine{614     GTEST\_DISALLOW\_ASSIGN\_(Impl);}
\DoxyCodeLine{615   \};}
\DoxyCodeLine{616 }
\DoxyCodeLine{617   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1linked__ptr}{linked\_ptr<R>}} value\_;}
\DoxyCodeLine{618 }
\DoxyCodeLine{619   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnAction}{ReturnAction}});}
\DoxyCodeLine{620 \};}
\DoxyCodeLine{621 }
\DoxyCodeLine{622 \textcolor{comment}{// Implements the ReturnNull() action.}}
\DoxyCodeLine{623 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnNullAction}{ReturnNullAction}} \{}
\DoxyCodeLine{624  \textcolor{keyword}{public}:}
\DoxyCodeLine{625   \textcolor{comment}{// Allows ReturnNull() to be used in any pointer-\/returning function. In C++11}}
\DoxyCodeLine{626   \textcolor{comment}{// this is enforced by returning nullptr, and in non-\/C++11 by asserting a}}
\DoxyCodeLine{627   \textcolor{comment}{// pointer type on compile time.}}
\DoxyCodeLine{628   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{629   \textcolor{keyword}{static} Result Perform(\textcolor{keyword}{const} ArgumentTuple\&) \{}
\DoxyCodeLine{630 \textcolor{preprocessor}{\#if GTEST\_LANG\_CXX11}}
\DoxyCodeLine{631     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{632 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{633     GTEST\_COMPILE\_ASSERT\_(\mbox{\hyperlink{structtesting_1_1internal_1_1is__pointer}{internal::is\_pointer<Result>::value}},}
\DoxyCodeLine{634                           ReturnNull\_can\_be\_used\_to\_return\_a\_pointer\_only);}
\DoxyCodeLine{635     \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{636 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GTEST\_LANG\_CXX11}}
\DoxyCodeLine{637   \}}
\DoxyCodeLine{638 \};}
\DoxyCodeLine{639 }
\DoxyCodeLine{640 \textcolor{comment}{// Implements the Return() action.}}
\DoxyCodeLine{641 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnVoidAction}{ReturnVoidAction}} \{}
\DoxyCodeLine{642  \textcolor{keyword}{public}:}
\DoxyCodeLine{643   \textcolor{comment}{// Allows Return() to be used in any void-\/returning function.}}
\DoxyCodeLine{644   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{645   \textcolor{keyword}{static} \textcolor{keywordtype}{void} Perform(\textcolor{keyword}{const} ArgumentTuple\&) \{}
\DoxyCodeLine{646     \mbox{\hyperlink{structtesting_1_1internal_1_1CompileAssertTypesEqual}{CompileAssertTypesEqual<void, Result>}}();}
\DoxyCodeLine{647   \}}
\DoxyCodeLine{648 \};}
\DoxyCodeLine{649 }
\DoxyCodeLine{650 \textcolor{comment}{// Implements the polymorphic ReturnRef(x) action, which can be used}}
\DoxyCodeLine{651 \textcolor{comment}{// in any function that returns a reference to the type of x,}}
\DoxyCodeLine{652 \textcolor{comment}{// regardless of the argument types.}}
\DoxyCodeLine{653 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{654 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnRefAction}{ReturnRefAction}} \{}
\DoxyCodeLine{655  \textcolor{keyword}{public}:}
\DoxyCodeLine{656   \textcolor{comment}{// Constructs a ReturnRefAction object from the reference to be returned.}}
\DoxyCodeLine{657   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ReturnRefAction}{ReturnRefAction}}(T\& ref) : ref\_(ref) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{658 }
\DoxyCodeLine{659   \textcolor{comment}{// This template type conversion operator allows ReturnRef(x) to be}}
\DoxyCodeLine{660   \textcolor{comment}{// used in ANY function that returns a reference to x's type.}}
\DoxyCodeLine{661   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{662   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{663     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::Result}} Result;}
\DoxyCodeLine{664     \textcolor{comment}{// Asserts that the function return type is a reference.  This}}
\DoxyCodeLine{665     \textcolor{comment}{// catches the user error of using ReturnRef(x) when Return(x)}}
\DoxyCodeLine{666     \textcolor{comment}{// should be used, and generates some helpful error message.}}
\DoxyCodeLine{667     GTEST\_COMPILE\_ASSERT\_(\mbox{\hyperlink{structtesting_1_1internal_1_1is__reference}{internal::is\_reference<Result>::value}},}
\DoxyCodeLine{668                           use\_Return\_instead\_of\_ReturnRef\_to\_return\_a\_value);}
\DoxyCodeLine{669     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(\textcolor{keyword}{new} Impl<F>(ref\_));}
\DoxyCodeLine{670   \}}
\DoxyCodeLine{671 }
\DoxyCodeLine{672  \textcolor{keyword}{private}:}
\DoxyCodeLine{673   \textcolor{comment}{// Implements the ReturnRef(x) action for a particular function type F.}}
\DoxyCodeLine{674   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{675   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}<F> \{}
\DoxyCodeLine{676    \textcolor{keyword}{public}:}
\DoxyCodeLine{677     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::Result}} Result;}
\DoxyCodeLine{678     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{679 }
\DoxyCodeLine{680     \textcolor{keyword}{explicit} Impl(T\& ref) : ref\_(ref) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{681 }
\DoxyCodeLine{682     \textcolor{keyword}{virtual} Result Perform(\textcolor{keyword}{const} ArgumentTuple\&) \{}
\DoxyCodeLine{683       \textcolor{keywordflow}{return} ref\_;}
\DoxyCodeLine{684     \}}
\DoxyCodeLine{685 }
\DoxyCodeLine{686    \textcolor{keyword}{private}:}
\DoxyCodeLine{687     T\& ref\_;}
\DoxyCodeLine{688 }
\DoxyCodeLine{689     GTEST\_DISALLOW\_ASSIGN\_(Impl);}
\DoxyCodeLine{690   \};}
\DoxyCodeLine{691 }
\DoxyCodeLine{692   T\& ref\_;}
\DoxyCodeLine{693 }
\DoxyCodeLine{694   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnRefAction}{ReturnRefAction}});}
\DoxyCodeLine{695 \};}
\DoxyCodeLine{696 }
\DoxyCodeLine{697 \textcolor{comment}{// Implements the polymorphic ReturnRefOfCopy(x) action, which can be}}
\DoxyCodeLine{698 \textcolor{comment}{// used in any function that returns a reference to the type of x,}}
\DoxyCodeLine{699 \textcolor{comment}{// regardless of the argument types.}}
\DoxyCodeLine{700 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{701 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnRefOfCopyAction}{ReturnRefOfCopyAction}} \{}
\DoxyCodeLine{702  \textcolor{keyword}{public}:}
\DoxyCodeLine{703   \textcolor{comment}{// Constructs a ReturnRefOfCopyAction object from the reference to}}
\DoxyCodeLine{704   \textcolor{comment}{// be returned.}}
\DoxyCodeLine{705   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ReturnRefOfCopyAction}{ReturnRefOfCopyAction}}(\textcolor{keyword}{const} T\& value) : value\_(value) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{706 }
\DoxyCodeLine{707   \textcolor{comment}{// This template type conversion operator allows ReturnRefOfCopy(x) to be}}
\DoxyCodeLine{708   \textcolor{comment}{// used in ANY function that returns a reference to x's type.}}
\DoxyCodeLine{709   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{710   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{711     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::Result}} Result;}
\DoxyCodeLine{712     \textcolor{comment}{// Asserts that the function return type is a reference.  This}}
\DoxyCodeLine{713     \textcolor{comment}{// catches the user error of using ReturnRefOfCopy(x) when Return(x)}}
\DoxyCodeLine{714     \textcolor{comment}{// should be used, and generates some helpful error message.}}
\DoxyCodeLine{715     GTEST\_COMPILE\_ASSERT\_(}
\DoxyCodeLine{716         \mbox{\hyperlink{structtesting_1_1internal_1_1is__reference}{internal::is\_reference<Result>::value}},}
\DoxyCodeLine{717         use\_Return\_instead\_of\_ReturnRefOfCopy\_to\_return\_a\_value);}
\DoxyCodeLine{718     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(\textcolor{keyword}{new} Impl<F>(value\_));}
\DoxyCodeLine{719   \}}
\DoxyCodeLine{720 }
\DoxyCodeLine{721  \textcolor{keyword}{private}:}
\DoxyCodeLine{722   \textcolor{comment}{// Implements the ReturnRefOfCopy(x) action for a particular function type F.}}
\DoxyCodeLine{723   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{724   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}<F> \{}
\DoxyCodeLine{725    \textcolor{keyword}{public}:}
\DoxyCodeLine{726     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::Result}} Result;}
\DoxyCodeLine{727     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{728 }
\DoxyCodeLine{729     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} T\& value) : value\_(value) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{730 }
\DoxyCodeLine{731     \textcolor{keyword}{virtual} Result Perform(\textcolor{keyword}{const} ArgumentTuple\&) \{}
\DoxyCodeLine{732       \textcolor{keywordflow}{return} value\_;}
\DoxyCodeLine{733     \}}
\DoxyCodeLine{734 }
\DoxyCodeLine{735    \textcolor{keyword}{private}:}
\DoxyCodeLine{736     T value\_;}
\DoxyCodeLine{737 }
\DoxyCodeLine{738     GTEST\_DISALLOW\_ASSIGN\_(Impl);}
\DoxyCodeLine{739   \};}
\DoxyCodeLine{740 }
\DoxyCodeLine{741   \textcolor{keyword}{const} T value\_;}
\DoxyCodeLine{742 }
\DoxyCodeLine{743   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1ReturnRefOfCopyAction}{ReturnRefOfCopyAction}});}
\DoxyCodeLine{744 \};}
\DoxyCodeLine{745 }
\DoxyCodeLine{746 \textcolor{comment}{// Implements the polymorphic DoDefault() action.}}
\DoxyCodeLine{747 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1DoDefaultAction}{DoDefaultAction}} \{}
\DoxyCodeLine{748  \textcolor{keyword}{public}:}
\DoxyCodeLine{749   \textcolor{comment}{// This template type conversion operator allows DoDefault() to be}}
\DoxyCodeLine{750   \textcolor{comment}{// used in any function.}}
\DoxyCodeLine{751   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{752   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(NULL); \}}
\DoxyCodeLine{753 \};}
\DoxyCodeLine{754 }
\DoxyCodeLine{755 \textcolor{comment}{// Implements the Assign action to set a given pointer referent to a}}
\DoxyCodeLine{756 \textcolor{comment}{// particular value.}}
\DoxyCodeLine{757 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{758 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1AssignAction}{AssignAction}} \{}
\DoxyCodeLine{759  \textcolor{keyword}{public}:}
\DoxyCodeLine{760   \mbox{\hyperlink{classtesting_1_1internal_1_1AssignAction}{AssignAction}}(T1* ptr, T2 value) : ptr\_(ptr), value\_(value) \{\}}
\DoxyCodeLine{761 }
\DoxyCodeLine{762   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{763   \textcolor{keywordtype}{void} Perform(\textcolor{keyword}{const} ArgumentTuple\& \textcolor{comment}{/* args */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{764     *ptr\_ = value\_;}
\DoxyCodeLine{765   \}}
\DoxyCodeLine{766 }
\DoxyCodeLine{767  \textcolor{keyword}{private}:}
\DoxyCodeLine{768   T1* \textcolor{keyword}{const} ptr\_;}
\DoxyCodeLine{769   \textcolor{keyword}{const} T2 value\_;}
\DoxyCodeLine{770 }
\DoxyCodeLine{771   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1AssignAction}{AssignAction}});}
\DoxyCodeLine{772 \};}
\DoxyCodeLine{773 }
\DoxyCodeLine{774 \textcolor{preprocessor}{\#if !GTEST\_OS\_WINDOWS\_MOBILE}}
\DoxyCodeLine{775 }
\DoxyCodeLine{776 \textcolor{comment}{// Implements the SetErrnoAndReturn action to simulate return from}}
\DoxyCodeLine{777 \textcolor{comment}{// various system calls and libc functions.}}
\DoxyCodeLine{778 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{779 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1SetErrnoAndReturnAction}{SetErrnoAndReturnAction}} \{}
\DoxyCodeLine{780  \textcolor{keyword}{public}:}
\DoxyCodeLine{781   \mbox{\hyperlink{classtesting_1_1internal_1_1SetErrnoAndReturnAction}{SetErrnoAndReturnAction}}(\textcolor{keywordtype}{int} errno\_value, T result)}
\DoxyCodeLine{782       : errno\_(errno\_value),}
\DoxyCodeLine{783         result\_(result) \{\}}
\DoxyCodeLine{784   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{785   Result Perform(\textcolor{keyword}{const} ArgumentTuple\& \textcolor{comment}{/* args */})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{786     errno = errno\_;}
\DoxyCodeLine{787     \textcolor{keywordflow}{return} result\_;}
\DoxyCodeLine{788   \}}
\DoxyCodeLine{789 }
\DoxyCodeLine{790  \textcolor{keyword}{private}:}
\DoxyCodeLine{791   \textcolor{keyword}{const} \textcolor{keywordtype}{int} errno\_;}
\DoxyCodeLine{792   \textcolor{keyword}{const} T result\_;}
\DoxyCodeLine{793 }
\DoxyCodeLine{794   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1SetErrnoAndReturnAction}{SetErrnoAndReturnAction}});}
\DoxyCodeLine{795 \};}
\DoxyCodeLine{796 }
\DoxyCodeLine{797 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !GTEST\_OS\_WINDOWS\_MOBILE}}
\DoxyCodeLine{798 }
\DoxyCodeLine{799 \textcolor{comment}{// Implements the SetArgumentPointee<N>(x) action for any function}}
\DoxyCodeLine{800 \textcolor{comment}{// whose N-\/th argument (0-\/based) is a pointer to x's type.  The}}
\DoxyCodeLine{801 \textcolor{comment}{// template parameter kIsProto is true iff type A is ProtocolMessage,}}
\DoxyCodeLine{802 \textcolor{comment}{// proto2::Message, or a sub-\/class of those.}}
\DoxyCodeLine{803 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} A, \textcolor{keywordtype}{bool} kIsProto>}
\DoxyCodeLine{804 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1SetArgumentPointeeAction}{SetArgumentPointeeAction}} \{}
\DoxyCodeLine{805  \textcolor{keyword}{public}:}
\DoxyCodeLine{806   \textcolor{comment}{// Constructs an action that sets the variable pointed to by the}}
\DoxyCodeLine{807   \textcolor{comment}{// N-\/th function argument to 'value'.}}
\DoxyCodeLine{808   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1SetArgumentPointeeAction}{SetArgumentPointeeAction}}(\textcolor{keyword}{const} A\& value) : value\_(value) \{\}}
\DoxyCodeLine{809 }
\DoxyCodeLine{810   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{811   \textcolor{keywordtype}{void} Perform(\textcolor{keyword}{const} ArgumentTuple\& args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{812     \mbox{\hyperlink{structtesting_1_1internal_1_1CompileAssertTypesEqual}{CompileAssertTypesEqual<void, Result>}}();}
\DoxyCodeLine{813     *::testing::get<N>(args) = value\_;}
\DoxyCodeLine{814   \}}
\DoxyCodeLine{815 }
\DoxyCodeLine{816  \textcolor{keyword}{private}:}
\DoxyCodeLine{817   \textcolor{keyword}{const} A value\_;}
\DoxyCodeLine{818 }
\DoxyCodeLine{819   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1SetArgumentPointeeAction}{SetArgumentPointeeAction}});}
\DoxyCodeLine{820 \};}
\DoxyCodeLine{821 }
\DoxyCodeLine{822 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} Proto>}
\DoxyCodeLine{823 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1SetArgumentPointeeAction}{SetArgumentPointeeAction}}<N, Proto, true> \{}
\DoxyCodeLine{824  \textcolor{keyword}{public}:}
\DoxyCodeLine{825   \textcolor{comment}{// Constructs an action that sets the variable pointed to by the}}
\DoxyCodeLine{826   \textcolor{comment}{// N-\/th function argument to 'proto'.  Both ProtocolMessage and}}
\DoxyCodeLine{827   \textcolor{comment}{// proto2::Message have the CopyFrom() method, so the same}}
\DoxyCodeLine{828   \textcolor{comment}{// implementation works for both.}}
\DoxyCodeLine{829   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1SetArgumentPointeeAction}{SetArgumentPointeeAction}}(\textcolor{keyword}{const} Proto\& proto) : proto\_(\textcolor{keyword}{new} Proto) \{}
\DoxyCodeLine{830     proto\_-\/>CopyFrom(proto);}
\DoxyCodeLine{831   \}}
\DoxyCodeLine{832 }
\DoxyCodeLine{833   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{834   \textcolor{keywordtype}{void} Perform(\textcolor{keyword}{const} ArgumentTuple\& args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{835     \mbox{\hyperlink{structtesting_1_1internal_1_1CompileAssertTypesEqual}{CompileAssertTypesEqual<void, Result>}}();}
\DoxyCodeLine{836     ::testing::get<N>(args)-\/>CopyFrom(*proto\_);}
\DoxyCodeLine{837   \}}
\DoxyCodeLine{838 }
\DoxyCodeLine{839  \textcolor{keyword}{private}:}
\DoxyCodeLine{840   \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1linked__ptr}{internal::linked\_ptr<Proto>}} proto\_;}
\DoxyCodeLine{841 }
\DoxyCodeLine{842   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1SetArgumentPointeeAction}{SetArgumentPointeeAction}});}
\DoxyCodeLine{843 \};}
\DoxyCodeLine{844 }
\DoxyCodeLine{845 \textcolor{comment}{// Implements the InvokeWithoutArgs(f) action.  The template argument}}
\DoxyCodeLine{846 \textcolor{comment}{// FunctionImpl is the implementation type of f, which can be either a}}
\DoxyCodeLine{847 \textcolor{comment}{// function pointer or a functor.  InvokeWithoutArgs(f) can be used as an}}
\DoxyCodeLine{848 \textcolor{comment}{// Action<F> as long as f's type is compatible with F (i.e. f can be}}
\DoxyCodeLine{849 \textcolor{comment}{// assigned to a tr1::function<F>).}}
\DoxyCodeLine{850 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FunctionImpl>}
\DoxyCodeLine{851 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1InvokeWithoutArgsAction}{InvokeWithoutArgsAction}} \{}
\DoxyCodeLine{852  \textcolor{keyword}{public}:}
\DoxyCodeLine{853   \textcolor{comment}{// The c'tor makes a copy of function\_impl (either a function}}
\DoxyCodeLine{854   \textcolor{comment}{// pointer or a functor).}}
\DoxyCodeLine{855   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1InvokeWithoutArgsAction}{InvokeWithoutArgsAction}}(FunctionImpl function\_impl)}
\DoxyCodeLine{856       : function\_impl\_(function\_impl) \{\}}
\DoxyCodeLine{857 }
\DoxyCodeLine{858   \textcolor{comment}{// Allows InvokeWithoutArgs(f) to be used as any action whose type is}}
\DoxyCodeLine{859   \textcolor{comment}{// compatible with f.}}
\DoxyCodeLine{860   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{861   Result Perform(\textcolor{keyword}{const} ArgumentTuple\&) \{ \textcolor{keywordflow}{return} function\_impl\_(); \}}
\DoxyCodeLine{862 }
\DoxyCodeLine{863  \textcolor{keyword}{private}:}
\DoxyCodeLine{864   FunctionImpl function\_impl\_;}
\DoxyCodeLine{865 }
\DoxyCodeLine{866   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1InvokeWithoutArgsAction}{InvokeWithoutArgsAction}});}
\DoxyCodeLine{867 \};}
\DoxyCodeLine{868 }
\DoxyCodeLine{869 \textcolor{comment}{// Implements the InvokeWithoutArgs(object\_ptr, \&Class::Method) action.}}
\DoxyCodeLine{870 \textcolor{keyword}{template} <\textcolor{keyword}{class} Class, \textcolor{keyword}{typename} MethodPtr>}
\DoxyCodeLine{871 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1InvokeMethodWithoutArgsAction}{InvokeMethodWithoutArgsAction}} \{}
\DoxyCodeLine{872  \textcolor{keyword}{public}:}
\DoxyCodeLine{873   \mbox{\hyperlink{classtesting_1_1internal_1_1InvokeMethodWithoutArgsAction}{InvokeMethodWithoutArgsAction}}(Class* obj\_ptr, MethodPtr method\_ptr)}
\DoxyCodeLine{874       : obj\_ptr\_(obj\_ptr), method\_ptr\_(method\_ptr) \{\}}
\DoxyCodeLine{875 }
\DoxyCodeLine{876   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result, \textcolor{keyword}{typename} ArgumentTuple>}
\DoxyCodeLine{877   Result Perform(\textcolor{keyword}{const} ArgumentTuple\&)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{878     \textcolor{keywordflow}{return} (obj\_ptr\_-\/>*method\_ptr\_)();}
\DoxyCodeLine{879   \}}
\DoxyCodeLine{880 }
\DoxyCodeLine{881  \textcolor{keyword}{private}:}
\DoxyCodeLine{882   Class* \textcolor{keyword}{const} obj\_ptr\_;}
\DoxyCodeLine{883   \textcolor{keyword}{const} MethodPtr method\_ptr\_;}
\DoxyCodeLine{884 }
\DoxyCodeLine{885   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1InvokeMethodWithoutArgsAction}{InvokeMethodWithoutArgsAction}});}
\DoxyCodeLine{886 \};}
\DoxyCodeLine{887 }
\DoxyCodeLine{888 \textcolor{comment}{// Implements the IgnoreResult(action) action.}}
\DoxyCodeLine{889 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A>}
\DoxyCodeLine{890 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1IgnoreResultAction}{IgnoreResultAction}} \{}
\DoxyCodeLine{891  \textcolor{keyword}{public}:}
\DoxyCodeLine{892   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1IgnoreResultAction}{IgnoreResultAction}}(\textcolor{keyword}{const} A\& action) : action\_(action) \{\}}
\DoxyCodeLine{893 }
\DoxyCodeLine{894   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{895   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{896     \textcolor{comment}{// Assert statement belongs here because this is the best place to verify}}
\DoxyCodeLine{897     \textcolor{comment}{// conditions on F. It produces the clearest error messages}}
\DoxyCodeLine{898     \textcolor{comment}{// in most compilers.}}
\DoxyCodeLine{899     \textcolor{comment}{// Impl really belongs in this scope as a local class but can't}}
\DoxyCodeLine{900     \textcolor{comment}{// because MSVC produces duplicate symbols in different translation units}}
\DoxyCodeLine{901     \textcolor{comment}{// in this case. Until MS fixes that bug we put Impl into the class scope}}
\DoxyCodeLine{902     \textcolor{comment}{// and put the typedef both here (for use in assert statement) and}}
\DoxyCodeLine{903     \textcolor{comment}{// in the Impl class. But both definitions must be the same.}}
\DoxyCodeLine{904     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::Result}} Result;}
\DoxyCodeLine{905 }
\DoxyCodeLine{906     \textcolor{comment}{// Asserts at compile time that F returns void.}}
\DoxyCodeLine{907     \mbox{\hyperlink{structtesting_1_1internal_1_1CompileAssertTypesEqual}{CompileAssertTypesEqual<void, Result>}}();}
\DoxyCodeLine{908 }
\DoxyCodeLine{909     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(\textcolor{keyword}{new} Impl<F>(action\_));}
\DoxyCodeLine{910   \}}
\DoxyCodeLine{911 }
\DoxyCodeLine{912  \textcolor{keyword}{private}:}
\DoxyCodeLine{913   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{914   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}<F> \{}
\DoxyCodeLine{915    \textcolor{keyword}{public}:}
\DoxyCodeLine{916     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::Result}} Result;}
\DoxyCodeLine{917     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{918 }
\DoxyCodeLine{919     \textcolor{keyword}{explicit} Impl(\textcolor{keyword}{const} A\& action) : action\_(action) \{\}}
\DoxyCodeLine{920 }
\DoxyCodeLine{921     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} Perform(\textcolor{keyword}{const} ArgumentTuple\& args) \{}
\DoxyCodeLine{922       \textcolor{comment}{// Performs the action and ignores its result.}}
\DoxyCodeLine{923       action\_.Perform(args);}
\DoxyCodeLine{924     \}}
\DoxyCodeLine{925 }
\DoxyCodeLine{926    \textcolor{keyword}{private}:}
\DoxyCodeLine{927     \textcolor{comment}{// Type OriginalFunction is the same as F except that its return}}
\DoxyCodeLine{928     \textcolor{comment}{// type is IgnoredValue.}}
\DoxyCodeLine{929     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{internal::Function<F>::MakeResultIgnoredValue}}}
\DoxyCodeLine{930         OriginalFunction;}
\DoxyCodeLine{931 }
\DoxyCodeLine{932     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Action}{Action<OriginalFunction>}} action\_;}
\DoxyCodeLine{933 }
\DoxyCodeLine{934     GTEST\_DISALLOW\_ASSIGN\_(Impl);}
\DoxyCodeLine{935   \};}
\DoxyCodeLine{936 }
\DoxyCodeLine{937   \textcolor{keyword}{const} A action\_;}
\DoxyCodeLine{938 }
\DoxyCodeLine{939   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1IgnoreResultAction}{IgnoreResultAction}});}
\DoxyCodeLine{940 \};}
\DoxyCodeLine{941 }
\DoxyCodeLine{942 \textcolor{comment}{// A ReferenceWrapper<T> object represents a reference to type T,}}
\DoxyCodeLine{943 \textcolor{comment}{// which can be either const or not.  It can be explicitly converted}}
\DoxyCodeLine{944 \textcolor{comment}{// from, and implicitly converted to, a T\&.  Unlike a reference,}}
\DoxyCodeLine{945 \textcolor{comment}{// ReferenceWrapper<T> can be copied and can survive template type}}
\DoxyCodeLine{946 \textcolor{comment}{// inference.  This is used to support by-\/reference arguments in the}}
\DoxyCodeLine{947 \textcolor{comment}{// InvokeArgument<N>(...) action.  The idea was from "{}reference}}
\DoxyCodeLine{948 \textcolor{comment}{// wrappers"{} in tr1, which we don't have in our source tree yet.}}
\DoxyCodeLine{949 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{950 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1ReferenceWrapper}{ReferenceWrapper}} \{}
\DoxyCodeLine{951  \textcolor{keyword}{public}:}
\DoxyCodeLine{952   \textcolor{comment}{// Constructs a ReferenceWrapper<T> object from a T\&.}}
\DoxyCodeLine{953   \textcolor{keyword}{explicit} \mbox{\hyperlink{classtesting_1_1internal_1_1ReferenceWrapper}{ReferenceWrapper}}(T\& l\_value) : pointer\_(\&l\_value) \{\}  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{954 }
\DoxyCodeLine{955   \textcolor{comment}{// Allows a ReferenceWrapper<T> object to be implicitly converted to}}
\DoxyCodeLine{956   \textcolor{comment}{// a T\&.}}
\DoxyCodeLine{957   \textcolor{keyword}{operator} T\&() \textcolor{keyword}{const} \{ \textcolor{keywordflow}{return} *pointer\_; \}}
\DoxyCodeLine{958  \textcolor{keyword}{private}:}
\DoxyCodeLine{959   T* pointer\_;}
\DoxyCodeLine{960 \};}
\DoxyCodeLine{961 }
\DoxyCodeLine{962 \textcolor{comment}{// Allows the expression ByRef(x) to be printed as a reference to x.}}
\DoxyCodeLine{963 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{964 \textcolor{keywordtype}{void} PrintTo(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1internal_1_1ReferenceWrapper}{ReferenceWrapper<T>}}\& ref, ::std::ostream* os) \{}
\DoxyCodeLine{965   T\& value = ref;}
\DoxyCodeLine{966   \mbox{\hyperlink{classtesting_1_1internal_1_1UniversalPrinter}{UniversalPrinter<T\&>::Print}}(value, os);}
\DoxyCodeLine{967 \}}
\DoxyCodeLine{968 }
\DoxyCodeLine{969 \textcolor{comment}{// Does two actions sequentially.  Used for implementing the DoAll(a1,}}
\DoxyCodeLine{970 \textcolor{comment}{// a2, ...) action.}}
\DoxyCodeLine{971 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Action1, \textcolor{keyword}{typename} Action2>}
\DoxyCodeLine{972 \textcolor{keyword}{class }\mbox{\hyperlink{classtesting_1_1internal_1_1DoBothAction}{DoBothAction}} \{}
\DoxyCodeLine{973  \textcolor{keyword}{public}:}
\DoxyCodeLine{974   \mbox{\hyperlink{classtesting_1_1internal_1_1DoBothAction}{DoBothAction}}(Action1 action1, Action2 action2)}
\DoxyCodeLine{975       : action1\_(action1), action2\_(action2) \{\}}
\DoxyCodeLine{976 }
\DoxyCodeLine{977   \textcolor{comment}{// This template type conversion operator allows DoAll(a1, ..., a\_n)}}
\DoxyCodeLine{978   \textcolor{comment}{// to be used in ANY function of compatible type.}}
\DoxyCodeLine{979   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{980   \textcolor{keyword}{operator} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{981     \textcolor{keywordflow}{return} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}(\textcolor{keyword}{new} Impl<F>(action1\_, action2\_));}
\DoxyCodeLine{982   \}}
\DoxyCodeLine{983 }
\DoxyCodeLine{984  \textcolor{keyword}{private}:}
\DoxyCodeLine{985   \textcolor{comment}{// Implements the DoAll(...) action for a particular function type F.}}
\DoxyCodeLine{986   \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{987   \textcolor{keyword}{class }Impl : \textcolor{keyword}{public} \mbox{\hyperlink{classtesting_1_1ActionInterface}{ActionInterface}}<F> \{}
\DoxyCodeLine{988    \textcolor{keyword}{public}:}
\DoxyCodeLine{989     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::Result}} Result;}
\DoxyCodeLine{990     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::ArgumentTuple}} ArgumentTuple;}
\DoxyCodeLine{991     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structtesting_1_1internal_1_1Function}{Function<F>::MakeResultVoid}} VoidResult;}
\DoxyCodeLine{992 }
\DoxyCodeLine{993     Impl(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Action}{Action<VoidResult>}}\& action1, \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}}\& action2)}
\DoxyCodeLine{994         : action1\_(action1), action2\_(action2) \{\}}
\DoxyCodeLine{995 }
\DoxyCodeLine{996     \textcolor{keyword}{virtual} Result Perform(\textcolor{keyword}{const} ArgumentTuple\& args) \{}
\DoxyCodeLine{997       action1\_.Perform(args);}
\DoxyCodeLine{998       \textcolor{keywordflow}{return} action2\_.Perform(args);}
\DoxyCodeLine{999     \}}
\DoxyCodeLine{1000 }
\DoxyCodeLine{1001    \textcolor{keyword}{private}:}
\DoxyCodeLine{1002     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Action}{Action<VoidResult>}} action1\_;}
\DoxyCodeLine{1003     \textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Action}{Action<F>}} action2\_;}
\DoxyCodeLine{1004 }
\DoxyCodeLine{1005     GTEST\_DISALLOW\_ASSIGN\_(Impl);}
\DoxyCodeLine{1006   \};}
\DoxyCodeLine{1007 }
\DoxyCodeLine{1008   Action1 action1\_;}
\DoxyCodeLine{1009   Action2 action2\_;}
\DoxyCodeLine{1010 }
\DoxyCodeLine{1011   GTEST\_DISALLOW\_ASSIGN\_(\mbox{\hyperlink{classtesting_1_1internal_1_1DoBothAction}{DoBothAction}});}
\DoxyCodeLine{1012 \};}
\DoxyCodeLine{1013 }
\DoxyCodeLine{1014 \}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{1015 }
\DoxyCodeLine{1016 \textcolor{comment}{// An Unused object can be implicitly constructed from ANY value.}}
\DoxyCodeLine{1017 \textcolor{comment}{// This is handy when defining actions that ignore some or all of the}}
\DoxyCodeLine{1018 \textcolor{comment}{// mock function arguments.  For example, given}}
\DoxyCodeLine{1019 \textcolor{comment}{//}}
\DoxyCodeLine{1020 \textcolor{comment}{//   MOCK\_METHOD3(Foo, double(const string\& label, double x, double y));}}
\DoxyCodeLine{1021 \textcolor{comment}{//   MOCK\_METHOD3(Bar, double(int index, double x, double y));}}
\DoxyCodeLine{1022 \textcolor{comment}{//}}
\DoxyCodeLine{1023 \textcolor{comment}{// instead of}}
\DoxyCodeLine{1024 \textcolor{comment}{//}}
\DoxyCodeLine{1025 \textcolor{comment}{//   double DistanceToOriginWithLabel(const string\& label, double x, double y) \{}}
\DoxyCodeLine{1026 \textcolor{comment}{//     return sqrt(x*x + y*y);}}
\DoxyCodeLine{1027 \textcolor{comment}{//   \}}}
\DoxyCodeLine{1028 \textcolor{comment}{//   double DistanceToOriginWithIndex(int index, double x, double y) \{}}
\DoxyCodeLine{1029 \textcolor{comment}{//     return sqrt(x*x + y*y);}}
\DoxyCodeLine{1030 \textcolor{comment}{//   \}}}
\DoxyCodeLine{1031 \textcolor{comment}{//   ...}}
\DoxyCodeLine{1032 \textcolor{comment}{//   EXEPCT\_CALL(mock, Foo("{}abc"{}, \_, \_))}}
\DoxyCodeLine{1033 \textcolor{comment}{//       .WillOnce(Invoke(DistanceToOriginWithLabel));}}
\DoxyCodeLine{1034 \textcolor{comment}{//   EXEPCT\_CALL(mock, Bar(5, \_, \_))}}
\DoxyCodeLine{1035 \textcolor{comment}{//       .WillOnce(Invoke(DistanceToOriginWithIndex));}}
\DoxyCodeLine{1036 \textcolor{comment}{//}}
\DoxyCodeLine{1037 \textcolor{comment}{// you could write}}
\DoxyCodeLine{1038 \textcolor{comment}{//}}
\DoxyCodeLine{1039 \textcolor{comment}{//   // We can declare any uninteresting argument as Unused.}}
\DoxyCodeLine{1040 \textcolor{comment}{//   double DistanceToOrigin(Unused, double x, double y) \{}}
\DoxyCodeLine{1041 \textcolor{comment}{//     return sqrt(x*x + y*y);}}
\DoxyCodeLine{1042 \textcolor{comment}{//   \}}}
\DoxyCodeLine{1043 \textcolor{comment}{//   ...}}
\DoxyCodeLine{1044 \textcolor{comment}{//   EXEPCT\_CALL(mock, Foo("{}abc"{}, \_, \_)).WillOnce(Invoke(DistanceToOrigin));}}
\DoxyCodeLine{1045 \textcolor{comment}{//   EXEPCT\_CALL(mock, Bar(5, \_, \_)).WillOnce(Invoke(DistanceToOrigin));}}
\DoxyCodeLine{1046 \textcolor{keyword}{typedef} \mbox{\hyperlink{classtesting_1_1internal_1_1IgnoredValue}{internal::IgnoredValue}} \mbox{\hyperlink{classtesting_1_1internal_1_1IgnoredValue}{Unused}};}
\DoxyCodeLine{1047 }
\DoxyCodeLine{1048 \textcolor{comment}{// This constructor allows us to turn an Action<From> object into an}}
\DoxyCodeLine{1049 \textcolor{comment}{// Action<To>, as long as To's arguments can be implicitly converted}}
\DoxyCodeLine{1050 \textcolor{comment}{// to From's and From's return type cann be implicitly converted to}}
\DoxyCodeLine{1051 \textcolor{comment}{// To's.}}
\DoxyCodeLine{1052 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To>}
\DoxyCodeLine{1053 \textcolor{keyword}{template} <\textcolor{keyword}{typename} From>}
\DoxyCodeLine{1054 \mbox{\hyperlink{classtesting_1_1Action}{Action<To>::Action}}(\textcolor{keyword}{const} \mbox{\hyperlink{classtesting_1_1Action}{Action<From>}}\& from)}
\DoxyCodeLine{1055     : impl\_(new internal::ActionAdaptor<To, From>(from)) \{\}}
\DoxyCodeLine{1056 }
\DoxyCodeLine{1057 \textcolor{comment}{// Creates an action that returns 'value'.  'value' is passed by value}}
\DoxyCodeLine{1058 \textcolor{comment}{// instead of const reference -\/ otherwise Return("{}string literal"{})}}
\DoxyCodeLine{1059 \textcolor{comment}{// will trigger a compiler error about using array as initializer.}}
\DoxyCodeLine{1060 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R>}
\DoxyCodeLine{1061 internal::ReturnAction<R> Return(R value) \{}
\DoxyCodeLine{1062   \textcolor{keywordflow}{return} internal::ReturnAction<R>(internal::move(value));}
\DoxyCodeLine{1063 \}}
\DoxyCodeLine{1064 }
\DoxyCodeLine{1065 \textcolor{comment}{// Creates an action that returns NULL.}}
\DoxyCodeLine{1066 \textcolor{keyword}{inline} PolymorphicAction<internal::ReturnNullAction> ReturnNull() \{}
\DoxyCodeLine{1067   \textcolor{keywordflow}{return} MakePolymorphicAction(internal::ReturnNullAction());}
\DoxyCodeLine{1068 \}}
\DoxyCodeLine{1069 }
\DoxyCodeLine{1070 \textcolor{comment}{// Creates an action that returns from a void function.}}
\DoxyCodeLine{1071 \textcolor{keyword}{inline} PolymorphicAction<internal::ReturnVoidAction> Return() \{}
\DoxyCodeLine{1072   \textcolor{keywordflow}{return} MakePolymorphicAction(internal::ReturnVoidAction());}
\DoxyCodeLine{1073 \}}
\DoxyCodeLine{1074 }
\DoxyCodeLine{1075 \textcolor{comment}{// Creates an action that returns the reference to a variable.}}
\DoxyCodeLine{1076 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R>}
\DoxyCodeLine{1077 \textcolor{keyword}{inline} internal::ReturnRefAction<R> ReturnRef(R\& x) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1078   \textcolor{keywordflow}{return} internal::ReturnRefAction<R>(x);}
\DoxyCodeLine{1079 \}}
\DoxyCodeLine{1080 }
\DoxyCodeLine{1081 \textcolor{comment}{// Creates an action that returns the reference to a copy of the}}
\DoxyCodeLine{1082 \textcolor{comment}{// argument.  The copy is created when the action is constructed and}}
\DoxyCodeLine{1083 \textcolor{comment}{// lives as long as the action.}}
\DoxyCodeLine{1084 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R>}
\DoxyCodeLine{1085 \textcolor{keyword}{inline} internal::ReturnRefOfCopyAction<R> ReturnRefOfCopy(\textcolor{keyword}{const} R\& x) \{}
\DoxyCodeLine{1086   \textcolor{keywordflow}{return} internal::ReturnRefOfCopyAction<R>(x);}
\DoxyCodeLine{1087 \}}
\DoxyCodeLine{1088 }
\DoxyCodeLine{1089 \textcolor{comment}{// Modifies the parent action (a Return() action) to perform a move of the}}
\DoxyCodeLine{1090 \textcolor{comment}{// argument instead of a copy.}}
\DoxyCodeLine{1091 \textcolor{comment}{// Return(ByMove()) actions can only be executed once and will assert this}}
\DoxyCodeLine{1092 \textcolor{comment}{// invariant.}}
\DoxyCodeLine{1093 \textcolor{keyword}{template} <\textcolor{keyword}{typename} R>}
\DoxyCodeLine{1094 internal::ByMoveWrapper<R> ByMove(R x) \{}
\DoxyCodeLine{1095   \textcolor{keywordflow}{return} internal::ByMoveWrapper<R>(internal::move(x));}
\DoxyCodeLine{1096 \}}
\DoxyCodeLine{1097 }
\DoxyCodeLine{1098 \textcolor{comment}{// Creates an action that does the default action for the give mock function.}}
\DoxyCodeLine{1099 \textcolor{keyword}{inline} internal::DoDefaultAction DoDefault() \{}
\DoxyCodeLine{1100   \textcolor{keywordflow}{return} internal::DoDefaultAction();}
\DoxyCodeLine{1101 \}}
\DoxyCodeLine{1102 }
\DoxyCodeLine{1103 \textcolor{comment}{// Creates an action that sets the variable pointed by the N-\/th}}
\DoxyCodeLine{1104 \textcolor{comment}{// (0-\/based) function argument to 'value'.}}
\DoxyCodeLine{1105 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1106 PolymorphicAction<}
\DoxyCodeLine{1107   internal::SetArgumentPointeeAction<}
\DoxyCodeLine{1108     N, T, internal::IsAProtocolMessage<T>::value> >}
\DoxyCodeLine{1109 SetArgPointee(\textcolor{keyword}{const} T\& x) \{}
\DoxyCodeLine{1110   \textcolor{keywordflow}{return} MakePolymorphicAction(internal::SetArgumentPointeeAction<}
\DoxyCodeLine{1111       N, T, internal::IsAProtocolMessage<T>::value>(x));}
\DoxyCodeLine{1112 \}}
\DoxyCodeLine{1113 }
\DoxyCodeLine{1114 \textcolor{preprocessor}{\#if !((GTEST\_GCC\_VER\_ \&\& GTEST\_GCC\_VER\_ < 40000) || GTEST\_OS\_SYMBIAN)}}
\DoxyCodeLine{1115 \textcolor{comment}{// This overload allows SetArgPointee() to accept a string literal.}}
\DoxyCodeLine{1116 \textcolor{comment}{// GCC prior to the version 4.0 and Symbian C++ compiler cannot distinguish}}
\DoxyCodeLine{1117 \textcolor{comment}{// this overload from the templated version and emit a compile error.}}
\DoxyCodeLine{1118 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{1119 PolymorphicAction<}
\DoxyCodeLine{1120   internal::SetArgumentPointeeAction<N, const char*, false> >}
\DoxyCodeLine{1121 SetArgPointee(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* p) \{}
\DoxyCodeLine{1122   \textcolor{keywordflow}{return} MakePolymorphicAction(internal::SetArgumentPointeeAction<}
\DoxyCodeLine{1123       N, \textcolor{keyword}{const} \textcolor{keywordtype}{char}*, \textcolor{keyword}{false}>(p));}
\DoxyCodeLine{1124 \}}
\DoxyCodeLine{1125 }
\DoxyCodeLine{1126 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{1127 PolymorphicAction<}
\DoxyCodeLine{1128   internal::SetArgumentPointeeAction<N, const wchar\_t*, false> >}
\DoxyCodeLine{1129 SetArgPointee(\textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* p) \{}
\DoxyCodeLine{1130   \textcolor{keywordflow}{return} MakePolymorphicAction(internal::SetArgumentPointeeAction<}
\DoxyCodeLine{1131       N, \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}*, \textcolor{keyword}{false}>(p));}
\DoxyCodeLine{1132 \}}
\DoxyCodeLine{1133 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1134 }
\DoxyCodeLine{1135 \textcolor{comment}{// The following version is DEPRECATED.}}
\DoxyCodeLine{1136 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} N, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1137 PolymorphicAction<}
\DoxyCodeLine{1138   internal::SetArgumentPointeeAction<}
\DoxyCodeLine{1139     N, T, internal::IsAProtocolMessage<T>::value> >}
\DoxyCodeLine{1140 SetArgumentPointee(\textcolor{keyword}{const} T\& x) \{}
\DoxyCodeLine{1141   \textcolor{keywordflow}{return} MakePolymorphicAction(internal::SetArgumentPointeeAction<}
\DoxyCodeLine{1142       N, T, internal::IsAProtocolMessage<T>::value>(x));}
\DoxyCodeLine{1143 \}}
\DoxyCodeLine{1144 }
\DoxyCodeLine{1145 \textcolor{comment}{// Creates an action that sets a pointer referent to a given value.}}
\DoxyCodeLine{1146 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1147 PolymorphicAction<internal::AssignAction<T1, T2> > Assign(T1* ptr, T2 val) \{}
\DoxyCodeLine{1148   \textcolor{keywordflow}{return} MakePolymorphicAction(internal::AssignAction<T1, T2>(ptr, val));}
\DoxyCodeLine{1149 \}}
\DoxyCodeLine{1150 }
\DoxyCodeLine{1151 \textcolor{preprocessor}{\#if !GTEST\_OS\_WINDOWS\_MOBILE}}
\DoxyCodeLine{1152 }
\DoxyCodeLine{1153 \textcolor{comment}{// Creates an action that sets errno and returns the appropriate error.}}
\DoxyCodeLine{1154 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1155 PolymorphicAction<internal::SetErrnoAndReturnAction<T> >}
\DoxyCodeLine{1156 SetErrnoAndReturn(\textcolor{keywordtype}{int} errval, T result) \{}
\DoxyCodeLine{1157   \textcolor{keywordflow}{return} MakePolymorphicAction(}
\DoxyCodeLine{1158       internal::SetErrnoAndReturnAction<T>(errval, result));}
\DoxyCodeLine{1159 \}}
\DoxyCodeLine{1160 }
\DoxyCodeLine{1161 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// !GTEST\_OS\_WINDOWS\_MOBILE}}
\DoxyCodeLine{1162 }
\DoxyCodeLine{1163 \textcolor{comment}{// Various overloads for InvokeWithoutArgs().}}
\DoxyCodeLine{1164 }
\DoxyCodeLine{1165 \textcolor{comment}{// Creates an action that invokes 'function\_impl' with no argument.}}
\DoxyCodeLine{1166 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FunctionImpl>}
\DoxyCodeLine{1167 PolymorphicAction<internal::InvokeWithoutArgsAction<FunctionImpl> >}
\DoxyCodeLine{1168 InvokeWithoutArgs(FunctionImpl function\_impl) \{}
\DoxyCodeLine{1169   \textcolor{keywordflow}{return} MakePolymorphicAction(}
\DoxyCodeLine{1170       internal::InvokeWithoutArgsAction<FunctionImpl>(function\_impl));}
\DoxyCodeLine{1171 \}}
\DoxyCodeLine{1172 }
\DoxyCodeLine{1173 \textcolor{comment}{// Creates an action that invokes the given method on the given object}}
\DoxyCodeLine{1174 \textcolor{comment}{// with no argument.}}
\DoxyCodeLine{1175 \textcolor{keyword}{template} <\textcolor{keyword}{class} Class, \textcolor{keyword}{typename} MethodPtr>}
\DoxyCodeLine{1176 PolymorphicAction<internal::InvokeMethodWithoutArgsAction<Class, MethodPtr> >}
\DoxyCodeLine{1177 InvokeWithoutArgs(Class* obj\_ptr, MethodPtr method\_ptr) \{}
\DoxyCodeLine{1178   \textcolor{keywordflow}{return} MakePolymorphicAction(}
\DoxyCodeLine{1179       internal::InvokeMethodWithoutArgsAction<Class, MethodPtr>(}
\DoxyCodeLine{1180           obj\_ptr, method\_ptr));}
\DoxyCodeLine{1181 \}}
\DoxyCodeLine{1182 }
\DoxyCodeLine{1183 \textcolor{comment}{// Creates an action that performs an\_action and throws away its}}
\DoxyCodeLine{1184 \textcolor{comment}{// result.  In other words, it changes the return type of an\_action to}}
\DoxyCodeLine{1185 \textcolor{comment}{// void.  an\_action MUST NOT return void, or the code won't compile.}}
\DoxyCodeLine{1186 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A>}
\DoxyCodeLine{1187 \textcolor{keyword}{inline} internal::IgnoreResultAction<A> IgnoreResult(\textcolor{keyword}{const} A\& an\_action) \{}
\DoxyCodeLine{1188   \textcolor{keywordflow}{return} internal::IgnoreResultAction<A>(an\_action);}
\DoxyCodeLine{1189 \}}
\DoxyCodeLine{1190 }
\DoxyCodeLine{1191 \textcolor{comment}{// Creates a reference wrapper for the given L-\/value.  If necessary,}}
\DoxyCodeLine{1192 \textcolor{comment}{// you can explicitly specify the type of the reference.  For example,}}
\DoxyCodeLine{1193 \textcolor{comment}{// suppose 'derived' is an object of type Derived, ByRef(derived)}}
\DoxyCodeLine{1194 \textcolor{comment}{// would wrap a Derived\&.  If you want to wrap a const Base\& instead,}}
\DoxyCodeLine{1195 \textcolor{comment}{// where Base is a base class of Derived, just write:}}
\DoxyCodeLine{1196 \textcolor{comment}{//}}
\DoxyCodeLine{1197 \textcolor{comment}{//   ByRef<const Base>(derived)}}
\DoxyCodeLine{1198 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1199 \textcolor{keyword}{inline} internal::ReferenceWrapper<T> ByRef(T\& l\_value) \{  \textcolor{comment}{// NOLINT}}
\DoxyCodeLine{1200   \textcolor{keywordflow}{return} internal::ReferenceWrapper<T>(l\_value);}
\DoxyCodeLine{1201 \}}
\DoxyCodeLine{1202 }
\DoxyCodeLine{1203 \}  \textcolor{comment}{// namespace testing}}
\DoxyCodeLine{1204 }
\DoxyCodeLine{1205 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// GMOCK\_INCLUDE\_GMOCK\_GMOCK\_ACTIONS\_H\_}}

\end{DoxyCode}
