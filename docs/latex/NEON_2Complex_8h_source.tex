\hypertarget{NEON_2Complex_8h_source}{}\doxysection{Complex.\+h}
\label{NEON_2Complex_8h_source}\index{include/Eigen/src/Core/arch/NEON/Complex.h@{include/Eigen/src/Core/arch/NEON/Complex.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}}
\DoxyCodeLine{2 \textcolor{comment}{// for linear algebra.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Copyright (C) 2010 Gael Guennebaud <gael.guennebaud@inria.fr>}}
\DoxyCodeLine{5 \textcolor{comment}{// Copyright (C) 2010 Konstantinos Margaritis <markos@freevec.org>}}
\DoxyCodeLine{6 \textcolor{comment}{//}}
\DoxyCodeLine{7 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}}
\DoxyCodeLine{8 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}}
\DoxyCodeLine{9 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#ifndef EIGEN\_COMPLEX\_NEON\_H}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#define EIGEN\_COMPLEX\_NEON\_H}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include "{}../../InternalHeaderCheck.h"{}}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceEigen}{Eigen}} \{}
\DoxyCodeLine{17 }
\DoxyCodeLine{18 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{keyword}{inline} uint32x4\_t p4ui\_CONJ\_XOR()}
\DoxyCodeLine{21 \{}
\DoxyCodeLine{22 \textcolor{comment}{// See bug 1325, clang fails to call vld1q\_u64.}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#if EIGEN\_COMP\_CLANG || EIGEN\_COMP\_CASTXML}}
\DoxyCodeLine{24   uint32x4\_t ret = \{ 0x00000000, 0x80000000, 0x00000000, 0x80000000 \};}
\DoxyCodeLine{25   \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{27   \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t conj\_XOR\_DATA[] = \{ 0x00000000, 0x80000000, 0x00000000, 0x80000000 \};}
\DoxyCodeLine{28   \textcolor{keywordflow}{return} vld1q\_u32( conj\_XOR\_DATA );}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{30 \}}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{keyword}{inline} uint32x2\_t p2ui\_CONJ\_XOR()}
\DoxyCodeLine{33 \{}
\DoxyCodeLine{34   \textcolor{keyword}{static} \textcolor{keyword}{const} uint32\_t conj\_XOR\_DATA[] = \{ 0x00000000, 0x80000000 \};}
\DoxyCodeLine{35   \textcolor{keywordflow}{return} vld1\_u32( conj\_XOR\_DATA );}
\DoxyCodeLine{36 \}}
\DoxyCodeLine{37 }
\DoxyCodeLine{38 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ float -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{39 }
\DoxyCodeLine{40 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1Packet1cf}{Packet1cf}}}
\DoxyCodeLine{41 \{}
\DoxyCodeLine{42   EIGEN\_STRONG\_INLINE \mbox{\hyperlink{structEigen_1_1internal_1_1Packet1cf}{Packet1cf}}() \{\}}
\DoxyCodeLine{43   EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} \mbox{\hyperlink{structEigen_1_1internal_1_1Packet1cf}{Packet1cf}}(\textcolor{keyword}{const} Packet2f\& a) : v(a) \{\}}
\DoxyCodeLine{44   Packet2f v;}
\DoxyCodeLine{45 \};}
\DoxyCodeLine{46 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1Packet2cf}{Packet2cf}}}
\DoxyCodeLine{47 \{}
\DoxyCodeLine{48   EIGEN\_STRONG\_INLINE \mbox{\hyperlink{structEigen_1_1internal_1_1Packet2cf}{Packet2cf}}() \{\}}
\DoxyCodeLine{49   EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} Packet2cf(\textcolor{keyword}{const} Packet4f\& a) : v(a) \{\}}
\DoxyCodeLine{50   Packet4f v;}
\DoxyCodeLine{51 \};}
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<std::complex<float> > : default\_packet\_traits}
\DoxyCodeLine{54 \{}
\DoxyCodeLine{55   \textcolor{keyword}{typedef} Packet2cf type;}
\DoxyCodeLine{56   \textcolor{keyword}{typedef} Packet1cf half;}
\DoxyCodeLine{57   \textcolor{keyword}{enum}}
\DoxyCodeLine{58   \{}
\DoxyCodeLine{59     Vectorizable = 1,}
\DoxyCodeLine{60     AlignedOnScalar = 1,}
\DoxyCodeLine{61     size = 2,}
\DoxyCodeLine{62     HasHalfPacket = 1,}
\DoxyCodeLine{63 }
\DoxyCodeLine{64     HasAdd       = 1,}
\DoxyCodeLine{65     HasSub       = 1,}
\DoxyCodeLine{66     HasMul       = 1,}
\DoxyCodeLine{67     HasDiv       = 1,}
\DoxyCodeLine{68     HasNegate    = 1,}
\DoxyCodeLine{69     HasAbs       = 0,}
\DoxyCodeLine{70     HasAbs2      = 0,}
\DoxyCodeLine{71     HasMin       = 0,}
\DoxyCodeLine{72     HasMax       = 0,}
\DoxyCodeLine{73     HasSetLinear = 0}
\DoxyCodeLine{74   \};}
\DoxyCodeLine{75 \};}
\DoxyCodeLine{76 }
\DoxyCodeLine{77 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1unpacket__traits}{unpacket\_traits}}<\mbox{\hyperlink{structEigen_1_1internal_1_1Packet1cf}{Packet1cf}}>}
\DoxyCodeLine{78 \{}
\DoxyCodeLine{79   \textcolor{keyword}{typedef} std::complex<float> type;}
\DoxyCodeLine{80   \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1internal_1_1Packet1cf}{Packet1cf}} \mbox{\hyperlink{structEigen_1_1internal_1_1Packet1cf}{half}};}
\DoxyCodeLine{81   \textcolor{keyword}{typedef} Packet2f as\_real;}
\DoxyCodeLine{82   \textcolor{keyword}{enum}}
\DoxyCodeLine{83   \{}
\DoxyCodeLine{84     size = 1,}
\DoxyCodeLine{85     alignment = \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad0b140cd97bc74365b51843d28379655}{Aligned16}},}
\DoxyCodeLine{86     vectorizable = \textcolor{keyword}{true},}
\DoxyCodeLine{87     masked\_load\_available = \textcolor{keyword}{false},}
\DoxyCodeLine{88     masked\_store\_available = \textcolor{keyword}{false}}
\DoxyCodeLine{89   \};}
\DoxyCodeLine{90 \};}
\DoxyCodeLine{91 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1unpacket__traits}{unpacket\_traits}}<\mbox{\hyperlink{structEigen_1_1internal_1_1Packet2cf}{Packet2cf}}>}
\DoxyCodeLine{92 \{}
\DoxyCodeLine{93   \textcolor{keyword}{typedef} std::complex<float> type;}
\DoxyCodeLine{94   \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1internal_1_1Packet1cf}{Packet1cf}} \mbox{\hyperlink{structEigen_1_1half}{half}};}
\DoxyCodeLine{95   \textcolor{keyword}{typedef} Packet4f as\_real;}
\DoxyCodeLine{96   \textcolor{keyword}{enum}}
\DoxyCodeLine{97   \{}
\DoxyCodeLine{98     size = 2,}
\DoxyCodeLine{99     alignment = \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad0b140cd97bc74365b51843d28379655}{Aligned16}},}
\DoxyCodeLine{100     vectorizable = \textcolor{keyword}{true},}
\DoxyCodeLine{101     masked\_load\_available = \textcolor{keyword}{false},}
\DoxyCodeLine{102     masked\_store\_available = \textcolor{keyword}{false}}
\DoxyCodeLine{103   \};}
\DoxyCodeLine{104 \};}
\DoxyCodeLine{105 }
\DoxyCodeLine{106 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf pcast<float,Packet1cf>(\textcolor{keyword}{const} \textcolor{keywordtype}{float}\& a)}
\DoxyCodeLine{107 \{ \textcolor{keywordflow}{return} Packet1cf(vset\_lane\_f32(a, vdup\_n\_f32(0.f), 0)); \}}
\DoxyCodeLine{108 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pcast<Packet2f,Packet2cf>(\textcolor{keyword}{const} Packet2f\& a)}
\DoxyCodeLine{109 \{ \textcolor{keywordflow}{return} Packet2cf(vreinterpretq\_f32\_u64(vmovl\_u32(vreinterpret\_u32\_f32(a)))); \}}
\DoxyCodeLine{110 }
\DoxyCodeLine{111 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf pset1<Packet1cf>(\textcolor{keyword}{const} std::complex<float>\& from)}
\DoxyCodeLine{112 \{ \textcolor{keywordflow}{return} Packet1cf(vld1\_f32(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(\&from))); \}}
\DoxyCodeLine{113 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pset1<Packet2cf>(\textcolor{keyword}{const} std::complex<float>\& from)}
\DoxyCodeLine{114 \{}
\DoxyCodeLine{115   \textcolor{keyword}{const} float32x2\_t r64 = vld1\_f32(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(\&from));}
\DoxyCodeLine{116   \textcolor{keywordflow}{return} Packet2cf(vcombine\_f32(r64, r64));}
\DoxyCodeLine{117 \}}
\DoxyCodeLine{118 }
\DoxyCodeLine{119 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf padd<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a, \textcolor{keyword}{const} Packet1cf\& b)}
\DoxyCodeLine{120 \{ \textcolor{keywordflow}{return} Packet1cf(padd<Packet2f>(a.v, b.v)); \}}
\DoxyCodeLine{121 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf padd<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a, \textcolor{keyword}{const} Packet2cf\& b)}
\DoxyCodeLine{122 \{ \textcolor{keywordflow}{return} Packet2cf(padd<Packet4f>(a.v, b.v)); \}}
\DoxyCodeLine{123 }
\DoxyCodeLine{124 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf psub<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a, \textcolor{keyword}{const} Packet1cf\& b)}
\DoxyCodeLine{125 \{ \textcolor{keywordflow}{return} Packet1cf(psub<Packet2f>(a.v, b.v)); \}}
\DoxyCodeLine{126 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf psub<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a, \textcolor{keyword}{const} Packet2cf\& b)}
\DoxyCodeLine{127 \{ \textcolor{keywordflow}{return} Packet2cf(psub<Packet4f>(a.v, b.v)); \}}
\DoxyCodeLine{128 }
\DoxyCodeLine{129 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf pnegate(\textcolor{keyword}{const} Packet1cf\& a) \{ \textcolor{keywordflow}{return} Packet1cf(pnegate<Packet2f>(a.v)); \}}
\DoxyCodeLine{130 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pnegate(\textcolor{keyword}{const} Packet2cf\& a) \{ \textcolor{keywordflow}{return} Packet2cf(pnegate<Packet4f>(a.v)); \}}
\DoxyCodeLine{131 }
\DoxyCodeLine{132 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf pconj(\textcolor{keyword}{const} Packet1cf\& a)}
\DoxyCodeLine{133 \{}
\DoxyCodeLine{134   \textcolor{keyword}{const} Packet2ui b = vreinterpret\_u32\_f32(a.v);}
\DoxyCodeLine{135   \textcolor{keywordflow}{return} Packet1cf(vreinterpret\_f32\_u32(veor\_u32(b, p2ui\_CONJ\_XOR())));}
\DoxyCodeLine{136 \}}
\DoxyCodeLine{137 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pconj(\textcolor{keyword}{const} Packet2cf\& a)}
\DoxyCodeLine{138 \{}
\DoxyCodeLine{139   \textcolor{keyword}{const} Packet4ui b = vreinterpretq\_u32\_f32(a.v);}
\DoxyCodeLine{140   \textcolor{keywordflow}{return} Packet2cf(vreinterpretq\_f32\_u32(veorq\_u32(b, p4ui\_CONJ\_XOR())));}
\DoxyCodeLine{141 \}}
\DoxyCodeLine{142 }
\DoxyCodeLine{143 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf pmul<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a, \textcolor{keyword}{const} Packet1cf\& b)}
\DoxyCodeLine{144 \{}
\DoxyCodeLine{145   Packet2f v1, v2;}
\DoxyCodeLine{146 }
\DoxyCodeLine{147   \textcolor{comment}{// Get the real values of a | a1\_re | a1\_re |}}
\DoxyCodeLine{148   v1 = vdup\_lane\_f32(a.v, 0);}
\DoxyCodeLine{149   \textcolor{comment}{// Get the imag values of a | a1\_im | a1\_im |}}
\DoxyCodeLine{150   v2 = vdup\_lane\_f32(a.v, 1);}
\DoxyCodeLine{151   \textcolor{comment}{// Multiply the real a with b}}
\DoxyCodeLine{152   v1 = vmul\_f32(v1, b.v);}
\DoxyCodeLine{153   \textcolor{comment}{// Multiply the imag a with b}}
\DoxyCodeLine{154   v2 = vmul\_f32(v2, b.v);}
\DoxyCodeLine{155   \textcolor{comment}{// Conjugate v2}}
\DoxyCodeLine{156   v2 = vreinterpret\_f32\_u32(veor\_u32(vreinterpret\_u32\_f32(v2), p2ui\_CONJ\_XOR()));}
\DoxyCodeLine{157   \textcolor{comment}{// Swap real/imag elements in v2.}}
\DoxyCodeLine{158   v2 = vrev64\_f32(v2);}
\DoxyCodeLine{159   \textcolor{comment}{// Add and return the result}}
\DoxyCodeLine{160   \textcolor{keywordflow}{return} Packet1cf(vadd\_f32(v1, v2));}
\DoxyCodeLine{161 \}}
\DoxyCodeLine{162 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pmul<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a, \textcolor{keyword}{const} Packet2cf\& b)}
\DoxyCodeLine{163 \{}
\DoxyCodeLine{164   Packet4f v1, v2;}
\DoxyCodeLine{165 }
\DoxyCodeLine{166   \textcolor{comment}{// Get the real values of a | a1\_re | a1\_re | a2\_re | a2\_re |}}
\DoxyCodeLine{167   v1 = vcombine\_f32(vdup\_lane\_f32(vget\_low\_f32(a.v), 0), vdup\_lane\_f32(vget\_high\_f32(a.v), 0));}
\DoxyCodeLine{168   \textcolor{comment}{// Get the imag values of a | a1\_im | a1\_im | a2\_im | a2\_im |}}
\DoxyCodeLine{169   v2 = vcombine\_f32(vdup\_lane\_f32(vget\_low\_f32(a.v), 1), vdup\_lane\_f32(vget\_high\_f32(a.v), 1));}
\DoxyCodeLine{170   \textcolor{comment}{// Multiply the real a with b}}
\DoxyCodeLine{171   v1 = vmulq\_f32(v1, b.v);}
\DoxyCodeLine{172   \textcolor{comment}{// Multiply the imag a with b}}
\DoxyCodeLine{173   v2 = vmulq\_f32(v2, b.v);}
\DoxyCodeLine{174   \textcolor{comment}{// Conjugate v2}}
\DoxyCodeLine{175   v2 = vreinterpretq\_f32\_u32(veorq\_u32(vreinterpretq\_u32\_f32(v2), p4ui\_CONJ\_XOR()));}
\DoxyCodeLine{176   \textcolor{comment}{// Swap real/imag elements in v2.}}
\DoxyCodeLine{177   v2 = vrev64q\_f32(v2);}
\DoxyCodeLine{178   \textcolor{comment}{// Add and return the result}}
\DoxyCodeLine{179   \textcolor{keywordflow}{return} Packet2cf(vaddq\_f32(v1, v2));}
\DoxyCodeLine{180 \}}
\DoxyCodeLine{181 }
\DoxyCodeLine{182 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf pcmp\_eq(\textcolor{keyword}{const} Packet1cf\& a, \textcolor{keyword}{const} Packet1cf\& b)}
\DoxyCodeLine{183 \{}
\DoxyCodeLine{184   \textcolor{comment}{// Compare real and imaginary parts of a and b to get the mask vector:}}
\DoxyCodeLine{185   \textcolor{comment}{// [re(a[0])==re(b[0]), im(a[0])==im(b[0])]}}
\DoxyCodeLine{186   Packet2f eq = pcmp\_eq<Packet2f>(a.v, b.v);}
\DoxyCodeLine{187   \textcolor{comment}{// Swap real/imag elements in the mask in to get:}}
\DoxyCodeLine{188   \textcolor{comment}{// [im(a[0])==im(b[0]), re(a[0])==re(b[0])]}}
\DoxyCodeLine{189   Packet2f eq\_swapped = vrev64\_f32(eq);}
\DoxyCodeLine{190   \textcolor{comment}{// Return re(a)==re(b) \&\& im(a)==im(b) by computing bitwise AND of eq and eq\_swapped}}
\DoxyCodeLine{191   \textcolor{keywordflow}{return} Packet1cf(pand<Packet2f>(eq, eq\_swapped));}
\DoxyCodeLine{192 \}}
\DoxyCodeLine{193 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pcmp\_eq(\textcolor{keyword}{const} Packet2cf\& a, \textcolor{keyword}{const} Packet2cf\& b)}
\DoxyCodeLine{194 \{}
\DoxyCodeLine{195   \textcolor{comment}{// Compare real and imaginary parts of a and b to get the mask vector:}}
\DoxyCodeLine{196   \textcolor{comment}{// [re(a[0])==re(b[0]), im(a[0])==im(b[0]), re(a[1])==re(b[1]), im(a[1])==im(b[1])]}}
\DoxyCodeLine{197   Packet4f eq = pcmp\_eq<Packet4f>(a.v, b.v);}
\DoxyCodeLine{198   \textcolor{comment}{// Swap real/imag elements in the mask in to get:}}
\DoxyCodeLine{199   \textcolor{comment}{// [im(a[0])==im(b[0]), re(a[0])==re(b[0]), im(a[1])==im(b[1]), re(a[1])==re(b[1])]}}
\DoxyCodeLine{200   Packet4f eq\_swapped = vrev64q\_f32(eq);}
\DoxyCodeLine{201   \textcolor{comment}{// Return re(a)==re(b) \&\& im(a)==im(b) by computing bitwise AND of eq and eq\_swapped}}
\DoxyCodeLine{202   \textcolor{keywordflow}{return} Packet2cf(pand<Packet4f>(eq, eq\_swapped));}
\DoxyCodeLine{203 \}}
\DoxyCodeLine{204 }
\DoxyCodeLine{205 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf pand<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a, \textcolor{keyword}{const} Packet1cf\& b)}
\DoxyCodeLine{206 \{ \textcolor{keywordflow}{return} Packet1cf(vreinterpret\_f32\_u32(vand\_u32(vreinterpret\_u32\_f32(a.v), vreinterpret\_u32\_f32(b.v)))); \}}
\DoxyCodeLine{207 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pand<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a, \textcolor{keyword}{const} Packet2cf\& b)}
\DoxyCodeLine{208 \{ \textcolor{keywordflow}{return} Packet2cf(vreinterpretq\_f32\_u32(vandq\_u32(vreinterpretq\_u32\_f32(a.v), vreinterpretq\_u32\_f32(b.v)))); \}}
\DoxyCodeLine{209 }
\DoxyCodeLine{210 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf por<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a, \textcolor{keyword}{const} Packet1cf\& b)}
\DoxyCodeLine{211 \{ \textcolor{keywordflow}{return} Packet1cf(vreinterpret\_f32\_u32(vorr\_u32(vreinterpret\_u32\_f32(a.v), vreinterpret\_u32\_f32(b.v)))); \}}
\DoxyCodeLine{212 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf por<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a, \textcolor{keyword}{const} Packet2cf\& b)}
\DoxyCodeLine{213 \{ \textcolor{keywordflow}{return} Packet2cf(vreinterpretq\_f32\_u32(vorrq\_u32(vreinterpretq\_u32\_f32(a.v), vreinterpretq\_u32\_f32(b.v)))); \}}
\DoxyCodeLine{214 }
\DoxyCodeLine{215 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf pxor<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a, \textcolor{keyword}{const} Packet1cf\& b)}
\DoxyCodeLine{216 \{ \textcolor{keywordflow}{return} Packet1cf(vreinterpret\_f32\_u32(veor\_u32(vreinterpret\_u32\_f32(a.v), vreinterpret\_u32\_f32(b.v)))); \}}
\DoxyCodeLine{217 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pxor<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a, \textcolor{keyword}{const} Packet2cf\& b)}
\DoxyCodeLine{218 \{ \textcolor{keywordflow}{return} Packet2cf(vreinterpretq\_f32\_u32(veorq\_u32(vreinterpretq\_u32\_f32(a.v), vreinterpretq\_u32\_f32(b.v)))); \}}
\DoxyCodeLine{219 }
\DoxyCodeLine{220 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf pandnot<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a, \textcolor{keyword}{const} Packet1cf\& b)}
\DoxyCodeLine{221 \{ \textcolor{keywordflow}{return} Packet1cf(vreinterpret\_f32\_u32(vbic\_u32(vreinterpret\_u32\_f32(a.v), vreinterpret\_u32\_f32(b.v)))); \}}
\DoxyCodeLine{222 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pandnot<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a, \textcolor{keyword}{const} Packet2cf\& b)}
\DoxyCodeLine{223 \{ \textcolor{keywordflow}{return} Packet2cf(vreinterpretq\_f32\_u32(vbicq\_u32(vreinterpretq\_u32\_f32(a.v), vreinterpretq\_u32\_f32(b.v)))); \}}
\DoxyCodeLine{224 }
\DoxyCodeLine{225 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf pload<Packet1cf>(\textcolor{keyword}{const} std::complex<float>* from)}
\DoxyCodeLine{226 \{ EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{return} Packet1cf(pload<Packet2f>((\textcolor{keyword}{const} \textcolor{keywordtype}{float}*)from)); \}}
\DoxyCodeLine{227 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pload<Packet2cf>(\textcolor{keyword}{const} std::complex<float>* from)}
\DoxyCodeLine{228 \{ EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{return} Packet2cf(pload<Packet4f>(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(from))); \}}
\DoxyCodeLine{229 }
\DoxyCodeLine{230 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf ploadu<Packet1cf>(\textcolor{keyword}{const} std::complex<float>* from)}
\DoxyCodeLine{231 \{ EIGEN\_DEBUG\_UNALIGNED\_LOAD \textcolor{keywordflow}{return} Packet1cf(ploadu<Packet2f>((\textcolor{keyword}{const} \textcolor{keywordtype}{float}*)from)); \}}
\DoxyCodeLine{232 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf ploadu<Packet2cf>(\textcolor{keyword}{const} std::complex<float>* from)}
\DoxyCodeLine{233 \{ EIGEN\_DEBUG\_UNALIGNED\_LOAD \textcolor{keywordflow}{return} Packet2cf(ploadu<Packet4f>(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(from))); \}}
\DoxyCodeLine{234 }
\DoxyCodeLine{235 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf ploaddup<Packet1cf>(\textcolor{keyword}{const} std::complex<float>* from)}
\DoxyCodeLine{236 \{ \textcolor{keywordflow}{return} pset1<Packet1cf>(*from); \}}
\DoxyCodeLine{237 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf ploaddup<Packet2cf>(\textcolor{keyword}{const} std::complex<float>* from)}
\DoxyCodeLine{238 \{ \textcolor{keywordflow}{return} pset1<Packet2cf>(*from); \}}
\DoxyCodeLine{239 }
\DoxyCodeLine{240 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore <std::complex<float> >(std::complex<float> *to, \textcolor{keyword}{const} Packet1cf\& from)}
\DoxyCodeLine{241 \{ EIGEN\_DEBUG\_ALIGNED\_STORE pstore((\textcolor{keywordtype}{float}*)to, from.v); \}}
\DoxyCodeLine{242 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore <std::complex<float> >(std::complex<float> *to, \textcolor{keyword}{const} Packet2cf\& from)}
\DoxyCodeLine{243 \{ EIGEN\_DEBUG\_ALIGNED\_STORE pstore(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(to), from.v); \}}
\DoxyCodeLine{244 }
\DoxyCodeLine{245 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<std::complex<float> >(std::complex<float> *to, \textcolor{keyword}{const} Packet1cf\& from)}
\DoxyCodeLine{246 \{ EIGEN\_DEBUG\_UNALIGNED\_STORE pstoreu((\textcolor{keywordtype}{float}*)to, from.v); \}}
\DoxyCodeLine{247 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<std::complex<float> >(std::complex<float> *to, \textcolor{keyword}{const} Packet2cf\& from)}
\DoxyCodeLine{248 \{ EIGEN\_DEBUG\_UNALIGNED\_STORE pstoreu(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(to), from.v); \}}
\DoxyCodeLine{249 }
\DoxyCodeLine{250 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet1cf pgather<std::complex<float>, Packet1cf>(}
\DoxyCodeLine{251     \textcolor{keyword}{const} std::complex<float>* from, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} stride)}
\DoxyCodeLine{252 \{}
\DoxyCodeLine{253   \textcolor{keyword}{const} Packet2f tmp = vdup\_n\_f32(std::real(from[0*stride]));}
\DoxyCodeLine{254   \textcolor{keywordflow}{return} Packet1cf(vset\_lane\_f32(std::imag(from[0*stride]), tmp, 1));}
\DoxyCodeLine{255 \}}
\DoxyCodeLine{256 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet2cf pgather<std::complex<float>, Packet2cf>(}
\DoxyCodeLine{257     \textcolor{keyword}{const} std::complex<float>* from, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} stride)}
\DoxyCodeLine{258 \{}
\DoxyCodeLine{259   Packet4f res = vdupq\_n\_f32(std::real(from[0*stride]));}
\DoxyCodeLine{260   res = vsetq\_lane\_f32(std::imag(from[0*stride]), res, 1);}
\DoxyCodeLine{261   res = vsetq\_lane\_f32(std::real(from[1*stride]), res, 2);}
\DoxyCodeLine{262   res = vsetq\_lane\_f32(std::imag(from[1*stride]), res, 3);}
\DoxyCodeLine{263   \textcolor{keywordflow}{return} Packet2cf(res);}
\DoxyCodeLine{264 \}}
\DoxyCodeLine{265 }
\DoxyCodeLine{266 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<std::complex<float>, Packet1cf>(}
\DoxyCodeLine{267     std::complex<float>* to, \textcolor{keyword}{const} Packet1cf\& from, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} stride)}
\DoxyCodeLine{268 \{ to[stride*0] = std::complex<float>(vget\_lane\_f32(from.v, 0), vget\_lane\_f32(from.v, 1)); \}}
\DoxyCodeLine{269 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<std::complex<float>, Packet2cf>(}
\DoxyCodeLine{270     std::complex<float>* to, \textcolor{keyword}{const} Packet2cf\& from, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} stride)}
\DoxyCodeLine{271 \{}
\DoxyCodeLine{272   to[stride*0] = std::complex<float>(vgetq\_lane\_f32(from.v, 0), vgetq\_lane\_f32(from.v, 1));}
\DoxyCodeLine{273   to[stride*1] = std::complex<float>(vgetq\_lane\_f32(from.v, 2), vgetq\_lane\_f32(from.v, 3));}
\DoxyCodeLine{274 \}}
\DoxyCodeLine{275 }
\DoxyCodeLine{276 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<std::complex<float> >(\textcolor{keyword}{const} std::complex<float> *addr)}
\DoxyCodeLine{277 \{ EIGEN\_ARM\_PREFETCH(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(addr)); \}}
\DoxyCodeLine{278 }
\DoxyCodeLine{279 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> pfirst<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a)}
\DoxyCodeLine{280 \{}
\DoxyCodeLine{281   EIGEN\_ALIGN16 std::complex<float> x;}
\DoxyCodeLine{282   vst1\_f32(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(\&x), a.v);}
\DoxyCodeLine{283   \textcolor{keywordflow}{return} x;}
\DoxyCodeLine{284 \}}
\DoxyCodeLine{285 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> pfirst<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a)}
\DoxyCodeLine{286 \{}
\DoxyCodeLine{287   EIGEN\_ALIGN16 std::complex<float> x[2];}
\DoxyCodeLine{288   vst1q\_f32(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(x), a.v);}
\DoxyCodeLine{289   \textcolor{keywordflow}{return} x[0];}
\DoxyCodeLine{290 \}}
\DoxyCodeLine{291 }
\DoxyCodeLine{292 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf preverse(\textcolor{keyword}{const} Packet1cf\& a) \{ \textcolor{keywordflow}{return} a; \}}
\DoxyCodeLine{293 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf preverse(\textcolor{keyword}{const} Packet2cf\& a)}
\DoxyCodeLine{294 \{ \textcolor{keywordflow}{return} Packet2cf(vcombine\_f32(vget\_high\_f32(a.v), vget\_low\_f32(a.v))); \}}
\DoxyCodeLine{295 }
\DoxyCodeLine{296 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf pcplxflip<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a)}
\DoxyCodeLine{297 \{ \textcolor{keywordflow}{return} Packet1cf(vrev64\_f32(a.v)); \}}
\DoxyCodeLine{298 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pcplxflip<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a)}
\DoxyCodeLine{299 \{ \textcolor{keywordflow}{return} Packet2cf(vrev64q\_f32(a.v)); \}}
\DoxyCodeLine{300 }
\DoxyCodeLine{301 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> predux<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a)}
\DoxyCodeLine{302 \{}
\DoxyCodeLine{303   std::complex<float> s;}
\DoxyCodeLine{304   vst1\_f32((\textcolor{keywordtype}{float} *)\&s, a.v);}
\DoxyCodeLine{305   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{306 \}}
\DoxyCodeLine{307 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> predux<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a)}
\DoxyCodeLine{308 \{}
\DoxyCodeLine{309   std::complex<float> s;}
\DoxyCodeLine{310   vst1\_f32(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(\&s), vadd\_f32(vget\_low\_f32(a.v), vget\_high\_f32(a.v)));}
\DoxyCodeLine{311   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{312 \}}
\DoxyCodeLine{313 }
\DoxyCodeLine{314 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> predux\_mul<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a)}
\DoxyCodeLine{315 \{}
\DoxyCodeLine{316   std::complex<float> s;}
\DoxyCodeLine{317   vst1\_f32((\textcolor{keywordtype}{float} *)\&s, a.v);}
\DoxyCodeLine{318   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{319 \}}
\DoxyCodeLine{320 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<float> predux\_mul<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a)}
\DoxyCodeLine{321 \{}
\DoxyCodeLine{322   float32x2\_t a1, a2, v1, v2, prod;}
\DoxyCodeLine{323   std::complex<float> s;}
\DoxyCodeLine{324 }
\DoxyCodeLine{325   a1 = vget\_low\_f32(a.v);}
\DoxyCodeLine{326   a2 = vget\_high\_f32(a.v);}
\DoxyCodeLine{327    \textcolor{comment}{// Get the real values of a | a1\_re | a1\_re | a2\_re | a2\_re |}}
\DoxyCodeLine{328   v1 = vdup\_lane\_f32(a1, 0);}
\DoxyCodeLine{329   \textcolor{comment}{// Get the real values of a | a1\_im | a1\_im | a2\_im | a2\_im |}}
\DoxyCodeLine{330   v2 = vdup\_lane\_f32(a1, 1);}
\DoxyCodeLine{331   \textcolor{comment}{// Multiply the real a with b}}
\DoxyCodeLine{332   v1 = vmul\_f32(v1, a2);}
\DoxyCodeLine{333   \textcolor{comment}{// Multiply the imag a with b}}
\DoxyCodeLine{334   v2 = vmul\_f32(v2, a2);}
\DoxyCodeLine{335   \textcolor{comment}{// Conjugate v2}}
\DoxyCodeLine{336   v2 = vreinterpret\_f32\_u32(veor\_u32(vreinterpret\_u32\_f32(v2), p2ui\_CONJ\_XOR()));}
\DoxyCodeLine{337   \textcolor{comment}{// Swap real/imag elements in v2.}}
\DoxyCodeLine{338   v2 = vrev64\_f32(v2);}
\DoxyCodeLine{339   \textcolor{comment}{// Add v1, v2}}
\DoxyCodeLine{340   prod = vadd\_f32(v1, v2);}
\DoxyCodeLine{341 }
\DoxyCodeLine{342   vst1\_f32(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{float}*\textcolor{keyword}{>}(\&s), prod);}
\DoxyCodeLine{343 }
\DoxyCodeLine{344   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{345 \}}
\DoxyCodeLine{346 }
\DoxyCodeLine{347 EIGEN\_MAKE\_CONJ\_HELPER\_CPLX\_REAL(Packet1cf,Packet2f)}
\DoxyCodeLine{348 EIGEN\_MAKE\_CONJ\_HELPER\_CPLX\_REAL(Packet2cf,Packet4f)}
\DoxyCodeLine{349 }
\DoxyCodeLine{350 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf pdiv<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a, \textcolor{keyword}{const} Packet1cf\& b)}
\DoxyCodeLine{351 \{}
\DoxyCodeLine{352   \textcolor{keywordflow}{return} pdiv\_complex(a, b);}
\DoxyCodeLine{353 \}}
\DoxyCodeLine{354 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf pdiv<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a, \textcolor{keyword}{const} Packet2cf\& b)}
\DoxyCodeLine{355 \{}
\DoxyCodeLine{356   \textcolor{keywordflow}{return} pdiv\_complex(a, b);}
\DoxyCodeLine{357 \}}
\DoxyCodeLine{358 }
\DoxyCodeLine{359 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} ptranspose(PacketBlock<Packet1cf, 1>\& \textcolor{comment}{/*kernel*/}) \{\}}
\DoxyCodeLine{360 EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} ptranspose(PacketBlock<Packet2cf, 2>\& kernel)}
\DoxyCodeLine{361 \{}
\DoxyCodeLine{362   Packet4f tmp = vcombine\_f32(vget\_high\_f32(kernel.packet[0].v), vget\_high\_f32(kernel.packet[1].v));}
\DoxyCodeLine{363   kernel.packet[0].v = vcombine\_f32(vget\_low\_f32(kernel.packet[0].v), vget\_low\_f32(kernel.packet[1].v));}
\DoxyCodeLine{364   kernel.packet[1].v = tmp;}
\DoxyCodeLine{365 \}}
\DoxyCodeLine{366 }
\DoxyCodeLine{367 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cf psqrt<Packet1cf>(\textcolor{keyword}{const} Packet1cf\& a) \{}
\DoxyCodeLine{368   \textcolor{keywordflow}{return} psqrt\_complex<Packet1cf>(a);}
\DoxyCodeLine{369 \}}
\DoxyCodeLine{370 }
\DoxyCodeLine{371 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet2cf psqrt<Packet2cf>(\textcolor{keyword}{const} Packet2cf\& a) \{}
\DoxyCodeLine{372   \textcolor{keywordflow}{return} psqrt\_complex<Packet2cf>(a);}
\DoxyCodeLine{373 \}}
\DoxyCodeLine{374 }
\DoxyCodeLine{375 \textcolor{comment}{//-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ double -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{376 \textcolor{preprocessor}{\#if EIGEN\_ARCH\_ARM64 \&\& !EIGEN\_APPLE\_DOUBLE\_NEON\_BUG}}
\DoxyCodeLine{377 }
\DoxyCodeLine{378 \textcolor{comment}{// See bug 1325, clang fails to call vld1q\_u64.}}
\DoxyCodeLine{379 \textcolor{preprocessor}{\#if EIGEN\_COMP\_CLANG || EIGEN\_COMP\_CASTXML}}
\DoxyCodeLine{380   \textcolor{keyword}{static} uint64x2\_t p2ul\_CONJ\_XOR = \{0x0, 0x8000000000000000\};}
\DoxyCodeLine{381 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{382   \textcolor{keyword}{const} uint64\_t  p2ul\_conj\_XOR\_DATA[] = \{ 0x0, 0x8000000000000000 \};}
\DoxyCodeLine{383   \textcolor{keyword}{static} uint64x2\_t p2ul\_CONJ\_XOR = vld1q\_u64( p2ul\_conj\_XOR\_DATA );}
\DoxyCodeLine{384 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{385 }
\DoxyCodeLine{386 \textcolor{keyword}{struct }Packet1cd}
\DoxyCodeLine{387 \{}
\DoxyCodeLine{388   EIGEN\_STRONG\_INLINE Packet1cd() \{\}}
\DoxyCodeLine{389   EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} Packet1cd(\textcolor{keyword}{const} Packet2d\& a) : v(a) \{\}}
\DoxyCodeLine{390   Packet2d v;}
\DoxyCodeLine{391 \};}
\DoxyCodeLine{392 }
\DoxyCodeLine{393 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }packet\_traits<std::complex<double> >  : default\_packet\_traits}
\DoxyCodeLine{394 \{}
\DoxyCodeLine{395   \textcolor{keyword}{typedef} Packet1cd type;}
\DoxyCodeLine{396   \textcolor{keyword}{typedef} Packet1cd half;}
\DoxyCodeLine{397   \textcolor{keyword}{enum}}
\DoxyCodeLine{398   \{}
\DoxyCodeLine{399     Vectorizable = 1,}
\DoxyCodeLine{400     AlignedOnScalar = 0,}
\DoxyCodeLine{401     size = 1,}
\DoxyCodeLine{402     HasHalfPacket = 0,}
\DoxyCodeLine{403 }
\DoxyCodeLine{404     HasAdd    = 1,}
\DoxyCodeLine{405     HasSub    = 1,}
\DoxyCodeLine{406     HasMul    = 1,}
\DoxyCodeLine{407     HasDiv    = 1,}
\DoxyCodeLine{408     HasNegate = 1,}
\DoxyCodeLine{409     HasAbs    = 0,}
\DoxyCodeLine{410     HasAbs2   = 0,}
\DoxyCodeLine{411     HasMin    = 0,}
\DoxyCodeLine{412     HasMax    = 0,}
\DoxyCodeLine{413     HasSetLinear = 0}
\DoxyCodeLine{414   \};}
\DoxyCodeLine{415 \};}
\DoxyCodeLine{416 }
\DoxyCodeLine{417 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }unpacket\_traits<Packet1cd>}
\DoxyCodeLine{418 \{}
\DoxyCodeLine{419   \textcolor{keyword}{typedef} std::complex<double> type;}
\DoxyCodeLine{420   \textcolor{keyword}{typedef} Packet1cd half;}
\DoxyCodeLine{421   \textcolor{keyword}{typedef} Packet2d as\_real;}
\DoxyCodeLine{422   \textcolor{keyword}{enum}}
\DoxyCodeLine{423   \{}
\DoxyCodeLine{424     size=1,}
\DoxyCodeLine{425     alignment=\mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad0b140cd97bc74365b51843d28379655}{Aligned16}},}
\DoxyCodeLine{426     vectorizable=\textcolor{keyword}{true},}
\DoxyCodeLine{427     masked\_load\_available=\textcolor{keyword}{false},}
\DoxyCodeLine{428     masked\_store\_available=\textcolor{keyword}{false}}
\DoxyCodeLine{429   \};}
\DoxyCodeLine{430 \};}
\DoxyCodeLine{431 }
\DoxyCodeLine{432 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pload<Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from)}
\DoxyCodeLine{433 \{ EIGEN\_DEBUG\_ALIGNED\_LOAD \textcolor{keywordflow}{return} Packet1cd(pload<Packet2d>(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{double}*\textcolor{keyword}{>}(from))); \}}
\DoxyCodeLine{434 }
\DoxyCodeLine{435 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd ploadu<Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from)}
\DoxyCodeLine{436 \{ EIGEN\_DEBUG\_UNALIGNED\_LOAD \textcolor{keywordflow}{return} Packet1cd(ploadu<Packet2d>(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{double}*\textcolor{keyword}{>}(from))); \}}
\DoxyCodeLine{437 }
\DoxyCodeLine{438 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pset1<Packet1cd>(\textcolor{keyword}{const} std::complex<double>\& from)}
\DoxyCodeLine{439 \{}
\DoxyCodeLine{440   \textcolor{comment}{/* here we really have to use unaligned loads :( */}}
\DoxyCodeLine{441   \textcolor{keywordflow}{return} ploadu<Packet1cd>(\&from);}
\DoxyCodeLine{442 \}}
\DoxyCodeLine{443 }
\DoxyCodeLine{444 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd padd<Packet1cd>(\textcolor{keyword}{const} Packet1cd\& a, \textcolor{keyword}{const} Packet1cd\& b)}
\DoxyCodeLine{445 \{ \textcolor{keywordflow}{return} Packet1cd(padd<Packet2d>(a.v, b.v)); \}}
\DoxyCodeLine{446 }
\DoxyCodeLine{447 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd psub<Packet1cd>(\textcolor{keyword}{const} Packet1cd\& a, \textcolor{keyword}{const} Packet1cd\& b)}
\DoxyCodeLine{448 \{ \textcolor{keywordflow}{return} Packet1cd(psub<Packet2d>(a.v, b.v)); \}}
\DoxyCodeLine{449 }
\DoxyCodeLine{450 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pnegate(\textcolor{keyword}{const} Packet1cd\& a)}
\DoxyCodeLine{451 \{ \textcolor{keywordflow}{return} Packet1cd(pnegate<Packet2d>(a.v)); \}}
\DoxyCodeLine{452 }
\DoxyCodeLine{453 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pconj(\textcolor{keyword}{const} Packet1cd\& a)}
\DoxyCodeLine{454 \{ \textcolor{keywordflow}{return} Packet1cd(vreinterpretq\_f64\_u64(veorq\_u64(vreinterpretq\_u64\_f64(a.v), p2ul\_CONJ\_XOR))); \}}
\DoxyCodeLine{455 }
\DoxyCodeLine{456 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pmul<Packet1cd>(\textcolor{keyword}{const} Packet1cd\& a, \textcolor{keyword}{const} Packet1cd\& b)}
\DoxyCodeLine{457 \{}
\DoxyCodeLine{458   Packet2d v1, v2;}
\DoxyCodeLine{459 }
\DoxyCodeLine{460   \textcolor{comment}{// Get the real values of a}}
\DoxyCodeLine{461   v1 = vdupq\_lane\_f64(vget\_low\_f64(a.v), 0);}
\DoxyCodeLine{462   \textcolor{comment}{// Get the imag values of a}}
\DoxyCodeLine{463   v2 = vdupq\_lane\_f64(vget\_high\_f64(a.v), 0);}
\DoxyCodeLine{464   \textcolor{comment}{// Multiply the real a with b}}
\DoxyCodeLine{465   v1 = vmulq\_f64(v1, b.v);}
\DoxyCodeLine{466   \textcolor{comment}{// Multiply the imag a with b}}
\DoxyCodeLine{467   v2 = vmulq\_f64(v2, b.v);}
\DoxyCodeLine{468   \textcolor{comment}{// Conjugate v2}}
\DoxyCodeLine{469   v2 = vreinterpretq\_f64\_u64(veorq\_u64(vreinterpretq\_u64\_f64(v2), p2ul\_CONJ\_XOR));}
\DoxyCodeLine{470   \textcolor{comment}{// Swap real/imag elements in v2.}}
\DoxyCodeLine{471   v2 = preverse<Packet2d>(v2);}
\DoxyCodeLine{472   \textcolor{comment}{// Add and return the result}}
\DoxyCodeLine{473   \textcolor{keywordflow}{return} Packet1cd(vaddq\_f64(v1, v2));}
\DoxyCodeLine{474 \}}
\DoxyCodeLine{475 }
\DoxyCodeLine{476 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pcmp\_eq(\textcolor{keyword}{const} Packet1cd\& a, \textcolor{keyword}{const} Packet1cd\& b)}
\DoxyCodeLine{477 \{}
\DoxyCodeLine{478   \textcolor{comment}{// Compare real and imaginary parts of a and b to get the mask vector:}}
\DoxyCodeLine{479   \textcolor{comment}{// [re(a)==re(b), im(a)==im(b)]}}
\DoxyCodeLine{480   Packet2d eq = pcmp\_eq<Packet2d>(a.v, b.v);}
\DoxyCodeLine{481   \textcolor{comment}{// Swap real/imag elements in the mask in to get:}}
\DoxyCodeLine{482   \textcolor{comment}{// [im(a)==im(b), re(a)==re(b)]}}
\DoxyCodeLine{483   Packet2d eq\_swapped = vreinterpretq\_f64\_u32(vrev64q\_u32(vreinterpretq\_u32\_f64(eq)));}
\DoxyCodeLine{484   \textcolor{comment}{// Return re(a)==re(b) \& im(a)==im(b) by computing bitwise AND of eq and eq\_swapped}}
\DoxyCodeLine{485   \textcolor{keywordflow}{return} Packet1cd(pand<Packet2d>(eq, eq\_swapped));}
\DoxyCodeLine{486 \}}
\DoxyCodeLine{487 }
\DoxyCodeLine{488 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pand<Packet1cd>(\textcolor{keyword}{const} Packet1cd\& a, \textcolor{keyword}{const} Packet1cd\& b)}
\DoxyCodeLine{489 \{ \textcolor{keywordflow}{return} Packet1cd(vreinterpretq\_f64\_u64(vandq\_u64(vreinterpretq\_u64\_f64(a.v),vreinterpretq\_u64\_f64(b.v)))); \}}
\DoxyCodeLine{490 }
\DoxyCodeLine{491 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd por<Packet1cd>(\textcolor{keyword}{const} Packet1cd\& a, \textcolor{keyword}{const} Packet1cd\& b)}
\DoxyCodeLine{492 \{ \textcolor{keywordflow}{return} Packet1cd(vreinterpretq\_f64\_u64(vorrq\_u64(vreinterpretq\_u64\_f64(a.v),vreinterpretq\_u64\_f64(b.v)))); \}}
\DoxyCodeLine{493 }
\DoxyCodeLine{494 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pxor<Packet1cd>(\textcolor{keyword}{const} Packet1cd\& a, \textcolor{keyword}{const} Packet1cd\& b)}
\DoxyCodeLine{495 \{ \textcolor{keywordflow}{return} Packet1cd(vreinterpretq\_f64\_u64(veorq\_u64(vreinterpretq\_u64\_f64(a.v),vreinterpretq\_u64\_f64(b.v)))); \}}
\DoxyCodeLine{496 }
\DoxyCodeLine{497 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pandnot<Packet1cd>(\textcolor{keyword}{const} Packet1cd\& a, \textcolor{keyword}{const} Packet1cd\& b)}
\DoxyCodeLine{498 \{ \textcolor{keywordflow}{return} Packet1cd(vreinterpretq\_f64\_u64(vbicq\_u64(vreinterpretq\_u64\_f64(a.v),vreinterpretq\_u64\_f64(b.v)))); \}}
\DoxyCodeLine{499 }
\DoxyCodeLine{500 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd ploaddup<Packet1cd>(\textcolor{keyword}{const} std::complex<double>* from)}
\DoxyCodeLine{501 \{ \textcolor{keywordflow}{return} pset1<Packet1cd>(*from); \}}
\DoxyCodeLine{502 }
\DoxyCodeLine{503 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstore <std::complex<double> >(std::complex<double> *to, \textcolor{keyword}{const} Packet1cd\& from)}
\DoxyCodeLine{504 \{ EIGEN\_DEBUG\_ALIGNED\_STORE pstore(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{double}*\textcolor{keyword}{>}(to), from.v); \}}
\DoxyCodeLine{505 }
\DoxyCodeLine{506 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} pstoreu<std::complex<double> >(std::complex<double> *to, \textcolor{keyword}{const} Packet1cd\& from)}
\DoxyCodeLine{507 \{ EIGEN\_DEBUG\_UNALIGNED\_STORE pstoreu(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{double}*\textcolor{keyword}{>}(to), from.v); \}}
\DoxyCodeLine{508 }
\DoxyCodeLine{509 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} prefetch<std::complex<double> >(\textcolor{keyword}{const} std::complex<double> *addr)}
\DoxyCodeLine{510 \{ EIGEN\_ARM\_PREFETCH(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{double}*\textcolor{keyword}{>}(addr)); \}}
\DoxyCodeLine{511 }
\DoxyCodeLine{512 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} Packet1cd pgather<std::complex<double>, Packet1cd>(}
\DoxyCodeLine{513     \textcolor{keyword}{const} std::complex<double>* from, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} stride)}
\DoxyCodeLine{514 \{}
\DoxyCodeLine{515   Packet2d res = pset1<Packet2d>(0.0);}
\DoxyCodeLine{516   res = vsetq\_lane\_f64(std::real(from[0*stride]), res, 0);}
\DoxyCodeLine{517   res = vsetq\_lane\_f64(std::imag(from[0*stride]), res, 1);}
\DoxyCodeLine{518   \textcolor{keywordflow}{return} Packet1cd(res);}
\DoxyCodeLine{519 \}}
\DoxyCodeLine{520 }
\DoxyCodeLine{521 \textcolor{keyword}{template}<> EIGEN\_DEVICE\_FUNC \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pscatter<std::complex<double>, Packet1cd>(}
\DoxyCodeLine{522     std::complex<double>* to, \textcolor{keyword}{const} Packet1cd\& from, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} stride)}
\DoxyCodeLine{523 \{ to[stride*0] = std::complex<double>(vgetq\_lane\_f64(from.v, 0), vgetq\_lane\_f64(from.v, 1)); \}}
\DoxyCodeLine{524 }
\DoxyCodeLine{525 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double> pfirst<Packet1cd>(\textcolor{keyword}{const} Packet1cd\& a)}
\DoxyCodeLine{526 \{}
\DoxyCodeLine{527   EIGEN\_ALIGN16 std::complex<double> res;}
\DoxyCodeLine{528   pstore<std::complex<double> >(\&res, a);}
\DoxyCodeLine{529   \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{530 \}}
\DoxyCodeLine{531 }
\DoxyCodeLine{532 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd preverse(\textcolor{keyword}{const} Packet1cd\& a) \{ \textcolor{keywordflow}{return} a; \}}
\DoxyCodeLine{533 }
\DoxyCodeLine{534 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double> predux<Packet1cd>(\textcolor{keyword}{const} Packet1cd\& a) \{ \textcolor{keywordflow}{return} pfirst(a); \}}
\DoxyCodeLine{535 }
\DoxyCodeLine{536 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE std::complex<double> predux\_mul<Packet1cd>(\textcolor{keyword}{const} Packet1cd\& a) \{ \textcolor{keywordflow}{return} pfirst(a); \}}
\DoxyCodeLine{537 }
\DoxyCodeLine{538 EIGEN\_MAKE\_CONJ\_HELPER\_CPLX\_REAL(Packet1cd,Packet2d)}
\DoxyCodeLine{539 }
\DoxyCodeLine{540 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd pdiv<Packet1cd>(\textcolor{keyword}{const} Packet1cd\& a, \textcolor{keyword}{const} Packet1cd\& b)}
\DoxyCodeLine{541 \{}
\DoxyCodeLine{542   \textcolor{keywordflow}{return} pdiv\_complex(a, b);}
\DoxyCodeLine{543 \}}
\DoxyCodeLine{544 }
\DoxyCodeLine{545 EIGEN\_STRONG\_INLINE Packet1cd pcplxflip\textcolor{comment}{/*<Packet1cd>*/}(\textcolor{keyword}{const} Packet1cd\& x)}
\DoxyCodeLine{546 \{ \textcolor{keywordflow}{return} Packet1cd(preverse(Packet2d(x.v))); \}}
\DoxyCodeLine{547 }
\DoxyCodeLine{548 EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} ptranspose(PacketBlock<Packet1cd,2>\& kernel)}
\DoxyCodeLine{549 \{}
\DoxyCodeLine{550   Packet2d tmp = vcombine\_f64(vget\_high\_f64(kernel.packet[0].v), vget\_high\_f64(kernel.packet[1].v));}
\DoxyCodeLine{551   kernel.packet[0].v = vcombine\_f64(vget\_low\_f64(kernel.packet[0].v), vget\_low\_f64(kernel.packet[1].v));}
\DoxyCodeLine{552   kernel.packet[1].v = tmp;}
\DoxyCodeLine{553 \}}
\DoxyCodeLine{554 }
\DoxyCodeLine{555 \textcolor{keyword}{template}<> EIGEN\_STRONG\_INLINE Packet1cd psqrt<Packet1cd>(\textcolor{keyword}{const} Packet1cd\& a) \{}
\DoxyCodeLine{556   \textcolor{keywordflow}{return} psqrt\_complex<Packet1cd>(a);}
\DoxyCodeLine{557 \}}
\DoxyCodeLine{558 }
\DoxyCodeLine{559 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// EIGEN\_ARCH\_ARM64}}
\DoxyCodeLine{560 }
\DoxyCodeLine{561 \} \textcolor{comment}{// end namespace internal}}
\DoxyCodeLine{562 }
\DoxyCodeLine{563 \} \textcolor{comment}{// end namespace Eigen}}
\DoxyCodeLine{564 }
\DoxyCodeLine{565 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// EIGEN\_COMPLEX\_NEON\_H}}

\end{DoxyCode}
