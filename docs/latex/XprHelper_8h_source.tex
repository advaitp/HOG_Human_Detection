\hypertarget{XprHelper_8h_source}{}\doxysection{Xpr\+Helper.\+h}
\label{XprHelper_8h_source}\index{include/Eigen/src/Core/util/XprHelper.h@{include/Eigen/src/Core/util/XprHelper.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}}
\DoxyCodeLine{2 \textcolor{comment}{// for linear algebra.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>}}
\DoxyCodeLine{5 \textcolor{comment}{// Copyright (C) 2006-\/2008 Benoit Jacob <jacob.benoit.1@gmail.com>}}
\DoxyCodeLine{6 \textcolor{comment}{//}}
\DoxyCodeLine{7 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}}
\DoxyCodeLine{8 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}}
\DoxyCodeLine{9 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#ifndef EIGEN\_XPRHELPER\_H}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#define EIGEN\_XPRHELPER\_H}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{comment}{// just a workaround because GCC seems to not really like empty structs}}
\DoxyCodeLine{15 \textcolor{comment}{// FIXME: gcc 4.3 generates bad code when strict-\/aliasing is enabled}}
\DoxyCodeLine{16 \textcolor{comment}{// so currently we simply disable this optimization for gcc 4.3}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#if EIGEN\_COMP\_GNUC \&\& !EIGEN\_GNUC\_AT(4,3)}}
\DoxyCodeLine{18 \textcolor{preprocessor}{  \#define EIGEN\_EMPTY\_STRUCT\_CTOR(X) \(\backslash\)}}
\DoxyCodeLine{19 \textcolor{preprocessor}{    EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE X() \{\} \(\backslash\)}}
\DoxyCodeLine{20 \textcolor{preprocessor}{    EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE X(const X\& ) \{\}}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{22 \textcolor{preprocessor}{  \#define EIGEN\_EMPTY\_STRUCT\_CTOR(X)}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include "{}../InternalHeaderCheck.h"{}}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceEigen}{Eigen}} \{}
\DoxyCodeLine{28 }
\DoxyCodeLine{29 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{30 }
\DoxyCodeLine{31 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IndexDest, \textcolor{keyword}{typename} IndexSrc>}
\DoxyCodeLine{32 EIGEN\_DEVICE\_FUNC}
\DoxyCodeLine{33 \textcolor{keyword}{inline} IndexDest convert\_index(\textcolor{keyword}{const} IndexSrc\& idx) \{}
\DoxyCodeLine{34   \textcolor{comment}{// for sizeof(IndexDest)>=sizeof(IndexSrc) compilers should be able to optimize this away:}}
\DoxyCodeLine{35   eigen\_internal\_assert(idx <= NumTraits<IndexDest>::highest() \&\& \textcolor{stringliteral}{"{}Index value to big for target type"{}});}
\DoxyCodeLine{36   \textcolor{keywordflow}{return} IndexDest(idx);}
\DoxyCodeLine{37 \}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{comment}{// true if T can be considered as an integral index (i.e., and integral type or enum)}}
\DoxyCodeLine{40 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1is__valid__index__type}{is\_valid\_index\_type}}}
\DoxyCodeLine{41 \{}
\DoxyCodeLine{42   \textcolor{keyword}{enum} \{ value =}
\DoxyCodeLine{43 \textcolor{preprocessor}{\#if EIGEN\_HAS\_TYPE\_TRAITS}}
\DoxyCodeLine{44     \mbox{\hyperlink{structEigen_1_1internal_1_1is__integral}{internal::is\_integral<T>::value}} || std::is\_enum<T>::value}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#elif EIGEN\_COMP\_MSVC}}
\DoxyCodeLine{46     \mbox{\hyperlink{structEigen_1_1internal_1_1is__integral}{internal::is\_integral<T>::value}} || \_\_is\_enum(T)}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{48     \textcolor{comment}{// without C++11, we use is\_convertible to Index instead of is\_integral in order to treat enums as Index.}}
\DoxyCodeLine{49     \mbox{\hyperlink{structEigen_1_1internal_1_1is__convertible}{internal::is\_convertible<T,Index>::value}} \&\& !\mbox{\hyperlink{structEigen_1_1internal_1_1is__same}{internal::is\_same<T,float>::value}} \&\& !\mbox{\hyperlink{structEigen_1_1internal_1_1is__same}{is\_same<T,double>::value}}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{51   \};}
\DoxyCodeLine{52 \};}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 \textcolor{comment}{// true if both types are not valid index types}}
\DoxyCodeLine{55 \textcolor{keyword}{template}<\textcolor{keyword}{typename} RowIndices, \textcolor{keyword}{typename} ColIndices>}
\DoxyCodeLine{56 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1valid__indexed__view__overload}{valid\_indexed\_view\_overload}} \{}
\DoxyCodeLine{57   \textcolor{keyword}{enum} \{ value = !(\mbox{\hyperlink{structEigen_1_1internal_1_1is__valid__index__type}{internal::is\_valid\_index\_type<RowIndices>::value}} \&\& \mbox{\hyperlink{structEigen_1_1internal_1_1is__valid__index__type}{internal::is\_valid\_index\_type<ColIndices>::value}}) \};}
\DoxyCodeLine{58 \};}
\DoxyCodeLine{59 }
\DoxyCodeLine{60 \textcolor{comment}{// promote\_scalar\_arg is an helper used in operation between an expression and a scalar, like:}}
\DoxyCodeLine{61 \textcolor{comment}{//    expression * scalar}}
\DoxyCodeLine{62 \textcolor{comment}{// Its role is to determine how the type T of the scalar operand should be promoted given the scalar type ExprScalar of the given expression.}}
\DoxyCodeLine{63 \textcolor{comment}{// The IsSupported template parameter must be provided by the caller as: internal::has\_ReturnType<ScalarBinaryOpTraits<ExprScalar,T,op> >::value using the proper order for ExprScalar and T.}}
\DoxyCodeLine{64 \textcolor{comment}{// Then the logic is as follows:}}
\DoxyCodeLine{65 \textcolor{comment}{//  -\/ if the operation is natively supported as defined by IsSupported, then the scalar type is not promoted, and T is returned.}}
\DoxyCodeLine{66 \textcolor{comment}{//  -\/ otherwise, NumTraits<ExprScalar>::Literal is returned if T is implicitly convertible to NumTraits<ExprScalar>::Literal AND that this does not imply a float to integer conversion.}}
\DoxyCodeLine{67 \textcolor{comment}{//  -\/ otherwise, ExprScalar is returned if T is implicitly convertible to ExprScalar AND that this does not imply a float to integer conversion.}}
\DoxyCodeLine{68 \textcolor{comment}{//  -\/ In all other cases, the promoted type is not defined, and the respective operation is thus invalid and not available (SFINAE).}}
\DoxyCodeLine{69 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExprScalar,\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} IsSupported>}
\DoxyCodeLine{70 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__scalar__arg}{promote\_scalar\_arg}};}
\DoxyCodeLine{71 }
\DoxyCodeLine{72 \textcolor{keyword}{template}<\textcolor{keyword}{typename} S,\textcolor{keyword}{typename} T>}
\DoxyCodeLine{73 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__scalar__arg}{promote\_scalar\_arg}}<S,T,true>}
\DoxyCodeLine{74 \{}
\DoxyCodeLine{75   \textcolor{keyword}{typedef} T type;}
\DoxyCodeLine{76 \};}
\DoxyCodeLine{77 }
\DoxyCodeLine{78 \textcolor{comment}{// Recursively check safe conversion to PromotedType, and then ExprScalar if they are different.}}
\DoxyCodeLine{79 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExprScalar,\textcolor{keyword}{typename} T,\textcolor{keyword}{typename} PromotedType,}
\DoxyCodeLine{80   \textcolor{keywordtype}{bool} ConvertibleToLiteral = \mbox{\hyperlink{structEigen_1_1internal_1_1is__convertible}{internal::is\_convertible<T,PromotedType>::value}},}
\DoxyCodeLine{81   \textcolor{keywordtype}{bool} IsSafe = \mbox{\hyperlink{structEigen_1_1NumTraits}{NumTraits<T>::IsInteger}} || !\mbox{\hyperlink{structEigen_1_1NumTraits}{NumTraits<PromotedType>::IsInteger}}>}
\DoxyCodeLine{82 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__scalar__arg__unsupported}{promote\_scalar\_arg\_unsupported}};}
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{comment}{// Start recursion with NumTraits<ExprScalar>::Literal}}
\DoxyCodeLine{85 \textcolor{keyword}{template}<\textcolor{keyword}{typename} S,\textcolor{keyword}{typename} T>}
\DoxyCodeLine{86 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__scalar__arg}{promote\_scalar\_arg}}<S,T,false> : \mbox{\hyperlink{structEigen_1_1internal_1_1promote__scalar__arg__unsupported}{promote\_scalar\_arg\_unsupported}}<S,T,typename NumTraits<S>::Literal> \{\};}
\DoxyCodeLine{87 }
\DoxyCodeLine{88 \textcolor{comment}{// We found a match!}}
\DoxyCodeLine{89 \textcolor{keyword}{template}<\textcolor{keyword}{typename} S,\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} PromotedType>}
\DoxyCodeLine{90 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__scalar__arg__unsupported}{promote\_scalar\_arg\_unsupported}}<S,T,PromotedType,true,true>}
\DoxyCodeLine{91 \{}
\DoxyCodeLine{92   \textcolor{keyword}{typedef} PromotedType type;}
\DoxyCodeLine{93 \};}
\DoxyCodeLine{94 }
\DoxyCodeLine{95 \textcolor{comment}{// No match, but no real-\/to-\/integer issues, and ExprScalar and current PromotedType are different,}}
\DoxyCodeLine{96 \textcolor{comment}{// so let's try to promote to ExprScalar}}
\DoxyCodeLine{97 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExprScalar,\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} PromotedType>}
\DoxyCodeLine{98 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__scalar__arg__unsupported}{promote\_scalar\_arg\_unsupported}}<ExprScalar,T,PromotedType,false,true>}
\DoxyCodeLine{99    : \mbox{\hyperlink{structEigen_1_1internal_1_1promote__scalar__arg__unsupported}{promote\_scalar\_arg\_unsupported}}<ExprScalar,T,ExprScalar>}
\DoxyCodeLine{100 \{\};}
\DoxyCodeLine{101 }
\DoxyCodeLine{102 \textcolor{comment}{// Unsafe real-\/to-\/integer, let's stop.}}
\DoxyCodeLine{103 \textcolor{keyword}{template}<\textcolor{keyword}{typename} S,\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} PromotedType, \textcolor{keywordtype}{bool} ConvertibleToLiteral>}
\DoxyCodeLine{104 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__scalar__arg__unsupported}{promote\_scalar\_arg\_unsupported}}<S,T,PromotedType,ConvertibleToLiteral,false> \{\};}
\DoxyCodeLine{105 }
\DoxyCodeLine{106 \textcolor{comment}{// T is not even convertible to ExprScalar, let's stop.}}
\DoxyCodeLine{107 \textcolor{keyword}{template}<\textcolor{keyword}{typename} S,\textcolor{keyword}{typename} T>}
\DoxyCodeLine{108 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__scalar__arg__unsupported}{promote\_scalar\_arg\_unsupported}}<S,T,S,false,true> \{\};}
\DoxyCodeLine{109 }
\DoxyCodeLine{110 \textcolor{comment}{//classes inheriting no\_assignment\_operator don't generate a default operator=.}}
\DoxyCodeLine{111 \textcolor{keyword}{class }\mbox{\hyperlink{classEigen_1_1internal_1_1no__assignment__operator}{no\_assignment\_operator}}}
\DoxyCodeLine{112 \{}
\DoxyCodeLine{113   \textcolor{keyword}{private}:}
\DoxyCodeLine{114     \mbox{\hyperlink{classEigen_1_1internal_1_1no__assignment__operator}{no\_assignment\_operator}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classEigen_1_1internal_1_1no__assignment__operator}{no\_assignment\_operator}}\&);}
\DoxyCodeLine{115   \textcolor{keyword}{protected}:}
\DoxyCodeLine{116     EIGEN\_DEFAULT\_COPY\_CONSTRUCTOR(\mbox{\hyperlink{classEigen_1_1internal_1_1no__assignment__operator}{no\_assignment\_operator}})}
\DoxyCodeLine{117     EIGEN\_DEFAULT\_EMPTY\_CONSTRUCTOR\_AND\_DESTRUCTOR(\mbox{\hyperlink{classEigen_1_1internal_1_1no__assignment__operator}{no\_assignment\_operator}})}
\DoxyCodeLine{118 \};}
\DoxyCodeLine{119 }
\DoxyCodeLine{121 \textcolor{keyword}{template}<\textcolor{keyword}{typename} I1, \textcolor{keyword}{typename} I2>}
\DoxyCodeLine{122 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__index__type}{promote\_index\_type}}}
\DoxyCodeLine{123 \{}
\DoxyCodeLine{124   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional}}<(\textcolor{keyword}{sizeof}(I1)<\textcolor{keyword}{sizeof}(I2)), I2, I1>::\mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{type}} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{type}};}
\DoxyCodeLine{125 \};}
\DoxyCodeLine{126 }
\DoxyCodeLine{131 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} Value> \textcolor{keyword}{class }\mbox{\hyperlink{classEigen_1_1internal_1_1variable__if__dynamic}{variable\_if\_dynamic}}}
\DoxyCodeLine{132 \{}
\DoxyCodeLine{133   \textcolor{keyword}{public}:}
\DoxyCodeLine{134     EIGEN\_DEFAULT\_EMPTY\_CONSTRUCTOR\_AND\_DESTRUCTOR(\mbox{\hyperlink{classEigen_1_1internal_1_1variable__if__dynamic}{variable\_if\_dynamic}})}
\DoxyCodeLine{135     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} \mbox{\hyperlink{classEigen_1_1internal_1_1variable__if__dynamic}{variable\_if\_dynamic}}(T v) \{ EIGEN\_ONLY\_USED\_FOR\_DEBUG(v); eigen\_assert(v == T(Value)); \}}
\DoxyCodeLine{136     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE EIGEN\_CONSTEXPR}
\DoxyCodeLine{137     T value() \{ \textcolor{keywordflow}{return} T(Value); \}}
\DoxyCodeLine{138     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE EIGEN\_CONSTEXPR}
\DoxyCodeLine{139     \textcolor{keyword}{operator} T()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} T(Value); \}}
\DoxyCodeLine{140     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE}
\DoxyCodeLine{141     \textcolor{keywordtype}{void} setValue(T v)\textcolor{keyword}{ const }\{ EIGEN\_ONLY\_USED\_FOR\_DEBUG(v); eigen\_assert(v == T(Value)); \}}
\DoxyCodeLine{142 \};}
\DoxyCodeLine{143 }
\DoxyCodeLine{144 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{class }\mbox{\hyperlink{classEigen_1_1internal_1_1variable__if__dynamic}{variable\_if\_dynamic}}<T, \mbox{\hyperlink{namespaceEigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}>}
\DoxyCodeLine{145 \{}
\DoxyCodeLine{146     T m\_value;}
\DoxyCodeLine{147   \textcolor{keyword}{public}:}
\DoxyCodeLine{148     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} \mbox{\hyperlink{classEigen_1_1internal_1_1variable__if__dynamic}{variable\_if\_dynamic}}(T value = 0) EIGEN\_NO\_THROW : m\_value(value) \{\}}
\DoxyCodeLine{149     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE T value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_value; \}}
\DoxyCodeLine{150     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{operator} T()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_value; \}}
\DoxyCodeLine{151     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} setValue(T value) \{ m\_value = value; \}}
\DoxyCodeLine{152 \};}
\DoxyCodeLine{153 }
\DoxyCodeLine{156 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} Value> \textcolor{keyword}{class }\mbox{\hyperlink{classEigen_1_1internal_1_1variable__if__dynamicindex}{variable\_if\_dynamicindex}}}
\DoxyCodeLine{157 \{}
\DoxyCodeLine{158   \textcolor{keyword}{public}:}
\DoxyCodeLine{159     EIGEN\_EMPTY\_STRUCT\_CTOR(\mbox{\hyperlink{classEigen_1_1internal_1_1variable__if__dynamicindex}{variable\_if\_dynamicindex}})}
\DoxyCodeLine{160     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} \mbox{\hyperlink{classEigen_1_1internal_1_1variable__if__dynamicindex}{variable\_if\_dynamicindex}}(T v) \{ EIGEN\_ONLY\_USED\_FOR\_DEBUG(v); eigen\_assert(v == T(Value)); \}}
\DoxyCodeLine{161     EIGEN\_DEVICE\_FUNC \textcolor{keyword}{static} EIGEN\_STRONG\_INLINE EIGEN\_CONSTEXPR}
\DoxyCodeLine{162     T value() \{ \textcolor{keywordflow}{return} T(Value); \}}
\DoxyCodeLine{163     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE}
\DoxyCodeLine{164     \textcolor{keywordtype}{void} setValue(T) \{\}}
\DoxyCodeLine{165 \};}
\DoxyCodeLine{166 }
\DoxyCodeLine{167 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{class }\mbox{\hyperlink{classEigen_1_1internal_1_1variable__if__dynamicindex}{variable\_if\_dynamicindex}}<T, \mbox{\hyperlink{namespaceEigen_a73c597189a4a99127175e8167c456fff}{DynamicIndex}}>}
\DoxyCodeLine{168 \{}
\DoxyCodeLine{169     T m\_value;}
\DoxyCodeLine{170     EIGEN\_DEVICE\_FUNC \mbox{\hyperlink{classEigen_1_1internal_1_1variable__if__dynamicindex}{variable\_if\_dynamicindex}}() \{ eigen\_assert(\textcolor{keyword}{false}); \}}
\DoxyCodeLine{171   \textcolor{keyword}{public}:}
\DoxyCodeLine{172     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keyword}{explicit} \mbox{\hyperlink{classEigen_1_1internal_1_1variable__if__dynamicindex}{variable\_if\_dynamicindex}}(T value) : m\_value(value) \{\}}
\DoxyCodeLine{173     EIGEN\_DEVICE\_FUNC T EIGEN\_STRONG\_INLINE value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_value; \}}
\DoxyCodeLine{174     EIGEN\_DEVICE\_FUNC EIGEN\_STRONG\_INLINE \textcolor{keywordtype}{void} setValue(T value) \{ m\_value = value; \}}
\DoxyCodeLine{175 \};}
\DoxyCodeLine{176 }
\DoxyCodeLine{177 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1functor__traits}{functor\_traits}}}
\DoxyCodeLine{178 \{}
\DoxyCodeLine{179   \textcolor{keyword}{enum}}
\DoxyCodeLine{180   \{}
\DoxyCodeLine{181     Cost = 10,}
\DoxyCodeLine{182     PacketAccess = \textcolor{keyword}{false},}
\DoxyCodeLine{183     IsRepeatable = \textcolor{keyword}{false}}
\DoxyCodeLine{184   \};}
\DoxyCodeLine{185 \};}
\DoxyCodeLine{186 }
\DoxyCodeLine{187 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1packet__traits}{packet\_traits}};}
\DoxyCodeLine{188 }
\DoxyCodeLine{189 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1unpacket__traits}{unpacket\_traits}};}
\DoxyCodeLine{190 }
\DoxyCodeLine{191 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Size, \textcolor{keyword}{typename} PacketType,}
\DoxyCodeLine{192          \textcolor{keywordtype}{bool} Stop = Size==\mbox{\hyperlink{namespaceEigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}} || (Size\%\mbox{\hyperlink{structEigen_1_1internal_1_1unpacket__traits}{unpacket\_traits<PacketType>::size}})==0 || \mbox{\hyperlink{structEigen_1_1internal_1_1is__same}{is\_same}}<PacketType,\textcolor{keyword}{typename} \mbox{\hyperlink{unionEigen_1_1internal_1_1Packet}{unpacket\_traits<PacketType>::half}}>::value>}
\DoxyCodeLine{193 \textcolor{keyword}{struct} \mbox{\hyperlink{structEigen_1_1internal_1_1find__best__packet__helper}{find\_best\_packet\_helper}};}
\DoxyCodeLine{194 }
\DoxyCodeLine{195 \textcolor{keyword}{template}< \textcolor{keywordtype}{int} Size, \textcolor{keyword}{typename} PacketType>}
\DoxyCodeLine{196 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1find__best__packet__helper_3_01Size_00_01PacketType_00_01true_01_4}{find\_best\_packet\_helper<Size,PacketType,true>}}}
\DoxyCodeLine{197 \{}
\DoxyCodeLine{198   \textcolor{keyword}{typedef} PacketType type;}
\DoxyCodeLine{199 \};}
\DoxyCodeLine{200 }
\DoxyCodeLine{201 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Size, \textcolor{keyword}{typename} PacketType>}
\DoxyCodeLine{202 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1find__best__packet__helper_3_01Size_00_01PacketType_00_01false_01_4}{find\_best\_packet\_helper<Size,PacketType,false>}}}
\DoxyCodeLine{203 \{}
\DoxyCodeLine{204   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1find__best__packet__helper}{find\_best\_packet\_helper<Size,typename unpacket\_traits<PacketType>::half}}>::type type;}
\DoxyCodeLine{205 \};}
\DoxyCodeLine{206 }
\DoxyCodeLine{207 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} Size>}
\DoxyCodeLine{208 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1find__best__packet}{find\_best\_packet}}}
\DoxyCodeLine{209 \{}
\DoxyCodeLine{210   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1find__best__packet__helper}{find\_best\_packet\_helper<Size,typename packet\_traits<T>::type}}>::type type;}
\DoxyCodeLine{211 \};}
\DoxyCodeLine{212 }
\DoxyCodeLine{213 \textcolor{preprocessor}{\#if EIGEN\_MAX\_STATIC\_ALIGN\_BYTES>0}}
\DoxyCodeLine{214 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} ArrayBytes, \textcolor{keywordtype}{int} AlignmentBytes,}
\DoxyCodeLine{215          \textcolor{keywordtype}{bool} Match     =  bool((ArrayBytes\%AlignmentBytes)==0),}
\DoxyCodeLine{216          \textcolor{keywordtype}{bool} TryHalf   =  bool(EIGEN\_MIN\_ALIGN\_BYTES<AlignmentBytes) >}
\DoxyCodeLine{217 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1compute__default__alignment__helper}{compute\_default\_alignment\_helper}}}
\DoxyCodeLine{218 \{}
\DoxyCodeLine{219   \textcolor{keyword}{enum} \{ value = 0 \};}
\DoxyCodeLine{220 \};}
\DoxyCodeLine{221 }
\DoxyCodeLine{222 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} ArrayBytes, \textcolor{keywordtype}{int} AlignmentBytes, \textcolor{keywordtype}{bool} TryHalf>}
\DoxyCodeLine{223 \textcolor{keyword}{struct }compute\_default\_alignment\_helper<ArrayBytes, AlignmentBytes, true, TryHalf> \textcolor{comment}{// Match}}
\DoxyCodeLine{224 \{}
\DoxyCodeLine{225   \textcolor{keyword}{enum} \{ value = AlignmentBytes \};}
\DoxyCodeLine{226 \};}
\DoxyCodeLine{227 }
\DoxyCodeLine{228 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} ArrayBytes, \textcolor{keywordtype}{int} AlignmentBytes>}
\DoxyCodeLine{229 \textcolor{keyword}{struct }compute\_default\_alignment\_helper<ArrayBytes, AlignmentBytes, false, true> \textcolor{comment}{// Try-\/half}}
\DoxyCodeLine{230 \{}
\DoxyCodeLine{231   \textcolor{comment}{// current packet too large, try with an half-\/packet}}
\DoxyCodeLine{232   \textcolor{keyword}{enum} \{ value = compute\_default\_alignment\_helper<ArrayBytes, AlignmentBytes/2>::value \};}
\DoxyCodeLine{233 \};}
\DoxyCodeLine{234 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{235 \textcolor{comment}{// If static alignment is disabled, no need to bother.}}
\DoxyCodeLine{236 \textcolor{comment}{// This also avoids a division by zero in "{}bool Match =  bool((ArrayBytes\%AlignmentBytes)==0)"{}}}
\DoxyCodeLine{237 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} ArrayBytes, \textcolor{keywordtype}{int} AlignmentBytes>}
\DoxyCodeLine{238 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1compute__default__alignment__helper}{compute\_default\_alignment\_helper}}}
\DoxyCodeLine{239 \{}
\DoxyCodeLine{240   \textcolor{keyword}{enum} \{ value = 0 \};}
\DoxyCodeLine{241 \};}
\DoxyCodeLine{242 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{243 }
\DoxyCodeLine{244 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} Size> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1compute__default__alignment}{compute\_default\_alignment}} \{}
\DoxyCodeLine{245   \textcolor{keyword}{enum} \{ value = \mbox{\hyperlink{structEigen_1_1internal_1_1compute__default__alignment__helper}{compute\_default\_alignment\_helper}}<Size*\textcolor{keyword}{sizeof}(T),EIGEN\_MAX\_STATIC\_ALIGN\_BYTES>::value \};}
\DoxyCodeLine{246 \};}
\DoxyCodeLine{247 }
\DoxyCodeLine{248 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1compute__default__alignment}{compute\_default\_alignment}}<T,\mbox{\hyperlink{namespaceEigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}> \{}
\DoxyCodeLine{249   \textcolor{keyword}{enum} \{ value = EIGEN\_MAX\_ALIGN\_BYTES \};}
\DoxyCodeLine{250 \};}
\DoxyCodeLine{251 }
\DoxyCodeLine{252 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_, \textcolor{keywordtype}{int} Rows\_, \textcolor{keywordtype}{int} Cols\_,}
\DoxyCodeLine{253          \textcolor{keywordtype}{int} Options\_ = \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea}{AutoAlign}} |}
\DoxyCodeLine{254                           ( (Rows\_==1 \&\& Cols\_!=1) ? \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}}}
\DoxyCodeLine{255                           : (Cols\_==1 \&\& Rows\_!=1) ? \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62}{ColMajor}}}
\DoxyCodeLine{256                           : EIGEN\_DEFAULT\_MATRIX\_STORAGE\_ORDER\_OPTION ),}
\DoxyCodeLine{257          \textcolor{keywordtype}{int} MaxRows\_ = Rows\_,}
\DoxyCodeLine{258          \textcolor{keywordtype}{int} MaxCols\_ = Cols\_}
\DoxyCodeLine{259 > \textcolor{keyword}{class} \mbox{\hyperlink{classEigen_1_1internal_1_1make__proper__matrix__type}{make\_proper\_matrix\_type}}}
\DoxyCodeLine{260 \{}
\DoxyCodeLine{261     \textcolor{keyword}{enum} \{}
\DoxyCodeLine{262       IsColVector = Cols\_==1 \&\& Rows\_!=1,}
\DoxyCodeLine{263       IsRowVector = Rows\_==1 \&\& Cols\_!=1,}
\DoxyCodeLine{264       Options = IsColVector ? (Options\_ | \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62}{ColMajor}}) \& \string~\mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}}}
\DoxyCodeLine{265               : IsRowVector ? (Options\_ | \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}}) \& \string~ColMajor}
\DoxyCodeLine{266               : Options\_}
\DoxyCodeLine{267     \};}
\DoxyCodeLine{268   \textcolor{keyword}{public}:}
\DoxyCodeLine{269     \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Matrix}{Matrix<Scalar\_, Rows\_, Cols\_, Options, MaxRows\_, MaxCols\_>}} \mbox{\hyperlink{classEigen_1_1Matrix}{type}};}
\DoxyCodeLine{270 \};}
\DoxyCodeLine{271 }
\DoxyCodeLine{272 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keywordtype}{int} Rows, \textcolor{keywordtype}{int} Cols, \textcolor{keywordtype}{int} Options, \textcolor{keywordtype}{int} MaxRows, \textcolor{keywordtype}{int} MaxCols>}
\DoxyCodeLine{273 \textcolor{keyword}{class }\mbox{\hyperlink{classEigen_1_1internal_1_1compute__matrix__flags}{compute\_matrix\_flags}}}
\DoxyCodeLine{274 \{}
\DoxyCodeLine{275     \textcolor{keyword}{enum} \{ row\_major\_bit = Options\&\mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}} ? \mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}} : 0 \};}
\DoxyCodeLine{276   \textcolor{keyword}{public}:}
\DoxyCodeLine{277     \textcolor{comment}{// FIXME currently we still have to handle DirectAccessBit at the expression level to handle DenseCoeffsBase<>}}
\DoxyCodeLine{278     \textcolor{comment}{// and then propagate this information to the evaluator's flags.}}
\DoxyCodeLine{279     \textcolor{comment}{// However, I (Gael) think that DirectAccessBit should only matter at the evaluation stage.}}
\DoxyCodeLine{280     \textcolor{keyword}{enum} \{ ret = \mbox{\hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit}} | \mbox{\hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit}} | NestByRefBit | row\_major\_bit \};}
\DoxyCodeLine{281 \};}
\DoxyCodeLine{282 }
\DoxyCodeLine{283 \textcolor{keyword}{template}<\textcolor{keywordtype}{int} Rows\_, \textcolor{keywordtype}{int} Cols\_> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1size__at__compile__time}{size\_at\_compile\_time}}}
\DoxyCodeLine{284 \{}
\DoxyCodeLine{285   \textcolor{keyword}{enum} \{ ret = (Rows\_==\mbox{\hyperlink{namespaceEigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}} || Cols\_==\mbox{\hyperlink{namespaceEigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}) ? \mbox{\hyperlink{namespaceEigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}} : Rows\_ * Cols\_ \};}
\DoxyCodeLine{286 \};}
\DoxyCodeLine{287 }
\DoxyCodeLine{288 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1size__of__xpr__at__compile__time}{size\_of\_xpr\_at\_compile\_time}}}
\DoxyCodeLine{289 \{}
\DoxyCodeLine{290   \textcolor{keyword}{enum} \{ ret = \mbox{\hyperlink{structEigen_1_1internal_1_1size__at__compile__time}{size\_at\_compile\_time<traits<XprType>::RowsAtCompileTime}},\mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<XprType>::ColsAtCompileTime}}>::ret \};}
\DoxyCodeLine{291 \};}
\DoxyCodeLine{292 }
\DoxyCodeLine{293 \textcolor{comment}{/* plain\_matrix\_type : the difference from eval is that plain\_matrix\_type is always a plain matrix type,}}
\DoxyCodeLine{294 \textcolor{comment}{ * whereas eval is a const reference in the case of a matrix}}
\DoxyCodeLine{295 \textcolor{comment}{ */}}
\DoxyCodeLine{296 }
\DoxyCodeLine{297 template<typename T, typename StorageKind = typename traits<T>::StorageKind> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__matrix__type}{plain\_matrix\_type}};}
\DoxyCodeLine{298 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} BaseClassType, \textcolor{keywordtype}{int} Flags> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__matrix__type__dense}{plain\_matrix\_type\_dense}};}
\DoxyCodeLine{299 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__matrix__type}{plain\_matrix\_type}}<T,\mbox{\hyperlink{structEigen_1_1Dense}{Dense}}>}
\DoxyCodeLine{300 \{}
\DoxyCodeLine{301   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1plain__matrix__type__dense}{plain\_matrix\_type\_dense<T,typename traits<T>::XprKind}}, \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::Flags}}>::type type;}
\DoxyCodeLine{302 \};}
\DoxyCodeLine{303 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__matrix__type}{plain\_matrix\_type}}<T,\mbox{\hyperlink{structEigen_1_1DiagonalShape}{DiagonalShape}}>}
\DoxyCodeLine{304 \{}
\DoxyCodeLine{305   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} T::PlainObject type;}
\DoxyCodeLine{306 \};}
\DoxyCodeLine{307 }
\DoxyCodeLine{308 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} Flags> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__matrix__type__dense}{plain\_matrix\_type\_dense}}<T,\mbox{\hyperlink{structEigen_1_1MatrixXpr}{MatrixXpr}},Flags>}
\DoxyCodeLine{309 \{}
\DoxyCodeLine{310   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Matrix}{Matrix<typename traits<T>::Scalar}},}
\DoxyCodeLine{311                 \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::RowsAtCompileTime}},}
\DoxyCodeLine{312                 \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::ColsAtCompileTime}},}
\DoxyCodeLine{313                 \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea}{AutoAlign}} | (Flags\&\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}} ? \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}} : \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62}{ColMajor}}),}
\DoxyCodeLine{314                 \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::MaxRowsAtCompileTime}},}
\DoxyCodeLine{315                 \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::MaxColsAtCompileTime}}}
\DoxyCodeLine{316           > \mbox{\hyperlink{classEigen_1_1Matrix}{type}};}
\DoxyCodeLine{317 \};}
\DoxyCodeLine{318 }
\DoxyCodeLine{319 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} Flags> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__matrix__type__dense}{plain\_matrix\_type\_dense}}<T,\mbox{\hyperlink{structEigen_1_1ArrayXpr}{ArrayXpr}},Flags>}
\DoxyCodeLine{320 \{}
\DoxyCodeLine{321   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Array}{Array<typename traits<T>::Scalar}},}
\DoxyCodeLine{322                 \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::RowsAtCompileTime}},}
\DoxyCodeLine{323                 \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::ColsAtCompileTime}},}
\DoxyCodeLine{324                 \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13ad0e7f67d40bcde3d41c12849b16ce6ea}{AutoAlign}} | (Flags\&\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}} ? \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}} : \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62}{ColMajor}}),}
\DoxyCodeLine{325                 \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::MaxRowsAtCompileTime}},}
\DoxyCodeLine{326                 \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::MaxColsAtCompileTime}}}
\DoxyCodeLine{327           > \mbox{\hyperlink{classEigen_1_1Array}{type}};}
\DoxyCodeLine{328 \};}
\DoxyCodeLine{329 }
\DoxyCodeLine{330 \textcolor{comment}{/* eval : the return type of eval(). For matrices, this is just a const reference}}
\DoxyCodeLine{331 \textcolor{comment}{ * in order to avoid a useless copy}}
\DoxyCodeLine{332 \textcolor{comment}{ */}}
\DoxyCodeLine{333 }
\DoxyCodeLine{334 template<typename T, typename StorageKind = typename traits<T>::StorageKind> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1eval}{eval}};}
\DoxyCodeLine{335 }
\DoxyCodeLine{336 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1eval}{eval}}<T,\mbox{\hyperlink{structEigen_1_1Dense}{Dense}}>}
\DoxyCodeLine{337 \{}
\DoxyCodeLine{338   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1plain__matrix__type}{plain\_matrix\_type<T>::type}} type;}
\DoxyCodeLine{339 \textcolor{comment}{//   typedef typename T::PlainObject type;}}
\DoxyCodeLine{340 \textcolor{comment}{//   typedef T::Matrix<typename traits<T>::Scalar,}}
\DoxyCodeLine{341 \textcolor{comment}{//                 traits<T>::RowsAtCompileTime,}}
\DoxyCodeLine{342 \textcolor{comment}{//                 traits<T>::ColsAtCompileTime,}}
\DoxyCodeLine{343 \textcolor{comment}{//                 AutoAlign | (traits<T>::Flags\&RowMajorBit ? RowMajor : ColMajor),}}
\DoxyCodeLine{344 \textcolor{comment}{//                 traits<T>::MaxRowsAtCompileTime,}}
\DoxyCodeLine{345 \textcolor{comment}{//                 traits<T>::MaxColsAtCompileTime}}
\DoxyCodeLine{346 \textcolor{comment}{//           > type;}}
\DoxyCodeLine{347 \};}
\DoxyCodeLine{348 }
\DoxyCodeLine{349 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1eval}{eval}}<T,\mbox{\hyperlink{structEigen_1_1DiagonalShape}{DiagonalShape}}>}
\DoxyCodeLine{350 \{}
\DoxyCodeLine{351   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1plain__matrix__type}{plain\_matrix\_type<T>::type}} type;}
\DoxyCodeLine{352 \};}
\DoxyCodeLine{353 }
\DoxyCodeLine{354 \textcolor{comment}{// for matrices, no need to evaluate, just use a const reference to avoid a useless copy}}
\DoxyCodeLine{355 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_, \textcolor{keywordtype}{int} Rows\_, \textcolor{keywordtype}{int} Cols\_, \textcolor{keywordtype}{int} Options\_, \textcolor{keywordtype}{int} MaxRows\_, \textcolor{keywordtype}{int} MaxCols\_>}
\DoxyCodeLine{356 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1eval}{eval}}<\mbox{\hyperlink{classEigen_1_1Matrix}{Matrix}}<Scalar\_, Rows\_, Cols\_, Options\_, MaxRows\_, MaxCols\_>, \mbox{\hyperlink{structEigen_1_1Dense}{Dense}}>}
\DoxyCodeLine{357 \{}
\DoxyCodeLine{358   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \mbox{\hyperlink{classEigen_1_1Matrix}{Matrix<Scalar\_, Rows\_, Cols\_, Options\_, MaxRows\_, MaxCols\_>}}\& \mbox{\hyperlink{classEigen_1_1Matrix}{type}};}
\DoxyCodeLine{359 \};}
\DoxyCodeLine{360 }
\DoxyCodeLine{361 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar\_, \textcolor{keywordtype}{int} Rows\_, \textcolor{keywordtype}{int} Cols\_, \textcolor{keywordtype}{int} Options\_, \textcolor{keywordtype}{int} MaxRows\_, \textcolor{keywordtype}{int} MaxCols\_>}
\DoxyCodeLine{362 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1eval}{eval}}<\mbox{\hyperlink{classEigen_1_1Array}{Array}}<Scalar\_, Rows\_, Cols\_, Options\_, MaxRows\_, MaxCols\_>, \mbox{\hyperlink{structEigen_1_1Dense}{Dense}}>}
\DoxyCodeLine{363 \{}
\DoxyCodeLine{364   \textcolor{keyword}{typedef} \textcolor{keyword}{const} \mbox{\hyperlink{classEigen_1_1Array}{Array<Scalar\_, Rows\_, Cols\_, Options\_, MaxRows\_, MaxCols\_>}}\& \mbox{\hyperlink{classEigen_1_1Array}{type}};}
\DoxyCodeLine{365 \};}
\DoxyCodeLine{366 }
\DoxyCodeLine{367 }
\DoxyCodeLine{368 \textcolor{comment}{/* similar to plain\_matrix\_type, but using the evaluator's Flags */}}
\DoxyCodeLine{369 template<typename T, typename StorageKind = typename traits<T>::StorageKind> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__object__eval}{plain\_object\_eval}};}
\DoxyCodeLine{370 }
\DoxyCodeLine{371 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{372 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__object__eval}{plain\_object\_eval}}<T,\mbox{\hyperlink{structEigen_1_1Dense}{Dense}}>}
\DoxyCodeLine{373 \{}
\DoxyCodeLine{374   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1plain__matrix__type__dense}{plain\_matrix\_type\_dense<T,typename traits<T>::XprKind}}, \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{evaluator<T>::Flags}}>::type type;}
\DoxyCodeLine{375 \};}
\DoxyCodeLine{376 }
\DoxyCodeLine{377 }
\DoxyCodeLine{378 \textcolor{comment}{/* plain\_matrix\_type\_column\_major : same as plain\_matrix\_type but guaranteed to be column-\/major}}
\DoxyCodeLine{379 \textcolor{comment}{ */}}
\DoxyCodeLine{380 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__matrix__type__column__major}{plain\_matrix\_type\_column\_major}}}
\DoxyCodeLine{381 \{}
\DoxyCodeLine{382   \textcolor{keyword}{enum} \{ Rows = \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::RowsAtCompileTime}},}
\DoxyCodeLine{383          Cols = \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::ColsAtCompileTime}},}
\DoxyCodeLine{384          MaxRows = \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::MaxRowsAtCompileTime}},}
\DoxyCodeLine{385          MaxCols = \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::MaxColsAtCompileTime}}}
\DoxyCodeLine{386   \};}
\DoxyCodeLine{387   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Matrix}{Matrix<typename traits<T>::Scalar}},}
\DoxyCodeLine{388                 Rows,}
\DoxyCodeLine{389                 Cols,}
\DoxyCodeLine{390                 (MaxRows==1\&\&MaxCols!=1) ? \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}} : \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62}{ColMajor}},}
\DoxyCodeLine{391                 MaxRows,}
\DoxyCodeLine{392                 MaxCols}
\DoxyCodeLine{393           > \mbox{\hyperlink{classEigen_1_1Matrix}{type}};}
\DoxyCodeLine{394 \};}
\DoxyCodeLine{395 }
\DoxyCodeLine{396 \textcolor{comment}{/* plain\_matrix\_type\_row\_major : same as plain\_matrix\_type but guaranteed to be row-\/major}}
\DoxyCodeLine{397 \textcolor{comment}{ */}}
\DoxyCodeLine{398 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__matrix__type__row__major}{plain\_matrix\_type\_row\_major}}}
\DoxyCodeLine{399 \{}
\DoxyCodeLine{400   \textcolor{keyword}{enum} \{ Rows = \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::RowsAtCompileTime}},}
\DoxyCodeLine{401          Cols = \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::ColsAtCompileTime}},}
\DoxyCodeLine{402          MaxRows = \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::MaxRowsAtCompileTime}},}
\DoxyCodeLine{403          MaxCols = \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::MaxColsAtCompileTime}}}
\DoxyCodeLine{404   \};}
\DoxyCodeLine{405   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Matrix}{Matrix<typename traits<T>::Scalar}},}
\DoxyCodeLine{406                 Rows,}
\DoxyCodeLine{407                 Cols,}
\DoxyCodeLine{408                 (MaxCols==1\&\&MaxRows!=1) ? \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62}{ColMajor}} : \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}},}
\DoxyCodeLine{409                 MaxRows,}
\DoxyCodeLine{410                 MaxCols}
\DoxyCodeLine{411           > \mbox{\hyperlink{classEigen_1_1Matrix}{type}};}
\DoxyCodeLine{412 \};}
\DoxyCodeLine{413 }
\DoxyCodeLine{417 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{418 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1ref__selector}{ref\_selector}}}
\DoxyCodeLine{419 \{}
\DoxyCodeLine{420   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional}}<}
\DoxyCodeLine{421     bool(\mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::Flags}} \& NestByRefBit),}
\DoxyCodeLine{422     T \textcolor{keyword}{const}\&,}
\DoxyCodeLine{423     \textcolor{keyword}{const} T}
\DoxyCodeLine{424   >\mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{::type}} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{type}};}
\DoxyCodeLine{425 }
\DoxyCodeLine{426   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional}}<}
\DoxyCodeLine{427     bool(\mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<T>::Flags}} \& NestByRefBit),}
\DoxyCodeLine{428     T \&,}
\DoxyCodeLine{429     T}
\DoxyCodeLine{430   >\mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{::type}} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{non\_const\_type}};}
\DoxyCodeLine{431 \};}
\DoxyCodeLine{432 }
\DoxyCodeLine{434 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{435 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1transfer__constness}{transfer\_constness}}}
\DoxyCodeLine{436 \{}
\DoxyCodeLine{437   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional}}<}
\DoxyCodeLine{438     bool(\mbox{\hyperlink{structEigen_1_1internal_1_1is__const}{internal::is\_const<T1>::value}}),}
\DoxyCodeLine{439     \textcolor{keyword}{typename} internal::add\_const\_on\_value\_type<T2>::type,}
\DoxyCodeLine{440     T2}
\DoxyCodeLine{441   >\mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{::type}} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{type}};}
\DoxyCodeLine{442 \};}
\DoxyCodeLine{443 }
\DoxyCodeLine{444 }
\DoxyCodeLine{445 \textcolor{comment}{// However, we still need a mechanism to detect whether an expression which is evaluated multiple time}}
\DoxyCodeLine{446 \textcolor{comment}{// has to be evaluated into a temporary.}}
\DoxyCodeLine{447 \textcolor{comment}{// That's the purpose of this new nested\_eval helper:}}
\DoxyCodeLine{459 \textcolor{comment}{}template<typename T, int n, typename PlainObject = typename plain\_object\_eval<T>::type> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1nested__eval}{nested\_eval}}}
\DoxyCodeLine{460 \{}
\DoxyCodeLine{461   \textcolor{keyword}{enum} \{}
\DoxyCodeLine{462     ScalarReadCost = \mbox{\hyperlink{structEigen_1_1NumTraits}{NumTraits<typename traits<T>::Scalar}}>::ReadCost,}
\DoxyCodeLine{463     CoeffReadCost = \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{evaluator<T>::CoeffReadCost}},  \textcolor{comment}{// NOTE What if an evaluator evaluate itself into a temporary?}}
\DoxyCodeLine{464                                                   \textcolor{comment}{//      Then CoeffReadCost will be small (e.g., 1) but we still have to evaluate, especially if n>1.}}
\DoxyCodeLine{465                                                   \textcolor{comment}{//      This situation is already taken care by the EvalBeforeNestingBit flag, which is turned ON}}
\DoxyCodeLine{466                                                   \textcolor{comment}{//      for all evaluator creating a temporary. This flag is then propagated by the parent evaluators.}}
\DoxyCodeLine{467                                                   \textcolor{comment}{//      Another solution could be to count the number of temps?}}
\DoxyCodeLine{468     NAsInteger = n == \mbox{\hyperlink{namespaceEigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}} ? \mbox{\hyperlink{namespaceEigen_a3163430a1c13173faffde69016b48aaf}{HugeCost}} : n,}
\DoxyCodeLine{469     CostEval   = (NAsInteger+1) * ScalarReadCost + CoeffReadCost,}
\DoxyCodeLine{470     CostNoEval = NAsInteger * CoeffReadCost,}
\DoxyCodeLine{471     Evaluate = (\textcolor{keywordtype}{int}(\mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{evaluator<T>::Flags}}) \& \mbox{\hyperlink{group__flags_gaa34e83bae46a8eeae4e69ebe3aaecbed}{EvalBeforeNestingBit}}) || (\textcolor{keywordtype}{int}(CostEval) < int(CostNoEval))}
\DoxyCodeLine{472   \};}
\DoxyCodeLine{473 }
\DoxyCodeLine{474   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional<Evaluate, PlainObject, typename ref\_selector<T>::type}}>\mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{::type}} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{type}};}
\DoxyCodeLine{475 \};}
\DoxyCodeLine{476 }
\DoxyCodeLine{477 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{478 EIGEN\_DEVICE\_FUNC}
\DoxyCodeLine{479 \textcolor{keyword}{inline} T* const\_cast\_ptr(\textcolor{keyword}{const} T* ptr)}
\DoxyCodeLine{480 \{}
\DoxyCodeLine{481   \textcolor{keywordflow}{return} \textcolor{keyword}{const\_cast<}T*\textcolor{keyword}{>}(ptr);}
\DoxyCodeLine{482 \}}
\DoxyCodeLine{483 }
\DoxyCodeLine{484 template<typename Derived, typename XprKind = typename traits<Derived>::XprKind>}
\DoxyCodeLine{485 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1dense__xpr__base}{dense\_xpr\_base}}}
\DoxyCodeLine{486 \{}
\DoxyCodeLine{487   \textcolor{comment}{/* dense\_xpr\_base should only ever be used on dense expressions, thus falling either into the MatrixXpr or into the ArrayXpr cases */}}
\DoxyCodeLine{488 \};}
\DoxyCodeLine{489 }
\DoxyCodeLine{490 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{491 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1dense__xpr__base}{dense\_xpr\_base}}<Derived, \mbox{\hyperlink{structEigen_1_1MatrixXpr}{MatrixXpr}}>}
\DoxyCodeLine{492 \{}
\DoxyCodeLine{493   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1MatrixBase}{MatrixBase<Derived>}} \mbox{\hyperlink{classEigen_1_1MatrixBase}{type}};}
\DoxyCodeLine{494 \};}
\DoxyCodeLine{495 }
\DoxyCodeLine{496 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{497 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1dense__xpr__base}{dense\_xpr\_base}}<Derived, \mbox{\hyperlink{structEigen_1_1ArrayXpr}{ArrayXpr}}>}
\DoxyCodeLine{498 \{}
\DoxyCodeLine{499   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1ArrayBase}{ArrayBase<Derived>}} \mbox{\hyperlink{classEigen_1_1ArrayBase}{type}};}
\DoxyCodeLine{500 \};}
\DoxyCodeLine{501 }
\DoxyCodeLine{502 template<typename Derived, typename XprKind = typename traits<Derived>::XprKind, \textcolor{keyword}{typename} StorageKind = \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<Derived>::StorageKind}}>}
\DoxyCodeLine{503 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1generic__xpr__base}{generic\_xpr\_base}};}
\DoxyCodeLine{504 }
\DoxyCodeLine{505 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} XprKind>}
\DoxyCodeLine{506 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1generic__xpr__base}{generic\_xpr\_base}}<Derived, XprKind, \mbox{\hyperlink{structEigen_1_1Dense}{Dense}}>}
\DoxyCodeLine{507 \{}
\DoxyCodeLine{508   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1dense__xpr__base}{dense\_xpr\_base<Derived,XprKind>::type}} type;}
\DoxyCodeLine{509 \};}
\DoxyCodeLine{510 }
\DoxyCodeLine{511 \textcolor{keyword}{template}<\textcolor{keyword}{typename} XprType, \textcolor{keyword}{typename} CastType> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1cast__return__type}{cast\_return\_type}}}
\DoxyCodeLine{512 \{}
\DoxyCodeLine{513   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::Scalar CurrentScalarType;}
\DoxyCodeLine{514   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} remove\_all<CastType>::type \_CastType;}
\DoxyCodeLine{515   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \_CastType::Scalar NewScalarType;}
\DoxyCodeLine{516   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional<is\_same<CurrentScalarType,NewScalarType>::value}},}
\DoxyCodeLine{517                               \textcolor{keyword}{const} XprType\&,CastType>\mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{::type}} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{type}};}
\DoxyCodeLine{518 \};}
\DoxyCodeLine{519 }
\DoxyCodeLine{520 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__storage__type}{promote\_storage\_type}};}
\DoxyCodeLine{521 }
\DoxyCodeLine{522 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__storage__type}{promote\_storage\_type}}<A,A>}
\DoxyCodeLine{523 \{}
\DoxyCodeLine{524   \textcolor{keyword}{typedef} A ret;}
\DoxyCodeLine{525 \};}
\DoxyCodeLine{526 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__storage__type}{promote\_storage\_type}}<A, const A>}
\DoxyCodeLine{527 \{}
\DoxyCodeLine{528   \textcolor{keyword}{typedef} A ret;}
\DoxyCodeLine{529 \};}
\DoxyCodeLine{530 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1promote__storage__type}{promote\_storage\_type}}<const A, A>}
\DoxyCodeLine{531 \{}
\DoxyCodeLine{532   \textcolor{keyword}{typedef} A ret;}
\DoxyCodeLine{533 \};}
\DoxyCodeLine{534 }
\DoxyCodeLine{548 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B, \textcolor{keyword}{typename} Functor> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1cwise__promote__storage__type}{cwise\_promote\_storage\_type}};}
\DoxyCodeLine{549 }
\DoxyCodeLine{550 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} Functor>                   \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1cwise__promote__storage__type}{cwise\_promote\_storage\_type}}<A,A,Functor>                                      \{ \textcolor{keyword}{typedef} A      ret; \};}
\DoxyCodeLine{551 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Functor>                               \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1cwise__promote__storage__type}{cwise\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1Dense}{Dense}},\mbox{\hyperlink{structEigen_1_1Dense}{Dense}},Functor>                              \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Dense}{Dense}}  \mbox{\hyperlink{structEigen_1_1Dense}{ret}}; \};}
\DoxyCodeLine{552 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} Functor>                   \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1cwise__promote__storage__type}{cwise\_promote\_storage\_type}}<A,\mbox{\hyperlink{structEigen_1_1Dense}{Dense}},Functor>                                  \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Dense}{Dense}}  \mbox{\hyperlink{structEigen_1_1Dense}{ret}}; \};}
\DoxyCodeLine{553 \textcolor{keyword}{template} <\textcolor{keyword}{typename} B, \textcolor{keyword}{typename} Functor>                   \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1cwise__promote__storage__type}{cwise\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1Dense}{Dense}},B,Functor>                                  \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Dense}{Dense}}  \mbox{\hyperlink{structEigen_1_1Dense}{ret}}; \};}
\DoxyCodeLine{554 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Functor>                               \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1cwise__promote__storage__type}{cwise\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}},\mbox{\hyperlink{structEigen_1_1Dense}{Dense}},Functor>                             \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}} \mbox{\hyperlink{structEigen_1_1Sparse}{ret}}; \};}
\DoxyCodeLine{555 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Functor>                               \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1cwise__promote__storage__type}{cwise\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1Dense}{Dense}},\mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}},Functor>                             \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}} \mbox{\hyperlink{structEigen_1_1Sparse}{ret}}; \};}
\DoxyCodeLine{556 }
\DoxyCodeLine{557 \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsKind, \textcolor{keyword}{typename} RhsKind, \textcolor{keywordtype}{int} LhsOrder, \textcolor{keywordtype}{int} RhsOrder> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1cwise__promote__storage__order}{cwise\_promote\_storage\_order}} \{}
\DoxyCodeLine{558   \textcolor{keyword}{enum} \{ value = LhsOrder \};}
\DoxyCodeLine{559 \};}
\DoxyCodeLine{560 }
\DoxyCodeLine{561 \textcolor{keyword}{template} <\textcolor{keyword}{typename} LhsKind, \textcolor{keywordtype}{int} LhsOrder, \textcolor{keywordtype}{int} RhsOrder>   \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1cwise__promote__storage__order}{cwise\_promote\_storage\_order}}<LhsKind,\mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}},LhsOrder,RhsOrder>                \{ \textcolor{keyword}{enum} \{ value = RhsOrder \}; \};}
\DoxyCodeLine{562 \textcolor{keyword}{template} <\textcolor{keyword}{typename} RhsKind, \textcolor{keywordtype}{int} LhsOrder, \textcolor{keywordtype}{int} RhsOrder>   \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1cwise__promote__storage__order}{cwise\_promote\_storage\_order}}<\mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}},RhsKind,LhsOrder,RhsOrder>                \{ \textcolor{keyword}{enum} \{ value = LhsOrder \}; \};}
\DoxyCodeLine{563 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} Order>                                      \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1cwise__promote__storage__order}{cwise\_promote\_storage\_order}}<\mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}},\mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}},Order,Order>                       \{ \textcolor{keyword}{enum} \{ value = Order \}; \};}
\DoxyCodeLine{564 }
\DoxyCodeLine{565 }
\DoxyCodeLine{580 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B, \textcolor{keywordtype}{int} ProductTag> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}};}
\DoxyCodeLine{581 }
\DoxyCodeLine{582 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keywordtype}{int} ProductTag> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<A,                  A,                  ProductTag> \{ \textcolor{keyword}{typedef} A     ret;\};}
\DoxyCodeLine{583 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} ProductTag>             \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1Dense}{Dense}},              \mbox{\hyperlink{structEigen_1_1Dense}{Dense}},              ProductTag> \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Dense}{Dense}} \mbox{\hyperlink{structEigen_1_1Dense}{ret}};\};}
\DoxyCodeLine{584 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keywordtype}{int} ProductTag> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<A,                  \mbox{\hyperlink{structEigen_1_1Dense}{Dense}},              ProductTag> \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Dense}{Dense}} \mbox{\hyperlink{structEigen_1_1Dense}{ret}}; \};}
\DoxyCodeLine{585 \textcolor{keyword}{template} <\textcolor{keyword}{typename} B, \textcolor{keywordtype}{int} ProductTag> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1Dense}{Dense}},              B,                  ProductTag> \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Dense}{Dense}} \mbox{\hyperlink{structEigen_1_1Dense}{ret}}; \};}
\DoxyCodeLine{586 }
\DoxyCodeLine{587 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keywordtype}{int} ProductTag> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<A,                  \mbox{\hyperlink{structEigen_1_1DiagonalShape}{DiagonalShape}},      ProductTag> \{ \textcolor{keyword}{typedef} A ret; \};}
\DoxyCodeLine{588 \textcolor{keyword}{template} <\textcolor{keyword}{typename} B, \textcolor{keywordtype}{int} ProductTag> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1DiagonalShape}{DiagonalShape}},      B,                  ProductTag> \{ \textcolor{keyword}{typedef} B ret; \};}
\DoxyCodeLine{589 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} ProductTag>             \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1Dense}{Dense}},              \mbox{\hyperlink{structEigen_1_1DiagonalShape}{DiagonalShape}},      ProductTag> \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Dense}{Dense}} \mbox{\hyperlink{structEigen_1_1Dense}{ret}}; \};}
\DoxyCodeLine{590 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} ProductTag>             \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1DiagonalShape}{DiagonalShape}},      \mbox{\hyperlink{structEigen_1_1Dense}{Dense}},              ProductTag> \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Dense}{Dense}} \mbox{\hyperlink{structEigen_1_1Dense}{ret}}; \};}
\DoxyCodeLine{591 }
\DoxyCodeLine{592 \textcolor{keyword}{template} <\textcolor{keyword}{typename} A, \textcolor{keywordtype}{int} ProductTag> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<A,                  \mbox{\hyperlink{structEigen_1_1PermutationStorage}{PermutationStorage}}, ProductTag> \{ \textcolor{keyword}{typedef} A ret; \};}
\DoxyCodeLine{593 \textcolor{keyword}{template} <\textcolor{keyword}{typename} B, \textcolor{keywordtype}{int} ProductTag> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1PermutationStorage}{PermutationStorage}}, B,                  ProductTag> \{ \textcolor{keyword}{typedef} B ret; \};}
\DoxyCodeLine{594 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} ProductTag>             \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1Dense}{Dense}},              \mbox{\hyperlink{structEigen_1_1PermutationStorage}{PermutationStorage}}, ProductTag> \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Dense}{Dense}} \mbox{\hyperlink{structEigen_1_1Dense}{ret}}; \};}
\DoxyCodeLine{595 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} ProductTag>             \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1PermutationStorage}{PermutationStorage}}, \mbox{\hyperlink{structEigen_1_1Dense}{Dense}},              ProductTag> \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Dense}{Dense}} \mbox{\hyperlink{structEigen_1_1Dense}{ret}}; \};}
\DoxyCodeLine{596 }
\DoxyCodeLine{600 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType, \textcolor{keyword}{typename} Scalar = \textcolor{keyword}{typename} ExpressionType::Scalar>}
\DoxyCodeLine{601 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__row__type}{plain\_row\_type}}}
\DoxyCodeLine{602 \{}
\DoxyCodeLine{603   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Matrix}{Matrix}}<Scalar, 1, ExpressionType::ColsAtCompileTime,}
\DoxyCodeLine{604                  int(ExpressionType::PlainObject::Options) | int(\mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}}), 1, ExpressionType::MaxColsAtCompileTime> \mbox{\hyperlink{classEigen_1_1Matrix}{MatrixRowType}};}
\DoxyCodeLine{605   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Array}{Array}}<Scalar, 1, ExpressionType::ColsAtCompileTime,}
\DoxyCodeLine{606                  int(ExpressionType::PlainObject::Options) | int(\mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}}), 1, ExpressionType::MaxColsAtCompileTime> \mbox{\hyperlink{classEigen_1_1Array}{ArrayRowType}};}
\DoxyCodeLine{607 }
\DoxyCodeLine{608   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional}}<}
\DoxyCodeLine{609     \mbox{\hyperlink{structEigen_1_1internal_1_1is__same}{is\_same< typename traits<ExpressionType>::XprKind}}, \mbox{\hyperlink{structEigen_1_1MatrixXpr}{MatrixXpr}} >::value,}
\DoxyCodeLine{610     \mbox{\hyperlink{classEigen_1_1Matrix}{MatrixRowType}},}
\DoxyCodeLine{611     \mbox{\hyperlink{classEigen_1_1Array}{ArrayRowType}}}
\DoxyCodeLine{612   >\mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{::type}} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{type}};}
\DoxyCodeLine{613 \};}
\DoxyCodeLine{614 }
\DoxyCodeLine{615 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType, \textcolor{keyword}{typename} Scalar = \textcolor{keyword}{typename} ExpressionType::Scalar>}
\DoxyCodeLine{616 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__col__type}{plain\_col\_type}}}
\DoxyCodeLine{617 \{}
\DoxyCodeLine{618   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Matrix}{Matrix}}<Scalar, ExpressionType::RowsAtCompileTime, 1,}
\DoxyCodeLine{619                  ExpressionType::PlainObject::Options \& \string~RowMajor, ExpressionType::MaxRowsAtCompileTime, 1> \mbox{\hyperlink{classEigen_1_1Matrix}{MatrixColType}};}
\DoxyCodeLine{620   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Array}{Array}}<Scalar, ExpressionType::RowsAtCompileTime, 1,}
\DoxyCodeLine{621                  ExpressionType::PlainObject::Options \& \string~RowMajor, ExpressionType::MaxRowsAtCompileTime, 1> \mbox{\hyperlink{classEigen_1_1Array}{ArrayColType}};}
\DoxyCodeLine{622 }
\DoxyCodeLine{623   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional}}<}
\DoxyCodeLine{624     \mbox{\hyperlink{structEigen_1_1internal_1_1is__same}{is\_same< typename traits<ExpressionType>::XprKind}}, \mbox{\hyperlink{structEigen_1_1MatrixXpr}{MatrixXpr}} >::value,}
\DoxyCodeLine{625     \mbox{\hyperlink{classEigen_1_1Matrix}{MatrixColType}},}
\DoxyCodeLine{626     \mbox{\hyperlink{classEigen_1_1Array}{ArrayColType}}}
\DoxyCodeLine{627   >\mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{::type}} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{type}};}
\DoxyCodeLine{628 \};}
\DoxyCodeLine{629 }
\DoxyCodeLine{630 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType, \textcolor{keyword}{typename} Scalar = \textcolor{keyword}{typename} ExpressionType::Scalar>}
\DoxyCodeLine{631 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__diag__type}{plain\_diag\_type}}}
\DoxyCodeLine{632 \{}
\DoxyCodeLine{633   \textcolor{keyword}{enum} \{ diag\_size = EIGEN\_SIZE\_MIN\_PREFER\_DYNAMIC(ExpressionType::RowsAtCompileTime, ExpressionType::ColsAtCompileTime),}
\DoxyCodeLine{634          max\_diag\_size = EIGEN\_SIZE\_MIN\_PREFER\_FIXED(ExpressionType::MaxRowsAtCompileTime, ExpressionType::MaxColsAtCompileTime)}
\DoxyCodeLine{635   \};}
\DoxyCodeLine{636   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Matrix}{Matrix<Scalar, diag\_size, 1, ExpressionType::PlainObject::Options \& \string~RowMajor, max\_diag\_size, 1>}} \mbox{\hyperlink{classEigen_1_1Matrix}{MatrixDiagType}};}
\DoxyCodeLine{637   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Array}{Array<Scalar, diag\_size, 1, ExpressionType::PlainObject::Options \& \string~RowMajor, max\_diag\_size, 1>}} \mbox{\hyperlink{classEigen_1_1Array}{ArrayDiagType}};}
\DoxyCodeLine{638 }
\DoxyCodeLine{639   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional}}<}
\DoxyCodeLine{640     \mbox{\hyperlink{structEigen_1_1internal_1_1is__same}{is\_same< typename traits<ExpressionType>::XprKind}}, \mbox{\hyperlink{structEigen_1_1MatrixXpr}{MatrixXpr}} >::value,}
\DoxyCodeLine{641     \mbox{\hyperlink{classEigen_1_1Matrix}{MatrixDiagType}},}
\DoxyCodeLine{642     \mbox{\hyperlink{classEigen_1_1Array}{ArrayDiagType}}}
\DoxyCodeLine{643   >\mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{::type}} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{type}};}
\DoxyCodeLine{644 \};}
\DoxyCodeLine{645 }
\DoxyCodeLine{646 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Expr,\textcolor{keyword}{typename} Scalar = \textcolor{keyword}{typename} Expr::Scalar>}
\DoxyCodeLine{647 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1plain__constant__type}{plain\_constant\_type}}}
\DoxyCodeLine{648 \{}
\DoxyCodeLine{649   \textcolor{keyword}{enum} \{ Options = (\mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<Expr>::Flags}}\&\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}})?\mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}}:0 \};}
\DoxyCodeLine{650 }
\DoxyCodeLine{651   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Array}{Array<Scalar,  traits<Expr>::RowsAtCompileTime}},   \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<Expr>::ColsAtCompileTime}},}
\DoxyCodeLine{652                 Options, \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<Expr>::MaxRowsAtCompileTime}},\mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<Expr>::MaxColsAtCompileTime}}> \mbox{\hyperlink{classEigen_1_1Array}{array\_type}};}
\DoxyCodeLine{653 }
\DoxyCodeLine{654   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Matrix}{Matrix<Scalar,  traits<Expr>::RowsAtCompileTime}},   \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<Expr>::ColsAtCompileTime}},}
\DoxyCodeLine{655                  Options, \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<Expr>::MaxRowsAtCompileTime}},\mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<Expr>::MaxColsAtCompileTime}}> \mbox{\hyperlink{classEigen_1_1Matrix}{matrix\_type}};}
\DoxyCodeLine{656 }
\DoxyCodeLine{657   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1CwiseNullaryOp}{CwiseNullaryOp<scalar\_constant\_op<Scalar>}}, \textcolor{keyword}{const} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional<is\_same< typename traits<Expr>::XprKind}}, \mbox{\hyperlink{structEigen_1_1MatrixXpr}{MatrixXpr}} >::value, \mbox{\hyperlink{classEigen_1_1Matrix}{matrix\_type}}, \mbox{\hyperlink{classEigen_1_1Array}{array\_type}}>\mbox{\hyperlink{classEigen_1_1CwiseNullaryOp}{::type}} > \mbox{\hyperlink{classEigen_1_1CwiseNullaryOp}{type}};}
\DoxyCodeLine{658 \};}
\DoxyCodeLine{659 }
\DoxyCodeLine{660 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ExpressionType>}
\DoxyCodeLine{661 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1is__lvalue}{is\_lvalue}}}
\DoxyCodeLine{662 \{}
\DoxyCodeLine{663   \textcolor{keyword}{enum} \{ value = (!bool(\mbox{\hyperlink{structEigen_1_1internal_1_1is__const}{is\_const<ExpressionType>::value}})) \&\&}
\DoxyCodeLine{664                  \textcolor{keywordtype}{bool}(\mbox{\hyperlink{structEigen_1_1internal_1_1traits}{traits<ExpressionType>::Flags}} \& \mbox{\hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit}}) \};}
\DoxyCodeLine{665 \};}
\DoxyCodeLine{666 }
\DoxyCodeLine{667 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1is__diagonal}{is\_diagonal}}}
\DoxyCodeLine{668 \{ \textcolor{keyword}{enum} \{ ret = \textcolor{keyword}{false} \}; \};}
\DoxyCodeLine{669 }
\DoxyCodeLine{670 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1is__diagonal}{is\_diagonal}}<\mbox{\hyperlink{classEigen_1_1DiagonalBase}{DiagonalBase}}<T> >}
\DoxyCodeLine{671 \{ \textcolor{keyword}{enum} \{ ret = \textcolor{keyword}{true} \}; \};}
\DoxyCodeLine{672 }
\DoxyCodeLine{673 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1is__diagonal}{is\_diagonal}}<\mbox{\hyperlink{classEigen_1_1DiagonalWrapper}{DiagonalWrapper}}<T> >}
\DoxyCodeLine{674 \{ \textcolor{keyword}{enum} \{ ret = \textcolor{keyword}{true} \}; \};}
\DoxyCodeLine{675 }
\DoxyCodeLine{676 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} S> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1is__diagonal}{is\_diagonal}}<\mbox{\hyperlink{classEigen_1_1DiagonalMatrix}{DiagonalMatrix}}<T,S> >}
\DoxyCodeLine{677 \{ \textcolor{keyword}{enum} \{ ret = \textcolor{keyword}{true} \}; \};}
\DoxyCodeLine{678 }
\DoxyCodeLine{679 }
\DoxyCodeLine{680 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1is__identity}{is\_identity}}}
\DoxyCodeLine{681 \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{false} \}; \};}
\DoxyCodeLine{682 }
\DoxyCodeLine{683 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1is__identity}{is\_identity}}<\mbox{\hyperlink{classEigen_1_1CwiseNullaryOp}{CwiseNullaryOp}}<internal::\mbox{\hyperlink{structEigen_1_1internal_1_1scalar__identity__op}{scalar\_identity\_op}}<typename T::Scalar>, T> >}
\DoxyCodeLine{684 \{ \textcolor{keyword}{enum} \{ value = \textcolor{keyword}{true} \}; \};}
\DoxyCodeLine{685 }
\DoxyCodeLine{686 }
\DoxyCodeLine{687 \textcolor{keyword}{template}<\textcolor{keyword}{typename} S1, \textcolor{keyword}{typename} S2> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1glue__shapes}{glue\_shapes}};}
\DoxyCodeLine{688 \textcolor{keyword}{template}<> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1glue__shapes}{glue\_shapes}}<\mbox{\hyperlink{structEigen_1_1DenseShape}{DenseShape}},\mbox{\hyperlink{structEigen_1_1TriangularShape}{TriangularShape}}> \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1TriangularShape}{TriangularShape}} \mbox{\hyperlink{structEigen_1_1TriangularShape}{type}};  \};}
\DoxyCodeLine{689 }
\DoxyCodeLine{690 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{691 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1possibly__same__dense}{possibly\_same\_dense}} \{}
\DoxyCodeLine{692   \textcolor{keyword}{enum} \{ value = \mbox{\hyperlink{structEigen_1_1internal_1_1has__direct__access}{has\_direct\_access<T1>::ret}} \&\& \mbox{\hyperlink{structEigen_1_1internal_1_1has__direct__access}{has\_direct\_access<T2>::ret}} \&\& \mbox{\hyperlink{structEigen_1_1internal_1_1is__same}{is\_same<typename T1::Scalar,typename T2::Scalar>::value}} \};}
\DoxyCodeLine{693 \};}
\DoxyCodeLine{694 }
\DoxyCodeLine{695 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{696 EIGEN\_DEVICE\_FUNC}
\DoxyCodeLine{697 \textcolor{keywordtype}{bool} is\_same\_dense(\textcolor{keyword}{const} T1 \&mat1, \textcolor{keyword}{const} T2 \&mat2, \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1enable__if}{enable\_if}}<\mbox{\hyperlink{structEigen_1_1internal_1_1possibly__same__dense}{possibly\_same\_dense<T1,T2>::value}}>::type * = 0)}
\DoxyCodeLine{698 \{}
\DoxyCodeLine{699   \textcolor{keywordflow}{return} (mat1.data()==mat2.data()) \&\& (mat1.innerStride()==mat2.innerStride()) \&\& (mat1.outerStride()==mat2.outerStride());}
\DoxyCodeLine{700 \}}
\DoxyCodeLine{701 }
\DoxyCodeLine{702 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{703 EIGEN\_DEVICE\_FUNC}
\DoxyCodeLine{704 \textcolor{keywordtype}{bool} is\_same\_dense(\textcolor{keyword}{const} T1 \&, \textcolor{keyword}{const} T2 \&, \textcolor{keyword}{typename} enable\_if<!possibly\_same\_dense<T1,T2>::value>::type * = 0)}
\DoxyCodeLine{705 \{}
\DoxyCodeLine{706   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{707 \}}
\DoxyCodeLine{708 }
\DoxyCodeLine{709 \textcolor{comment}{// Internal helper defining the cost of a scalar division for the type T.}}
\DoxyCodeLine{710 \textcolor{comment}{// The default heuristic can be specialized for each scalar type and architecture.}}
\DoxyCodeLine{711 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T,\textcolor{keywordtype}{bool} Vectorized=false,\textcolor{keyword}{typename} EnableIf = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{712 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1scalar__div__cost}{scalar\_div\_cost}} \{}
\DoxyCodeLine{713   \textcolor{keyword}{enum} \{ value = 8*\mbox{\hyperlink{structEigen_1_1NumTraits}{NumTraits<T>::MulCost}} \};}
\DoxyCodeLine{714 \};}
\DoxyCodeLine{715 }
\DoxyCodeLine{716 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T,\textcolor{keywordtype}{bool} Vectorized>}
\DoxyCodeLine{717 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1scalar__div__cost}{scalar\_div\_cost}}<std::complex<T>, Vectorized> \{}
\DoxyCodeLine{718   \textcolor{keyword}{enum} \{ value = 2*\mbox{\hyperlink{structEigen_1_1internal_1_1scalar__div__cost}{scalar\_div\_cost<T>::value}}}
\DoxyCodeLine{719                + 6*\mbox{\hyperlink{structEigen_1_1NumTraits}{NumTraits<T>::MulCost}}}
\DoxyCodeLine{720                + 3*\mbox{\hyperlink{structEigen_1_1NumTraits}{NumTraits<T>::AddCost}}}
\DoxyCodeLine{721   \};}
\DoxyCodeLine{722 \};}
\DoxyCodeLine{723 }
\DoxyCodeLine{724 }
\DoxyCodeLine{725 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Vectorized>}
\DoxyCodeLine{726 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1scalar__div__cost}{scalar\_div\_cost}}<signed long,Vectorized,typename \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional}}<sizeof(long)==8,void,\mbox{\hyperlink{structEigen_1_1internal_1_1false__type}{false\_type}}>::type> \{ \textcolor{keyword}{enum} \{ value = 24 \}; \};}
\DoxyCodeLine{727 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} Vectorized>}
\DoxyCodeLine{728 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1scalar__div__cost}{scalar\_div\_cost}}<unsigned long,Vectorized,typename \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional}}<sizeof(long)==8,void,\mbox{\hyperlink{structEigen_1_1internal_1_1false__type}{false\_type}}>::type> \{ \textcolor{keyword}{enum} \{ value = 21 \}; \};}
\DoxyCodeLine{729 }
\DoxyCodeLine{730 }
\DoxyCodeLine{731 \textcolor{preprocessor}{\#ifdef EIGEN\_DEBUG\_ASSIGN}}
\DoxyCodeLine{732 std::string demangle\_traversal(\textcolor{keywordtype}{int} t)}
\DoxyCodeLine{733 \{}
\DoxyCodeLine{734   \textcolor{keywordflow}{if}(t==DefaultTraversal) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}DefaultTraversal"{}};}
\DoxyCodeLine{735   \textcolor{keywordflow}{if}(t==LinearTraversal) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}LinearTraversal"{}};}
\DoxyCodeLine{736   \textcolor{keywordflow}{if}(t==InnerVectorizedTraversal) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}InnerVectorizedTraversal"{}};}
\DoxyCodeLine{737   \textcolor{keywordflow}{if}(t==LinearVectorizedTraversal) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}LinearVectorizedTraversal"{}};}
\DoxyCodeLine{738   \textcolor{keywordflow}{if}(t==SliceVectorizedTraversal) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}SliceVectorizedTraversal"{}};}
\DoxyCodeLine{739   \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}?"{}};}
\DoxyCodeLine{740 \}}
\DoxyCodeLine{741 std::string demangle\_unrolling(\textcolor{keywordtype}{int} t)}
\DoxyCodeLine{742 \{}
\DoxyCodeLine{743   \textcolor{keywordflow}{if}(t==NoUnrolling) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}NoUnrolling"{}};}
\DoxyCodeLine{744   \textcolor{keywordflow}{if}(t==InnerUnrolling) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}InnerUnrolling"{}};}
\DoxyCodeLine{745   \textcolor{keywordflow}{if}(t==CompleteUnrolling) \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}CompleteUnrolling"{}};}
\DoxyCodeLine{746   \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}?"{}};}
\DoxyCodeLine{747 \}}
\DoxyCodeLine{748 std::string demangle\_flags(\textcolor{keywordtype}{int} f)}
\DoxyCodeLine{749 \{}
\DoxyCodeLine{750   std::string res;}
\DoxyCodeLine{751   \textcolor{keywordflow}{if}(f\&\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}})                 res += \textcolor{stringliteral}{"{} | RowMajor"{}};}
\DoxyCodeLine{752   \textcolor{keywordflow}{if}(f\&\mbox{\hyperlink{group__flags_ga1a306a438e1ab074e8be59512e887b9f}{PacketAccessBit}})             res += \textcolor{stringliteral}{"{} | Packet"{}};}
\DoxyCodeLine{753   \textcolor{keywordflow}{if}(f\&\mbox{\hyperlink{group__flags_ga4b983a15d57cd55806df618ac544d09e}{LinearAccessBit}})             res += \textcolor{stringliteral}{"{} | Linear"{}};}
\DoxyCodeLine{754   \textcolor{keywordflow}{if}(f\&\mbox{\hyperlink{group__flags_gae2c323957f20dfdc6cb8f44428eaec1a}{LvalueBit}})                   res += \textcolor{stringliteral}{"{} | Lvalue"{}};}
\DoxyCodeLine{755   \textcolor{keywordflow}{if}(f\&\mbox{\hyperlink{group__flags_gabf1e9d0516a933445a4c307ad8f14915}{DirectAccessBit}})             res += \textcolor{stringliteral}{"{} | Direct"{}};}
\DoxyCodeLine{756   \textcolor{keywordflow}{if}(f\&NestByRefBit)                res += \textcolor{stringliteral}{"{} | NestByRef"{}};}
\DoxyCodeLine{757   \textcolor{keywordflow}{if}(f\&\mbox{\hyperlink{group__flags_ga3c186ad80ddcf5e2ed3d7ee31cca1860}{NoPreferredStorageOrderBit}})  res += \textcolor{stringliteral}{"{} | NoPreferredStorageOrderBit"{}};}
\DoxyCodeLine{758 }
\DoxyCodeLine{759   \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{760 \}}
\DoxyCodeLine{761 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{762 }
\DoxyCodeLine{763 \} \textcolor{comment}{// end namespace internal}}
\DoxyCodeLine{764 }
\DoxyCodeLine{765 }
\DoxyCodeLine{802 \textcolor{keyword}{template}<\textcolor{keyword}{typename} ScalarA, \textcolor{keyword}{typename} ScalarB, \textcolor{keyword}{typename} BinaryOp=\textcolor{keywordtype}{int}ernal::scalar\_product\_op<ScalarA,ScalarB> >}
\DoxyCodeLine{803 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1ScalarBinaryOpTraits}{ScalarBinaryOpTraits}}}
\DoxyCodeLine{804 \#ifndef EIGEN\_PARSED\_BY\_DOXYGEN}
\DoxyCodeLine{805   \textcolor{comment}{// for backward compatibility, use the hints given by the (deprecated) internal::scalar\_product\_traits class.}}
\DoxyCodeLine{806   : \mbox{\hyperlink{structEigen_1_1internal_1_1scalar__product__traits}{internal::scalar\_product\_traits}}<ScalarA,ScalarB>}
\DoxyCodeLine{807 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// EIGEN\_PARSED\_BY\_DOXYGEN}}
\DoxyCodeLine{808 \{\};}
\DoxyCodeLine{809 }
\DoxyCodeLine{810 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} BinaryOp>}
\DoxyCodeLine{811 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1ScalarBinaryOpTraits}{ScalarBinaryOpTraits}}<T,T,BinaryOp>}
\DoxyCodeLine{812 \{}
\DoxyCodeLine{813   \textcolor{keyword}{typedef} T ReturnType;}
\DoxyCodeLine{814 \};}
\DoxyCodeLine{815 }
\DoxyCodeLine{816 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} BinaryOp>}
\DoxyCodeLine{817 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1ScalarBinaryOpTraits}{ScalarBinaryOpTraits}}<T, typename \mbox{\hyperlink{structEigen_1_1NumTraits}{NumTraits}}<typename internal::enable\_if<NumTraits<T>::IsComplex,T>::type>::Real, BinaryOp>}
\DoxyCodeLine{818 \{}
\DoxyCodeLine{819   \textcolor{keyword}{typedef} T ReturnType;}
\DoxyCodeLine{820 \};}
\DoxyCodeLine{821 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} BinaryOp>}
\DoxyCodeLine{822 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1ScalarBinaryOpTraits}{ScalarBinaryOpTraits}}<typename \mbox{\hyperlink{structEigen_1_1NumTraits}{NumTraits}}<typename internal::enable\_if<NumTraits<T>::IsComplex,T>::type>::Real, T, BinaryOp>}
\DoxyCodeLine{823 \{}
\DoxyCodeLine{824   \textcolor{keyword}{typedef} T ReturnType;}
\DoxyCodeLine{825 \};}
\DoxyCodeLine{826 }
\DoxyCodeLine{827 \textcolor{comment}{// For Matrix * Permutation}}
\DoxyCodeLine{828 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} BinaryOp>}
\DoxyCodeLine{829 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1ScalarBinaryOpTraits}{ScalarBinaryOpTraits}}<T,void,BinaryOp>}
\DoxyCodeLine{830 \{}
\DoxyCodeLine{831   \textcolor{keyword}{typedef} T ReturnType;}
\DoxyCodeLine{832 \};}
\DoxyCodeLine{833 }
\DoxyCodeLine{834 \textcolor{comment}{// For Permutation * Matrix}}
\DoxyCodeLine{835 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} BinaryOp>}
\DoxyCodeLine{836 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1ScalarBinaryOpTraits}{ScalarBinaryOpTraits}}<void,T,BinaryOp>}
\DoxyCodeLine{837 \{}
\DoxyCodeLine{838   \textcolor{keyword}{typedef} T ReturnType;}
\DoxyCodeLine{839 \};}
\DoxyCodeLine{840 }
\DoxyCodeLine{841 \textcolor{comment}{// for Permutation*Permutation}}
\DoxyCodeLine{842 \textcolor{keyword}{template}<\textcolor{keyword}{typename} BinaryOp>}
\DoxyCodeLine{843 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1ScalarBinaryOpTraits}{ScalarBinaryOpTraits}}<void,void,BinaryOp>}
\DoxyCodeLine{844 \{}
\DoxyCodeLine{845   \textcolor{keyword}{typedef} \textcolor{keywordtype}{void} ReturnType;}
\DoxyCodeLine{846 \};}
\DoxyCodeLine{847 }
\DoxyCodeLine{848 \textcolor{comment}{// We require Lhs and Rhs to have "{}compatible"{} scalar types.}}
\DoxyCodeLine{849 \textcolor{comment}{// It is tempting to always allow mixing different types but remember that this is often impossible in the vectorized paths.}}
\DoxyCodeLine{850 \textcolor{comment}{// So allowing mixing different types gives very unexpected errors when enabling vectorization, when the user tries to}}
\DoxyCodeLine{851 \textcolor{comment}{// add together a float matrix and a double matrix.}}
\DoxyCodeLine{852 \textcolor{preprocessor}{\#define EIGEN\_CHECK\_BINARY\_COMPATIBILIY(BINOP,LHS,RHS) \(\backslash\)}}
\DoxyCodeLine{853 \textcolor{preprocessor}{  EIGEN\_STATIC\_ASSERT((Eigen::internal::has\_ReturnType<ScalarBinaryOpTraits<LHS, RHS,BINOP> >::value), \(\backslash\)}}
\DoxyCodeLine{854 \textcolor{preprocessor}{    YOU\_MIXED\_DIFFERENT\_NUMERIC\_TYPES\_\_YOU\_NEED\_TO\_USE\_THE\_CAST\_METHOD\_OF\_MATRIXBASE\_TO\_CAST\_NUMERIC\_TYPES\_EXPLICITLY)}}
\DoxyCodeLine{855 }
\DoxyCodeLine{856 \} \textcolor{comment}{// end namespace Eigen}}
\DoxyCodeLine{857 }
\DoxyCodeLine{858 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// EIGEN\_XPRHELPER\_H}}

\end{DoxyCode}
