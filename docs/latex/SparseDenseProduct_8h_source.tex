\hypertarget{SparseDenseProduct_8h_source}{}\doxysection{Sparse\+Dense\+Product.\+h}
\label{SparseDenseProduct_8h_source}\index{include/Eigen/src/SparseCore/SparseDenseProduct.h@{include/Eigen/src/SparseCore/SparseDenseProduct.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// This file is part of Eigen, a lightweight C++ template library}}
\DoxyCodeLine{2 \textcolor{comment}{// for linear algebra.}}
\DoxyCodeLine{3 \textcolor{comment}{//}}
\DoxyCodeLine{4 \textcolor{comment}{// Copyright (C) 2008-\/2015 Gael Guennebaud <gael.guennebaud@inria.fr>}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// This Source Code Form is subject to the terms of the Mozilla}}
\DoxyCodeLine{7 \textcolor{comment}{// Public License v. 2.0. If a copy of the MPL was not distributed}}
\DoxyCodeLine{8 \textcolor{comment}{// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.}}
\DoxyCodeLine{9 }
\DoxyCodeLine{10 \textcolor{preprocessor}{\#ifndef EIGEN\_SPARSEDENSEPRODUCT\_H}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#define EIGEN\_SPARSEDENSEPRODUCT\_H}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include "{}./InternalHeaderCheck.h"{}}}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceEigen}{Eigen}} \{ }
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}},\mbox{\hyperlink{structEigen_1_1Dense}{Dense}}, OuterProduct> \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}} \mbox{\hyperlink{structEigen_1_1Sparse}{ret}}; \};}
\DoxyCodeLine{20 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__promote__storage__type}{product\_promote\_storage\_type}}<\mbox{\hyperlink{structEigen_1_1Dense}{Dense}},\mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}}, OuterProduct> \{ \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}} \mbox{\hyperlink{structEigen_1_1Sparse}{ret}}; \};}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType,}
\DoxyCodeLine{23          \textcolor{keyword}{typename} AlphaType,}
\DoxyCodeLine{24          \textcolor{keywordtype}{int} LhsStorageOrder = ((SparseLhsType::Flags\&\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}})==\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}}) ? \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}} : \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62}{ColMajor}},}
\DoxyCodeLine{25          \textcolor{keywordtype}{bool} ColPerCol = ((DenseRhsType::Flags\&\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}})==0) || DenseRhsType::ColsAtCompileTime==1>}
\DoxyCodeLine{26 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1sparse__time__dense__product__impl}{sparse\_time\_dense\_product\_impl}};}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType>}
\DoxyCodeLine{29 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1sparse__time__dense__product__impl}{sparse\_time\_dense\_product\_impl}}<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::Scalar, \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}}, true>}
\DoxyCodeLine{30 \{}
\DoxyCodeLine{31   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<SparseLhsType>::type Lhs;}
\DoxyCodeLine{32   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseRhsType>::type Rhs;}
\DoxyCodeLine{33   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseResType>::type Res;}
\DoxyCodeLine{34   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{evaluator<Lhs>::InnerIterator}} LhsInnerIterator;}
\DoxyCodeLine{35   \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{evaluator<Lhs>}} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{LhsEval}};}
\DoxyCodeLine{36   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} SparseLhsType\& lhs, \textcolor{keyword}{const} DenseRhsType\& rhs, DenseResType\& res, \textcolor{keyword}{const} \textcolor{keyword}{typename} Res::Scalar\& alpha)}
\DoxyCodeLine{37   \{}
\DoxyCodeLine{38     \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{LhsEval}} lhsEval(lhs);}
\DoxyCodeLine{39     }
\DoxyCodeLine{40     \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} n = lhs.outerSize();}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#ifdef EIGEN\_HAS\_OPENMP}}
\DoxyCodeLine{42     \mbox{\hyperlink{namespaceEigen_a820c0e0460934cc17eb6dacbad54a9f5}{Eigen::initParallel}}();}
\DoxyCodeLine{43     \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} threads = \mbox{\hyperlink{namespaceEigen_a9aca97d83e21b91a04ec079360dfffeb}{Eigen::nbThreads}}();}
\DoxyCodeLine{44 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{45     }
\DoxyCodeLine{46     \textcolor{keywordflow}{for}(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} c=0; c<rhs.cols(); ++c)}
\DoxyCodeLine{47     \{}
\DoxyCodeLine{48 \textcolor{preprocessor}{\#ifdef EIGEN\_HAS\_OPENMP}}
\DoxyCodeLine{49       \textcolor{comment}{// This 20000 threshold has been found experimentally on 2D and 3D Poisson problems.}}
\DoxyCodeLine{50       \textcolor{comment}{// It basically represents the minimal amount of work to be done to be worth it.}}
\DoxyCodeLine{51       \textcolor{keywordflow}{if}(threads>1 \&\& lhsEval.nonZerosEstimate() > 20000)}
\DoxyCodeLine{52       \{}
\DoxyCodeLine{53 \textcolor{preprocessor}{        \#pragma omp parallel for schedule(dynamic,(n+threads*4-\/1)/(threads*4)) num\_threads(threads)}}
\DoxyCodeLine{54         \textcolor{keywordflow}{for}(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i=0; i<n; ++i)}
\DoxyCodeLine{55           processRow(lhsEval,rhs,res,alpha,i,c);}
\DoxyCodeLine{56       \}}
\DoxyCodeLine{57       \textcolor{keywordflow}{else}}
\DoxyCodeLine{58 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{59       \{}
\DoxyCodeLine{60         \textcolor{keywordflow}{for}(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i=0; i<n; ++i)}
\DoxyCodeLine{61           processRow(lhsEval,rhs,res,alpha,i,c);}
\DoxyCodeLine{62       \}}
\DoxyCodeLine{63     \}}
\DoxyCodeLine{64   \}}
\DoxyCodeLine{65   }
\DoxyCodeLine{66   \textcolor{keyword}{static} \textcolor{keywordtype}{void} processRow(\textcolor{keyword}{const} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{LhsEval}}\& lhsEval, \textcolor{keyword}{const} DenseRhsType\& rhs, DenseResType\& res, \textcolor{keyword}{const} \textcolor{keyword}{typename} Res::Scalar\& alpha, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)}
\DoxyCodeLine{67   \{}
\DoxyCodeLine{68     \textcolor{keyword}{typename} Res::Scalar tmp(0);}
\DoxyCodeLine{69     \textcolor{keywordflow}{for}(LhsInnerIterator it(lhsEval,i); it ;++it)}
\DoxyCodeLine{70       tmp += it.value() * rhs.coeff(it.index(),col);}
\DoxyCodeLine{71     res.coeffRef(i,col) += alpha * tmp;}
\DoxyCodeLine{72   \}}
\DoxyCodeLine{73   }
\DoxyCodeLine{74 \};}
\DoxyCodeLine{75 }
\DoxyCodeLine{76 \textcolor{comment}{// FIXME: what is the purpose of the following specialization? Is it for the BlockedSparse format?}}
\DoxyCodeLine{77 \textcolor{comment}{// -\/> let's disable it for now as it is conflicting with generic scalar*matrix and matrix*scalar operators}}
\DoxyCodeLine{78 \textcolor{comment}{// template<typename T1, typename T2/*, int Options\_, typename \_StrideType*/>}}
\DoxyCodeLine{79 \textcolor{comment}{// struct ScalarBinaryOpTraits<T1, Ref<T2/*, Options\_, \_StrideType*/> >}}
\DoxyCodeLine{80 \textcolor{comment}{// \{}}
\DoxyCodeLine{81 \textcolor{comment}{//   enum \{}}
\DoxyCodeLine{82 \textcolor{comment}{//     Defined = 1}}
\DoxyCodeLine{83 \textcolor{comment}{//   \};}}
\DoxyCodeLine{84 \textcolor{comment}{//   typedef typename CwiseUnaryOp<scalar\_multiple2\_op<T1, typename T2::Scalar>, T2>::PlainObject ReturnType;}}
\DoxyCodeLine{85 \textcolor{comment}{// \};}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType, \textcolor{keyword}{typename} AlphaType>}
\DoxyCodeLine{88 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1sparse__time__dense__product__impl}{sparse\_time\_dense\_product\_impl}}<SparseLhsType,DenseRhsType,DenseResType, AlphaType, \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62}{ColMajor}}, true>}
\DoxyCodeLine{89 \{}
\DoxyCodeLine{90   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<SparseLhsType>::type Lhs;}
\DoxyCodeLine{91   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseRhsType>::type Rhs;}
\DoxyCodeLine{92   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseResType>::type Res;}
\DoxyCodeLine{93   \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{evaluator<Lhs>}} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{LhsEval}};}
\DoxyCodeLine{94   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsEval::InnerIterator LhsInnerIterator;}
\DoxyCodeLine{95   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} SparseLhsType\& lhs, \textcolor{keyword}{const} DenseRhsType\& rhs, DenseResType\& res, \textcolor{keyword}{const} AlphaType\& alpha)}
\DoxyCodeLine{96   \{}
\DoxyCodeLine{97     \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{LhsEval}} lhsEval(lhs);}
\DoxyCodeLine{98     \textcolor{keywordflow}{for}(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} c=0; c<rhs.cols(); ++c)}
\DoxyCodeLine{99     \{}
\DoxyCodeLine{100       \textcolor{keywordflow}{for}(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} j=0; j<lhs.outerSize(); ++j)}
\DoxyCodeLine{101       \{}
\DoxyCodeLine{102 \textcolor{comment}{//        typename Res::Scalar rhs\_j = alpha * rhs.coeff(j,c);}}
\DoxyCodeLine{103         \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1ScalarBinaryOpTraits}{ScalarBinaryOpTraits<AlphaType, typename Rhs::Scalar>::ReturnType}} rhs\_j(alpha * rhs.coeff(j,c));}
\DoxyCodeLine{104         \textcolor{keywordflow}{for}(LhsInnerIterator it(lhsEval,j); it ;++it)}
\DoxyCodeLine{105           res.coeffRef(it.index(),c) += it.value() * rhs\_j;}
\DoxyCodeLine{106       \}}
\DoxyCodeLine{107     \}}
\DoxyCodeLine{108   \}}
\DoxyCodeLine{109 \};}
\DoxyCodeLine{110 }
\DoxyCodeLine{111 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType>}
\DoxyCodeLine{112 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1sparse__time__dense__product__impl}{sparse\_time\_dense\_product\_impl}}<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::Scalar, \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f}{RowMajor}}, false>}
\DoxyCodeLine{113 \{}
\DoxyCodeLine{114   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<SparseLhsType>::type Lhs;}
\DoxyCodeLine{115   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseRhsType>::type Rhs;}
\DoxyCodeLine{116   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseResType>::type Res;}
\DoxyCodeLine{117   \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{evaluator<Lhs>}} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{LhsEval}};}
\DoxyCodeLine{118   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} LhsEval::InnerIterator LhsInnerIterator;}
\DoxyCodeLine{119   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} SparseLhsType\& lhs, \textcolor{keyword}{const} DenseRhsType\& rhs, DenseResType\& res, \textcolor{keyword}{const} \textcolor{keyword}{typename} Res::Scalar\& alpha)}
\DoxyCodeLine{120   \{}
\DoxyCodeLine{121     \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} n = lhs.rows();}
\DoxyCodeLine{122     \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{LhsEval}} lhsEval(lhs);}
\DoxyCodeLine{123 }
\DoxyCodeLine{124 \textcolor{preprocessor}{\#ifdef EIGEN\_HAS\_OPENMP}}
\DoxyCodeLine{125     \mbox{\hyperlink{namespaceEigen_a820c0e0460934cc17eb6dacbad54a9f5}{Eigen::initParallel}}();}
\DoxyCodeLine{126     \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} threads = \mbox{\hyperlink{namespaceEigen_a9aca97d83e21b91a04ec079360dfffeb}{Eigen::nbThreads}}();}
\DoxyCodeLine{127     \textcolor{comment}{// This 20000 threshold has been found experimentally on 2D and 3D Poisson problems.}}
\DoxyCodeLine{128     \textcolor{comment}{// It basically represents the minimal amount of work to be done to be worth it.}}
\DoxyCodeLine{129     \textcolor{keywordflow}{if}(threads>1 \&\& lhsEval.nonZerosEstimate()*rhs.cols() > 20000)}
\DoxyCodeLine{130     \{}
\DoxyCodeLine{131 \textcolor{preprocessor}{      \#pragma omp parallel for schedule(dynamic,(n+threads*4-\/1)/(threads*4)) num\_threads(threads)}}
\DoxyCodeLine{132       \textcolor{keywordflow}{for}(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i=0; i<n; ++i)}
\DoxyCodeLine{133         processRow(lhsEval,rhs,res,alpha,i);}
\DoxyCodeLine{134     \}}
\DoxyCodeLine{135     \textcolor{keywordflow}{else}}
\DoxyCodeLine{136 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{137     \{}
\DoxyCodeLine{138       \textcolor{keywordflow}{for}(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i=0; i<n; ++i)}
\DoxyCodeLine{139         processRow(lhsEval, rhs, res, alpha, i);}
\DoxyCodeLine{140     \}}
\DoxyCodeLine{141   \}}
\DoxyCodeLine{142 }
\DoxyCodeLine{143   \textcolor{keyword}{static} \textcolor{keywordtype}{void} processRow(\textcolor{keyword}{const} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{LhsEval}}\& lhsEval, \textcolor{keyword}{const} DenseRhsType\& rhs, Res\& res, \textcolor{keyword}{const} \textcolor{keyword}{typename} Res::Scalar\& alpha, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i)}
\DoxyCodeLine{144   \{}
\DoxyCodeLine{145     \textcolor{keyword}{typename} Res::RowXpr res\_i(res.row(i));}
\DoxyCodeLine{146     \textcolor{keywordflow}{for}(LhsInnerIterator it(lhsEval,i); it ;++it)}
\DoxyCodeLine{147       res\_i += (alpha*it.value()) * rhs.row(it.index());}
\DoxyCodeLine{148   \}}
\DoxyCodeLine{149 \};}
\DoxyCodeLine{150 }
\DoxyCodeLine{151 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType>}
\DoxyCodeLine{152 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1sparse__time__dense__product__impl}{sparse\_time\_dense\_product\_impl}}<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::Scalar, \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0103672ae41005ab03b4176c765afd62}{ColMajor}}, false>}
\DoxyCodeLine{153 \{}
\DoxyCodeLine{154   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<SparseLhsType>::type Lhs;}
\DoxyCodeLine{155   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseRhsType>::type Rhs;}
\DoxyCodeLine{156   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::remove\_all<DenseResType>::type Res;}
\DoxyCodeLine{157   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{evaluator<Lhs>::InnerIterator}} LhsInnerIterator;}
\DoxyCodeLine{158   \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} SparseLhsType\& lhs, \textcolor{keyword}{const} DenseRhsType\& rhs, DenseResType\& res, \textcolor{keyword}{const} \textcolor{keyword}{typename} Res::Scalar\& alpha)}
\DoxyCodeLine{159   \{}
\DoxyCodeLine{160     \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{evaluator<Lhs>}} lhsEval(lhs);}
\DoxyCodeLine{161     \textcolor{keywordflow}{for}(\mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} j=0; j<lhs.outerSize(); ++j)}
\DoxyCodeLine{162     \{}
\DoxyCodeLine{163       \textcolor{keyword}{typename} Rhs::ConstRowXpr rhs\_j(rhs.row(j));}
\DoxyCodeLine{164       \textcolor{keywordflow}{for}(LhsInnerIterator it(lhsEval,j); it ;++it)}
\DoxyCodeLine{165         res.row(it.index()) += (alpha*it.value()) * rhs\_j;}
\DoxyCodeLine{166     \}}
\DoxyCodeLine{167   \}}
\DoxyCodeLine{168 \};}
\DoxyCodeLine{169 }
\DoxyCodeLine{170 \textcolor{keyword}{template}<\textcolor{keyword}{typename} SparseLhsType, \textcolor{keyword}{typename} DenseRhsType, \textcolor{keyword}{typename} DenseResType,\textcolor{keyword}{typename} AlphaType>}
\DoxyCodeLine{171 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} sparse\_time\_dense\_product(\textcolor{keyword}{const} SparseLhsType\& lhs, \textcolor{keyword}{const} DenseRhsType\& rhs, DenseResType\& res, \textcolor{keyword}{const} AlphaType\& alpha)}
\DoxyCodeLine{172 \{}
\DoxyCodeLine{173   \mbox{\hyperlink{structEigen_1_1internal_1_1sparse__time__dense__product__impl}{sparse\_time\_dense\_product\_impl<SparseLhsType,DenseRhsType,DenseResType, AlphaType>::run}}(lhs, rhs, res, alpha);}
\DoxyCodeLine{174 \}}
\DoxyCodeLine{175 }
\DoxyCodeLine{176 \} \textcolor{comment}{// end namespace internal}}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 \textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{179 }
\DoxyCodeLine{180 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductType>}
\DoxyCodeLine{181 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1generic__product__impl}{generic\_product\_impl}}<Lhs, Rhs, \mbox{\hyperlink{structEigen_1_1SparseShape}{SparseShape}}, \mbox{\hyperlink{structEigen_1_1DenseShape}{DenseShape}}, ProductType>}
\DoxyCodeLine{182  : \mbox{\hyperlink{structEigen_1_1internal_1_1generic__product__impl__base}{generic\_product\_impl\_base}}<Lhs,Rhs,generic\_product\_impl<Lhs,Rhs,SparseShape,DenseShape,ProductType> >}
\DoxyCodeLine{183 \{}
\DoxyCodeLine{184   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classEigen_1_1Product}{Product<Lhs,Rhs>::Scalar}} Scalar;}
\DoxyCodeLine{185   }
\DoxyCodeLine{186   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dest>}
\DoxyCodeLine{187   \textcolor{keyword}{static} \textcolor{keywordtype}{void} scaleAndAddTo(Dest\& dst, \textcolor{keyword}{const} Lhs\& lhs, \textcolor{keyword}{const} Rhs\& rhs, \textcolor{keyword}{const} Scalar\& alpha)}
\DoxyCodeLine{188   \{}
\DoxyCodeLine{189     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1nested__eval}{nested\_eval}}<Lhs,((Rhs::Flags\&\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}})==0) ? 1 : Rhs::ColsAtCompileTime>::type LhsNested;}
\DoxyCodeLine{190     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1nested__eval}{nested\_eval}}<Rhs,((Lhs::Flags\&\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}})==0) ? 1 : \mbox{\hyperlink{namespaceEigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}>::type RhsNested;}
\DoxyCodeLine{191     LhsNested lhsNested(lhs);}
\DoxyCodeLine{192     RhsNested rhsNested(rhs);}
\DoxyCodeLine{193     internal::sparse\_time\_dense\_product(lhsNested, rhsNested, dst, alpha);}
\DoxyCodeLine{194   \}}
\DoxyCodeLine{195 \};}
\DoxyCodeLine{196 }
\DoxyCodeLine{197 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductType>}
\DoxyCodeLine{198 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1generic__product__impl}{generic\_product\_impl}}<Lhs, Rhs, \mbox{\hyperlink{structEigen_1_1internal_1_1SparseTriangularShape}{SparseTriangularShape}}, \mbox{\hyperlink{structEigen_1_1DenseShape}{DenseShape}}, ProductType>}
\DoxyCodeLine{199   : \mbox{\hyperlink{structEigen_1_1internal_1_1generic__product__impl}{generic\_product\_impl}}<Lhs, Rhs, SparseShape, DenseShape, ProductType>}
\DoxyCodeLine{200 \{\};}
\DoxyCodeLine{201 }
\DoxyCodeLine{202 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductType>}
\DoxyCodeLine{203 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1generic__product__impl}{generic\_product\_impl}}<Lhs, Rhs, \mbox{\hyperlink{structEigen_1_1DenseShape}{DenseShape}}, \mbox{\hyperlink{structEigen_1_1SparseShape}{SparseShape}}, ProductType>}
\DoxyCodeLine{204   : \mbox{\hyperlink{structEigen_1_1internal_1_1generic__product__impl__base}{generic\_product\_impl\_base}}<Lhs,Rhs,generic\_product\_impl<Lhs,Rhs,DenseShape,SparseShape,ProductType> >}
\DoxyCodeLine{205 \{}
\DoxyCodeLine{206   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{classEigen_1_1Product}{Product<Lhs,Rhs>::Scalar}} Scalar;}
\DoxyCodeLine{207   }
\DoxyCodeLine{208   \textcolor{keyword}{template}<\textcolor{keyword}{typename} Dst>}
\DoxyCodeLine{209   \textcolor{keyword}{static} \textcolor{keywordtype}{void} scaleAndAddTo(Dst\& dst, \textcolor{keyword}{const} Lhs\& lhs, \textcolor{keyword}{const} Rhs\& rhs, \textcolor{keyword}{const} Scalar\& alpha)}
\DoxyCodeLine{210   \{}
\DoxyCodeLine{211     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1nested__eval}{nested\_eval}}<Lhs,((Rhs::Flags\&\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}})==0) ? \mbox{\hyperlink{namespaceEigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}} : 1>::type LhsNested;}
\DoxyCodeLine{212     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1nested__eval}{nested\_eval}}<Rhs,((Lhs::Flags\&\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}})==\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}}) ? 1 : Lhs::RowsAtCompileTime>::type RhsNested;}
\DoxyCodeLine{213     LhsNested lhsNested(lhs);}
\DoxyCodeLine{214     RhsNested rhsNested(rhs);}
\DoxyCodeLine{215     }
\DoxyCodeLine{216     \textcolor{comment}{// transpose everything}}
\DoxyCodeLine{217     \mbox{\hyperlink{classEigen_1_1Transpose}{Transpose<Dst>}} dstT(dst);}
\DoxyCodeLine{218     internal::sparse\_time\_dense\_product(rhsNested.transpose(), lhsNested.transpose(), dstT, alpha);}
\DoxyCodeLine{219   \}}
\DoxyCodeLine{220 \};}
\DoxyCodeLine{221 }
\DoxyCodeLine{222 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs, \textcolor{keywordtype}{int} ProductType>}
\DoxyCodeLine{223 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1generic__product__impl}{generic\_product\_impl}}<Lhs, Rhs, \mbox{\hyperlink{structEigen_1_1DenseShape}{DenseShape}}, \mbox{\hyperlink{structEigen_1_1internal_1_1SparseTriangularShape}{SparseTriangularShape}}, ProductType>}
\DoxyCodeLine{224   : \mbox{\hyperlink{structEigen_1_1internal_1_1generic__product__impl}{generic\_product\_impl}}<Lhs, Rhs, DenseShape, SparseShape, ProductType>}
\DoxyCodeLine{225 \{\};}
\DoxyCodeLine{226 }
\DoxyCodeLine{227 \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT, \textcolor{keywordtype}{bool} NeedToTranspose>}
\DoxyCodeLine{228 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1sparse__dense__outer__product__evaluator}{sparse\_dense\_outer\_product\_evaluator}}}
\DoxyCodeLine{229 \{}
\DoxyCodeLine{230 \textcolor{keyword}{protected}:}
\DoxyCodeLine{231   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{conditional<NeedToTranspose,RhsT,LhsT>::type}} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{Lhs1}};}
\DoxyCodeLine{232   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{conditional<NeedToTranspose,LhsT,RhsT>::type}} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{ActualRhs}};}
\DoxyCodeLine{233   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Product}{Product<LhsT,RhsT,DefaultProduct>}} \mbox{\hyperlink{classEigen_1_1Product}{ProdXprType}};}
\DoxyCodeLine{234   }
\DoxyCodeLine{235   \textcolor{comment}{// if the actual left-\/hand side is a dense vector,}}
\DoxyCodeLine{236   \textcolor{comment}{// then build a sparse-\/view so that we can seamlessly iterate over it.}}
\DoxyCodeLine{237   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional<is\_same<typename internal::traits<Lhs1>::StorageKind}},\mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}}>::value,}
\DoxyCodeLine{238             \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{Lhs1}}, \mbox{\hyperlink{classEigen_1_1SparseView}{SparseView<Lhs1>}} >::type \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{ActualLhs}};}
\DoxyCodeLine{239   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1conditional}{conditional<is\_same<typename internal::traits<Lhs1>::StorageKind}},\mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}}>::value,}
\DoxyCodeLine{240             \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{Lhs1}} \textcolor{keyword}{const}\&, \mbox{\hyperlink{classEigen_1_1SparseView}{SparseView<Lhs1>}} >::type \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{LhsArg}};}
\DoxyCodeLine{241             }
\DoxyCodeLine{242   \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{evaluator<ActualLhs>}} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{LhsEval}};}
\DoxyCodeLine{243   \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{evaluator<ActualRhs>}} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{RhsEval}};}
\DoxyCodeLine{244   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{evaluator<ActualLhs>::InnerIterator}} LhsIterator;}
\DoxyCodeLine{245   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} ProdXprType::Scalar Scalar;}
\DoxyCodeLine{246   }
\DoxyCodeLine{247 \textcolor{keyword}{public}:}
\DoxyCodeLine{248   \textcolor{keyword}{enum} \{}
\DoxyCodeLine{249     Flags = NeedToTranspose ? \mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{RowMajorBit}} : 0,}
\DoxyCodeLine{250     CoeffReadCost = \mbox{\hyperlink{namespaceEigen_a3163430a1c13173faffde69016b48aaf}{HugeCost}}}
\DoxyCodeLine{251   \};}
\DoxyCodeLine{252   }
\DoxyCodeLine{253   \textcolor{keyword}{class }\mbox{\hyperlink{classEigen_1_1internal_1_1sparse__dense__outer__product__evaluator_1_1InnerIterator}{InnerIterator}} : \textcolor{keyword}{public} LhsIterator}
\DoxyCodeLine{254   \{}
\DoxyCodeLine{255   \textcolor{keyword}{public}:}
\DoxyCodeLine{256     \mbox{\hyperlink{classEigen_1_1internal_1_1sparse__dense__outer__product__evaluator_1_1InnerIterator}{InnerIterator}}(\textcolor{keyword}{const} \mbox{\hyperlink{structEigen_1_1internal_1_1sparse__dense__outer__product__evaluator}{sparse\_dense\_outer\_product\_evaluator}} \&xprEval, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer)}
\DoxyCodeLine{257       : LhsIterator(xprEval.m\_lhsXprImpl, 0),}
\DoxyCodeLine{258         m\_outer(outer),}
\DoxyCodeLine{259         m\_empty(\textcolor{keyword}{false}),}
\DoxyCodeLine{260         m\_factor(get(xprEval.m\_rhsXprImpl, outer, \textcolor{keyword}{typename} \mbox{\hyperlink{structEigen_1_1internal_1_1traits}{internal::traits<ActualRhs>::StorageKind}}() ))}
\DoxyCodeLine{261     \{\}}
\DoxyCodeLine{262     }
\DoxyCodeLine{263     EIGEN\_STRONG\_INLINE \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_outer; \}}
\DoxyCodeLine{264     EIGEN\_STRONG\_INLINE \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row()\textcolor{keyword}{   const }\{ \textcolor{keywordflow}{return} NeedToTranspose ? m\_outer : LhsIterator::index(); \}}
\DoxyCodeLine{265     EIGEN\_STRONG\_INLINE \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col()\textcolor{keyword}{   const }\{ \textcolor{keywordflow}{return} NeedToTranspose ? LhsIterator::index() : m\_outer; \}}
\DoxyCodeLine{266 }
\DoxyCodeLine{267     EIGEN\_STRONG\_INLINE Scalar value()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} LhsIterator::value() * m\_factor; \}}
\DoxyCodeLine{268     EIGEN\_STRONG\_INLINE \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} LhsIterator::operator bool() \&\& (!m\_empty); \}}
\DoxyCodeLine{269     }
\DoxyCodeLine{270   \textcolor{keyword}{protected}:}
\DoxyCodeLine{271     Scalar get(\textcolor{keyword}{const} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{RhsEval}} \&rhs, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer, \mbox{\hyperlink{structEigen_1_1Dense}{Dense}} = \mbox{\hyperlink{structEigen_1_1Dense}{Dense}}())\textcolor{keyword}{ const}}
\DoxyCodeLine{272 \textcolor{keyword}{    }\{}
\DoxyCodeLine{273       \textcolor{keywordflow}{return} rhs.coeff(outer);}
\DoxyCodeLine{274     \}}
\DoxyCodeLine{275     }
\DoxyCodeLine{276     Scalar get(\textcolor{keyword}{const} \mbox{\hyperlink{structEigen_1_1internal_1_1evaluator}{RhsEval}} \&rhs, \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer, \mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}} = \mbox{\hyperlink{structEigen_1_1Sparse}{Sparse}}())}
\DoxyCodeLine{277     \{}
\DoxyCodeLine{278       \textcolor{keyword}{typename} RhsEval::InnerIterator it(rhs, outer);}
\DoxyCodeLine{279       \textcolor{keywordflow}{if} (it \&\& it.index()==0 \&\& it.value()!=Scalar(0))}
\DoxyCodeLine{280         \textcolor{keywordflow}{return} it.value();}
\DoxyCodeLine{281       m\_empty = \textcolor{keyword}{true};}
\DoxyCodeLine{282       \textcolor{keywordflow}{return} Scalar(0);}
\DoxyCodeLine{283     \}}
\DoxyCodeLine{284     }
\DoxyCodeLine{285     \mbox{\hyperlink{namespaceEigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} m\_outer;}
\DoxyCodeLine{286     \textcolor{keywordtype}{bool} m\_empty;}
\DoxyCodeLine{287     Scalar m\_factor;}
\DoxyCodeLine{288   \};}
\DoxyCodeLine{289   }
\DoxyCodeLine{290   \mbox{\hyperlink{structEigen_1_1internal_1_1sparse__dense__outer__product__evaluator}{sparse\_dense\_outer\_product\_evaluator}}(\textcolor{keyword}{const} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{Lhs1}} \&lhs, \textcolor{keyword}{const} \mbox{\hyperlink{structEigen_1_1internal_1_1true__type}{ActualRhs}} \&rhs)}
\DoxyCodeLine{291      : m\_lhs(lhs), m\_lhsXprImpl(m\_lhs), m\_rhsXprImpl(rhs)}
\DoxyCodeLine{292   \{}
\DoxyCodeLine{293     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);}
\DoxyCodeLine{294   \}}
\DoxyCodeLine{295   }
\DoxyCodeLine{296   \textcolor{comment}{// transpose case}}
\DoxyCodeLine{297   \mbox{\hyperlink{structEigen_1_1internal_1_1sparse__dense__outer__product__evaluator}{sparse\_dense\_outer\_product\_evaluator}}(\textcolor{keyword}{const} ActualRhs \&rhs, \textcolor{keyword}{const} Lhs1 \&lhs)}
\DoxyCodeLine{298      : m\_lhs(lhs), m\_lhsXprImpl(m\_lhs), m\_rhsXprImpl(rhs)}
\DoxyCodeLine{299   \{}
\DoxyCodeLine{300     EIGEN\_INTERNAL\_CHECK\_COST\_VALUE(CoeffReadCost);}
\DoxyCodeLine{301   \}}
\DoxyCodeLine{302     }
\DoxyCodeLine{303 \textcolor{keyword}{protected}:}
\DoxyCodeLine{304   \textcolor{keyword}{const} LhsArg m\_lhs;}
\DoxyCodeLine{305   evaluator<ActualLhs> m\_lhsXprImpl;}
\DoxyCodeLine{306   evaluator<ActualRhs> m\_rhsXprImpl;}
\DoxyCodeLine{307 \};}
\DoxyCodeLine{308 }
\DoxyCodeLine{309 \textcolor{comment}{// sparse * dense outer product}}
\DoxyCodeLine{310 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{311 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__evaluator}{product\_evaluator}}<\mbox{\hyperlink{classEigen_1_1Product}{Product}}<Lhs, Rhs, DefaultProduct>, OuterProduct, \mbox{\hyperlink{structEigen_1_1SparseShape}{SparseShape}}, \mbox{\hyperlink{structEigen_1_1DenseShape}{DenseShape}}>}
\DoxyCodeLine{312   : \mbox{\hyperlink{structEigen_1_1internal_1_1sparse__dense__outer__product__evaluator}{sparse\_dense\_outer\_product\_evaluator}}<Lhs,Rhs, Lhs::IsRowMajor>}
\DoxyCodeLine{313 \{}
\DoxyCodeLine{314   \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1internal_1_1sparse__dense__outer__product__evaluator}{sparse\_dense\_outer\_product\_evaluator<Lhs,Rhs, Lhs::IsRowMajor>}} \mbox{\hyperlink{structEigen_1_1internal_1_1sparse__dense__outer__product__evaluator}{Base}};}
\DoxyCodeLine{315   }
\DoxyCodeLine{316   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Product}{Product<Lhs, Rhs>}} \mbox{\hyperlink{classEigen_1_1Product}{XprType}};}
\DoxyCodeLine{317   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::PlainObject PlainObject;}
\DoxyCodeLine{318 }
\DoxyCodeLine{319   \textcolor{keyword}{explicit} \mbox{\hyperlink{structEigen_1_1internal_1_1product__evaluator}{product\_evaluator}}(\textcolor{keyword}{const} \mbox{\hyperlink{classEigen_1_1Product}{XprType}}\& xpr)}
\DoxyCodeLine{320     : \mbox{\hyperlink{structEigen_1_1internal_1_1sparse__dense__outer__product__evaluator}{Base}}(xpr.lhs(), xpr.rhs())}
\DoxyCodeLine{321   \{\}}
\DoxyCodeLine{322   }
\DoxyCodeLine{323 \};}
\DoxyCodeLine{324 }
\DoxyCodeLine{325 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Lhs, \textcolor{keyword}{typename} Rhs>}
\DoxyCodeLine{326 \textcolor{keyword}{struct }\mbox{\hyperlink{structEigen_1_1internal_1_1product__evaluator}{product\_evaluator}}<\mbox{\hyperlink{classEigen_1_1Product}{Product}}<Lhs, Rhs, DefaultProduct>, OuterProduct, \mbox{\hyperlink{structEigen_1_1DenseShape}{DenseShape}}, \mbox{\hyperlink{structEigen_1_1SparseShape}{SparseShape}}>}
\DoxyCodeLine{327   : \mbox{\hyperlink{structEigen_1_1internal_1_1sparse__dense__outer__product__evaluator}{sparse\_dense\_outer\_product\_evaluator}}<Lhs,Rhs, Rhs::IsRowMajor>}
\DoxyCodeLine{328 \{}
\DoxyCodeLine{329   \textcolor{keyword}{typedef} \mbox{\hyperlink{structEigen_1_1internal_1_1sparse__dense__outer__product__evaluator}{sparse\_dense\_outer\_product\_evaluator<Lhs,Rhs, Rhs::IsRowMajor>}} \mbox{\hyperlink{structEigen_1_1internal_1_1sparse__dense__outer__product__evaluator}{Base}};}
\DoxyCodeLine{330   }
\DoxyCodeLine{331   \textcolor{keyword}{typedef} \mbox{\hyperlink{classEigen_1_1Product}{Product<Lhs, Rhs>}} \mbox{\hyperlink{classEigen_1_1Product}{XprType}};}
\DoxyCodeLine{332   \textcolor{keyword}{typedef} \textcolor{keyword}{typename} XprType::PlainObject PlainObject;}
\DoxyCodeLine{333 }
\DoxyCodeLine{334   \textcolor{keyword}{explicit} \mbox{\hyperlink{structEigen_1_1internal_1_1product__evaluator}{product\_evaluator}}(\textcolor{keyword}{const} \mbox{\hyperlink{classEigen_1_1Product}{XprType}}\& xpr)}
\DoxyCodeLine{335     : \mbox{\hyperlink{structEigen_1_1internal_1_1sparse__dense__outer__product__evaluator}{Base}}(xpr.lhs(), xpr.rhs())}
\DoxyCodeLine{336   \{\}}
\DoxyCodeLine{337   }
\DoxyCodeLine{338 \};}
\DoxyCodeLine{339 }
\DoxyCodeLine{340 \} \textcolor{comment}{// end namespace internal}}
\DoxyCodeLine{341 }
\DoxyCodeLine{342 \} \textcolor{comment}{// end namespace Eigen}}
\DoxyCodeLine{343 }
\DoxyCodeLine{344 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// EIGEN\_SPARSEDENSEPRODUCT\_H}}

\end{DoxyCode}
